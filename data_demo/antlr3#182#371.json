[{"index": "0", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.hasAncestor", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "public boolean hasAncestor(int ttype);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Is there is a node above with token type ttype?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "1", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getAncestor", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "public Tree getAncestor(int ttype);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Walk upwards and get first ancestor with this token type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "2", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getAncestors", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<?> getAncestors();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType)ParameterizedType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return a list of all ancestors of this node.  The first node of list is the root and the last is the parent of this node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "3", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getChildIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getChildIndex();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "This node is what child index? 0..n-1", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "4", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.freshenParentAndChildIndexes", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void freshenParentAndChildIndexes();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Set the parent and child index values for all children", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "5", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.addChild", "methodParameterType": "Tree#", "methodParameterName": "t#", "methodBody": "void addChild(Tree t);", "AST": "Javadoc#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Add t as a child to this node.  If t is null, do nothing.  If t is nil, add all children of t to this' children.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "6", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.setChild", "methodParameterType": "int#Tree#", "methodParameterName": "i#t#", "methodBody": "public void setChild(int i, Tree t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Set ith child (0..n-1) to t; t must be non-null and non-nil node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "7", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.replaceChildren", "methodParameterType": "int#int#Object#", "methodParameterName": "startChildIndex#stopChildIndex#t#", "methodBody": "public void replaceChildren(int startChildIndex, int stopChildIndex, Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Delete children from start to stop and replace with t even if t is a list (nil-root tree).  num of children can increase or decrease. For huge child lists, inserting children can force walking rest of children to set their childindex; could be slow.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "8", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.isNil", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "boolean isNil();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Indicates the node is a nil node but may still have children, meaning the tree is a flat list.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "9", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getTokenStartIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getTokenStartIndex();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "What is the smallest token index (indexing from 0) for this node and its children?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "10", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getTokenStopIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getTokenStopIndex();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "What is the largest token index (indexing from 0) for this node and its children?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "11", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getType", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getType();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return a token type; needed for tree parsing", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "12", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/Tree.java", "methodName": "org.antlr.runtime.tree.Tree.getLine", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getLine();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "In case we don't have a token payload, what is the line for errors?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "13", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.RewriteRuleElementStream", "methodParameterType": "TreeAdaptor#String#Object#", "methodParameterName": "adaptor#elementDescription#oneElement#", "methodBody": "@SuppressWarnings(\"OverridableMethodCallInConstructor\")\n\tpublic RewriteRuleElementStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t\tString elementDescription,\n\t\t\t\t\t\t\t\t\tObject oneElement)\n\t{\n\t\tthis(adaptor, elementDescription);\n\t\tadd(oneElement);\n\t}", "AST": "Javadoc#SimpleName#StringLiteral#SingleMemberAnnotation#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#ConstructorInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(SingleMemberAnnotation(SimpleName)SimpleName(StringLiteral)StringLiteral)SingleMemberAnnotation(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)ConstructorInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a stream with one element", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "14", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.RewriteRuleElementStream", "methodParameterType": "TreeAdaptor#String#List<Object>#", "methodParameterName": "adaptor#elementDescription#elements#", "methodBody": "public RewriteRuleElementStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t\tString elementDescription,\n\t\t\t\t\t\t\t\t\tList<Object> elements)\n\t{\n\t\tthis(adaptor, elementDescription);\n\t\tthis.singleElement = null;\n\t\tthis.elements = elements;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#ConstructorInvocation#ThisExpression#SimpleName#FieldAccess#NullLiteral#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)ConstructorInvocation(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a stream, but feed off an existing list", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "15", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.reset", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void reset() {\n\t\tcursor = 0;\n\t\tdirty = true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset the condition of this stream so that it appears we have not consumed any of its elements.  Elements themselves are untouched. Once we reset the stream, any future use will need duplicates.  Set the dirty bit.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "16", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.nextTree", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object nextTree() {\n\t\tint n = size();\n\t\tif ( dirty || (cursor>=n && n==1) ) {\n\t\t\t// if out of elements and size is 1, dup\n\t\t\tObject el = _next();\n\t\t\treturn dup(el);\n\t\t}\n\t\t// test size above then fetch\n\t\tObject el = _next();\n\t\treturn el;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the next element in the stream.  If out of elements, throw an exception unless size()==1.  If size is 1, then return elements[0]. Return a duplicate node/subtree if stream is out of elements and size==1.  If we've already used the element, dup (dirty bit set).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "17", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream._next", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected Object _next() {\n\t\tint n = size();\n\t\tif ( n ==0 ) {\n\t\t\tthrow new RewriteEmptyStreamException(elementDescription);\n\t\t}\n\t\tif ( cursor>= n) { // out of elements?\n\t\t\tif ( n ==1 ) {  // if size is 1, it's ok; return and we'll dup\n\t\t\t\treturn toTree(singleElement);\n\t\t\t}\n\t\t\t// out of elements and size was not 1, so we can't dup\n\t\t\tthrow new RewriteCardinalityException(elementDescription);\n\t\t}\n\t\t// we have elements\n\t\tif ( singleElement!=null ) {\n\t\t\tcursor++; // move cursor even for single element list\n\t\t\treturn toTree(singleElement);\n\t\t}\n\t\t// must have more than one in list, pull from elements\n\t\tObject o = toTree(elements.get(cursor));\n\t\tcursor++;\n\t\treturn o;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "do the work of getting the next element, making sure that it's a tree node or subtree.  Deal with the optimization of single- element list versus list of size &gt; 1.  Throw an exception if the stream is empty or we're out of elements and size&gt;1. protected so you can override in a subclass if necessary.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "18", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.dup", "methodParameterType": "Object#", "methodParameterName": "el#", "methodBody": "protected abstract Object dup(Object el);", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "When constructing trees, sometimes we need to dup a token or AST subtree.  Dup'ing a token means just creating another AST node around it.  For trees, you must call the adaptor.dupTree() unless the element is for a tree root; then it must be a node dup.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "19", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleElementStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleElementStream.toTree", "methodParameterType": "Object#", "methodParameterName": "el#", "methodBody": "protected Object toTree(Object el) {\n\t\treturn el;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Ensure stream emits trees; tokens must be converted to AST nodes. AST nodes can be passed through unmolested.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "20", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleNodeStream.RewriteRuleNodeStream", "methodParameterType": "TreeAdaptor#String#Object#", "methodParameterName": "adaptor#elementDescription#oneElement#", "methodBody": "public RewriteRuleNodeStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t String elementDescription,\n\t\t\t\t\t\t\t\t Object oneElement)\n\t{\n\t\tsuper(adaptor, elementDescription, oneElement);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream with one element", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "21", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleNodeStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleNodeStream.RewriteRuleNodeStream", "methodParameterType": "TreeAdaptor#String#List<Object>#", "methodParameterName": "adaptor#elementDescription#elements#", "methodBody": "public RewriteRuleNodeStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t String elementDescription,\n\t\t\t\t\t\t\t\t List<Object> elements)\n\t{\n\t\tsuper(adaptor, elementDescription, elements);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream, but feed off an existing list", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "22", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleSubtreeStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleSubtreeStream.RewriteRuleSubtreeStream", "methodParameterType": "TreeAdaptor#String#Object#", "methodParameterName": "adaptor#elementDescription#oneElement#", "methodBody": "public RewriteRuleSubtreeStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t\tString elementDescription,\n\t\t\t\t\t\t\t\t\tObject oneElement)\n\t{\n\t\tsuper(adaptor, elementDescription, oneElement);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream with one element", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "23", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleSubtreeStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleSubtreeStream.RewriteRuleSubtreeStream", "methodParameterType": "TreeAdaptor#String#List<Object>#", "methodParameterName": "adaptor#elementDescription#elements#", "methodBody": "public RewriteRuleSubtreeStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t\tString elementDescription,\n\t\t\t\t\t\t\t\t\tList<Object> elements)\n\t{\n\t\tsuper(adaptor, elementDescription, elements);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream, but feed off an existing list", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "24", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleSubtreeStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleSubtreeStream.nextNode", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object nextNode() {\n\t\t//System.out.println(\"nextNode: elements=\"+elements+\", singleElement=\"+((Tree)singleElement).toStringTree());\n\t\tint n = size();\n\t\tif ( dirty || (cursor>=n && n==1) ) {\n\t\t\t// if out of elements and size is 1, dup (at most a single node\n\t\t\t// since this is for making root nodes).\n\t\t\tObject el = _next();\n\t\t\treturn adaptor.dupNode(el);\n\t\t}\n\t\t// test size above then fetch\n\t\tObject tree = _next();\n\t\twhile (adaptor.isNil(tree) && adaptor.getChildCount(tree) == 1)\n\t\t\ttree = adaptor.getChild(tree, 0);\n\t\t//System.out.println(\"_next=\"+((Tree)tree).toStringTree());\n\t\tObject el = adaptor.dupNode(tree); // dup just the root (want node here)\n\t\treturn el;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#WhileStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)WhileStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Treat next element as a single node even if it's a subtree. This is used instead of next() when the result has to be a tree root node.  Also prevents us from duplicating recently-added children; e.g., ^(type ID)+ adds ID to type and then 2nd iteration must dup the type node, but ID has been added. Referencing a rule result twice is ok; dup entire tree as we can't be adding trees as root; e.g., expr expr. Hideous code duplication here with super.next().  Can't think of a proper way to refactor.  This needs to always call dup node and super.next() doesn't know which to call: dup node or dup tree.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "25", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.TreeWizard", "methodParameterType": "TreeAdaptor#", "methodParameterName": "adaptor#", "methodBody": "public TreeWizard(TreeAdaptor adaptor) {\n\t\tthis.adaptor = adaptor;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "During fillBuffer(), we can make a reverse index from a set of token types of interest to the list of indexes into the node stream.  This lets us convert a node pointer to a stream index semi-efficiently for a list of interesting nodes such as function definition nodes (you'll want to seek to their bodies for an interpreter).  Also useful for doing dynamic searches; i.e., go find me all PLUS nodes. protected Map tokenTypeToStreamIndexesMap; /", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "26", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.computeTokenTypes", "methodParameterType": "String[]#", "methodParameterName": "tokenNames#", "methodBody": "public Map<String, Integer> computeTokenTypes(String[] tokenNames) {\n\t\tMap<String, Integer> m = new HashMap<String, Integer>();\n\t\tif ( tokenNames==null ) {\n\t\t\treturn m;\n\t\t}\n\t\tfor (int ttype = Token.MIN_TOKEN_TYPE; ttype < tokenNames.length; ttype++) {\n\t\t\tString name = tokenNames[ttype];\n\t\t\tm.put(name, ttype);\n\t\t}\n\t\treturn m;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute a Map&lt;String, Integer&gt; that is an inverted index of tokenNames (which maps int token types to names).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "27", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.getTokenType", "methodParameterType": "String#", "methodParameterName": "tokenName#", "methodBody": "public int getTokenType(String tokenName) {\n\t \tif ( tokenNameToTypeMap==null ) {\n\t\t\t return Token.INVALID_TOKEN_TYPE;\n\t\t }\n\t\tInteger ttypeI = tokenNameToTypeMap.get(tokenName);\n\t\tif ( ttypeI!=null ) {\n\t\t\treturn ttypeI;\n\t\t}\n\t\treturn Token.INVALID_TOKEN_TYPE;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Using the map of token names to token types, return the type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "28", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.index", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public Map<Integer, List<Object>> index(Object t) {\n\t\tMap<Integer, List<Object>> m = new HashMap<Integer, List<Object>>();\n\t\t_index(t, m);\n\t\treturn m;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Walk the entire tree and make a node name to nodes mapping. For now, use recursion but later nonrecursive version may be more efficient.  Returns Map&lt;Integer, List&gt; where the List is of your AST node type.  The Integer is the token type of the node. TODO: save this index so that find and visit are faster", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "29", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard._index", "methodParameterType": "Object#Map<Integer,List<Object>>#", "methodParameterName": "t#m#", "methodBody": "protected void _index(Object t, Map<Integer, List<Object>> m) {\n\t\tif ( t==null ) {\n\t\t\treturn;\n\t\t}\n\t\tint ttype = adaptor.getType(t);\n\t\tList<Object> elements = m.get(ttype);\n\t\tif ( elements==null ) {\n\t\t\telements = new ArrayList<Object>();\n\t\t\tm.put(ttype, elements);\n\t\t}\n\t\telements.add(t);\n\t\tint n = adaptor.getChildCount(t);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tObject child = adaptor.getChild(t, i);\n\t\t\t_index(child, m);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Do the work for index", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "30", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.find", "methodParameterType": "Object#int#", "methodParameterName": "t#ttype#", "methodBody": "public List<? extends Object> find(Object t, int ttype) {\n\t\tfinal List<Object> nodes = new ArrayList<Object>();\n\t\tvisit(t, ttype, new TreeWizard.Visitor() {\n\t\t\t@Override\n\t\t\tpublic void visit(Object t) {\n\t\t\t\tnodes.add(t);\n\t\t\t}\n\t\t});\n\t\treturn nodes;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#AnonymousClassDeclaration#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(AnonymousClassDeclaration(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration)AnonymousClassDeclaration)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a List of tree nodes with token type ttype", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "31", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.find", "methodParameterType": "Object#String#", "methodParameterName": "t#pattern#", "methodBody": "public List<? extends Object> find(Object t, String pattern) {\n\t\tfinal List<Object> subtrees = new ArrayList<Object>();\n\t\t// Create a TreePattern from the pattern\n\t\tTreePatternLexer tokenizer = new TreePatternLexer(pattern);\n\t\tTreePatternParser parser =\n\t\t\tnew TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());\n\t\tfinal TreePattern tpattern = (TreePattern)parser.pattern();\n\t\t// don't allow invalid patterns\n\t\tif ( tpattern==null ||\n\t\t\t tpattern.isNil() ||\n\t\t\t tpattern.getClass()==WildcardTreePattern.class )\n\t\t{\n\t\t\treturn null;\n\t\t}\n\t\tint rootTokenType = tpattern.getType();\n\t\tvisit(t, rootTokenType, new TreeWizard.ContextVisitor() {\n\t\t\t@Override\n\t\t\tpublic void visit(Object t, Object parent, int childIndex, Map labels) {\n\t\t\t\tif ( _parse(t, tpattern, null) ) {\n\t\t\t\t\tsubtrees.add(t);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn subtrees;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ThisExpression#SimpleName#SimpleType#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#TypeLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#AnonymousClassDeclaration#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(ThisExpression)ThisExpression(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(AnonymousClassDeclaration(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration)AnonymousClassDeclaration)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a List of subtrees matching pattern.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "32", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.visit", "methodParameterType": "Object#int#ContextVisitor#", "methodParameterName": "t#ttype#visitor#", "methodBody": "public void visit(Object t, int ttype, ContextVisitor visitor) {\n\t\t_visit(t, null, 0, ttype, visitor);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#NullLiteral#NumberLiteral#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral(NumberLiteral)NumberLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Visit every ttype node in t, invoking the visitor.  This is a quicker version of the general visit(t, pattern) method.  The labels arg of the visitor action method is never set (it's null) since using a token type rather than a pattern doesn't let us set a label.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "33", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard._visit", "methodParameterType": "Object#Object#int#int#ContextVisitor#", "methodParameterName": "t#parent#childIndex#ttype#visitor#", "methodBody": "protected void _visit(Object t, Object parent, int childIndex, int ttype, ContextVisitor visitor) {\n\t\tif ( t==null ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( adaptor.getType(t)==ttype ) {\n\t\t\tvisitor.visit(t, parent, childIndex, null);\n\t\t}\n\t\tint n = adaptor.getChildCount(t);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tObject child = adaptor.getChild(t, i);\n\t\t\t_visit(child, t, i, ttype, visitor);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Do the recursive work for visit", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "34", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.visit", "methodParameterType": "Object#String#ContextVisitor#", "methodParameterName": "t#pattern#visitor#", "methodBody": "public void visit(Object t, final String pattern, final ContextVisitor visitor) {\n\t\t// Create a TreePattern from the pattern\n\t\tTreePatternLexer tokenizer = new TreePatternLexer(pattern);\n\t\tTreePatternParser parser =\n\t\t\tnew TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());\n\t\tfinal TreePattern tpattern = (TreePattern)parser.pattern();\n\t\t// don't allow invalid patterns\n\t\tif ( tpattern==null ||\n\t\t\t tpattern.isNil() ||\n\t\t\t tpattern.getClass()==WildcardTreePattern.class )\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\tfinal Map<String, Object> labels = new HashMap<String, Object>(); // reused for each _parse\n\t\tint rootTokenType = tpattern.getType();\n\t\tvisit(t, rootTokenType, new TreeWizard.ContextVisitor() {\n\t\t\t@Override\n\t\t\tpublic void visit(Object t, Object parent, int childIndex, Map<String, Object> unusedlabels) {\n\t\t\t\t// the unusedlabels arg is null as visit on token type doesn't set.\n\t\t\t\tlabels.clear();\n\t\t\t\tif ( _parse(t, tpattern, labels) ) {\n\t\t\t\t\tvisitor.visit(t, parent, childIndex, labels);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Modifier#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Modifier#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ThisExpression#SimpleName#SimpleType#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#TypeLiteral#InfixExpression#InfixExpression#ReturnStatement#Block#IfStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#AnonymousClassDeclaration#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(ThisExpression)ThisExpression(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral)InfixExpression)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(AnonymousClassDeclaration(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration)AnonymousClassDeclaration)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "For all subtrees that match the pattern, execute the visit action. The implementation uses the root node of the pattern in combination with visit(t, ttype, visitor) so nil-rooted patterns are not allowed. Patterns with wildcard roots are also not allowed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "35", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.parse", "methodParameterType": "Object#String#Map<String,Object>#", "methodParameterName": "t#pattern#labels#", "methodBody": "public boolean parse(Object t, String pattern, Map<String, Object> labels) {\n\t\tTreePatternLexer tokenizer = new TreePatternLexer(pattern);\n\t\tTreePatternParser parser =\n\t\t\tnew TreePatternParser(tokenizer, this, new TreePatternTreeAdaptor());\n\t\tTreePattern tpattern = (TreePattern)parser.pattern();\n\t\t/*\n\t\tSystem.out.println(\"t=\"+((Tree)t).toStringTree());\n\t\tSystem.out.println(\"scant=\"+tpattern.toStringTree());\n\t\t*/\n\t\tboolean matched = _parse(t, tpattern, labels);\n\t\treturn matched;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ThisExpression#SimpleName#SimpleType#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(ThisExpression)ThisExpression(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a pattern like (ASSIGN %lhs:ID %rhs:.) with optional labels on the various nodes and '.' (dot) as the node/subtree wildcard, return true if the pattern matches and fill the labels Map with the labels pointing at the appropriate nodes.  Return false if the pattern is malformed or the tree does not match. If a node specifies a text arg in pattern, then that must match for that node in t. TODO: what's a better way to indicate bad pattern? Exceptions are a hassle", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "36", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard._parse", "methodParameterType": "Object#TreePattern#Map<String,Object>#", "methodParameterName": "t1#tpattern#labels#", "methodBody": "protected boolean _parse(Object t1, TreePattern tpattern, Map<String, Object> labels) {\n\t\t// make sure both are non-null\n\t\tif ( t1==null || tpattern==null ) {\n\t\t\treturn false;\n\t\t}\n\t\t// check roots (wildcard matches anything)\n\t\tif ( tpattern.getClass() != WildcardTreePattern.class ) {\n\t\t\tif ( adaptor.getType(t1) != tpattern.getType() ) return false;\n            // if pattern has text, check node text\n\t\t\tif ( tpattern.hasTextArg && !adaptor.getText(t1).equals(tpattern.getText()) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tif ( tpattern.label!=null && labels!=null ) {\n\t\t\t// map label in pattern to node in t1\n\t\t\tlabels.put(tpattern.label, t1);\n\t\t}\n\t\t// check children\n\t\tint n1 = adaptor.getChildCount(t1);\n\t\tint n2 = tpattern.getChildCount();\n\t\tif ( n1 != n2 ) {\n\t\t\treturn false;\n\t\t}\n\t\tfor (int i=0; i<n1; i++) {\n\t\t\tObject child1 = adaptor.getChild(t1, i);\n\t\t\tTreePattern child2 = (TreePattern)tpattern.getChild(i);\n\t\t\tif ( !_parse(child1, child2, labels) ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#TypeLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#PrefixExpression#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#ForStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(PrefixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)PrefixExpression)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Do the work for parse. Check to see if the t2 pattern fits the structure and token types in t1.  Check text if the pattern has text arguments on nodes.  Fill labels map with pointers to nodes in tree matched against nodes in pattern with labels.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "37", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.create", "methodParameterType": "String#", "methodParameterName": "pattern#", "methodBody": "public Object create(String pattern) {\n\t\tTreePatternLexer tokenizer = new TreePatternLexer(pattern);\n\t\tTreePatternParser parser = new TreePatternParser(tokenizer, this, adaptor);\n\t\tObject t = parser.pattern();\n\t\treturn t;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ThisExpression#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a tree or node from the indicated tree pattern that closely follows ANTLR tree grammar tree element syntax: (root child1 ... child2). You can also just pass in a node: ID Any node can have a text argument: ID[foo] (notice there are no quotes around foo--it's clear it's a string). nil is a special name meaning \"give me a nil node\".  Useful for making lists: (nil A B C) is a list of A B C.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "38", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.equals", "methodParameterType": "Object#Object#TreeAdaptor#", "methodParameterName": "t1#t2#adaptor#", "methodBody": "public static boolean equals(Object t1, Object t2, TreeAdaptor adaptor) {\n\t\treturn _equals(t1, t2, adaptor);\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compare t1 and t2; return true if token types/text, structure match exactly. The trees are examined in their entirety so that (A B) does not match (A B C) nor (A (B C)).  // TODO: allow them to pass in a comparator TODO: have a version that is nonstatic so it can use instance adaptor I cannot rely on the tree node's equals() implementation as I make no constraints at all on the node types nor interface etc...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "39", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeWizard.java", "methodName": "org.antlr.runtime.tree.TreeWizard.equals", "methodParameterType": "Object#Object#", "methodParameterName": "t1#t2#", "methodBody": "public boolean equals(Object t1, Object t2) {\n\t\treturn _equals(t1, t2, adaptor);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compare type, structure, and text of two trees, assuming adaptor in this instance of a TreeWizard.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "40", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.CommonTreeNodeStream.nextElement", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public Object nextElement() {\n        Object t = it.next();\n        //System.out.println(\"pulled \"+adaptor.getType(t));\n        if ( t == it.up ) {\n            level--;\n            if ( level==0 && hasNilRoot ) return it.next(); // don't give last UP; get EOF\n        }\n        else if ( t == it.down ) level++;\n        if ( level==0 && adaptor.isNil(t) ) { // if nil root, scarf nil, DOWN\n            hasNilRoot = true;\n            t = it.next(); // t is now DOWN, so get first real node next\n            level++;\n            t = it.next();\n        }\n        return t;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ReturnStatement#IfStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#IfStatement#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName)InfixExpression(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)IfStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)IfStatement)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Pull elements from tree iterator.  Track tree level 0..max_level. If nil rooted tree, don't give initial nil and DOWN nor final UP.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "41", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.CommonTreeNodeStream.push", "methodParameterType": "int#", "methodParameterName": "index#", "methodBody": "public void push(int index) {\n        if ( calls==null ) {\n            calls = new IntArray();\n        }\n        calls.push(p); // save current index\n        seek(index);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make stream jump to a new location, saving old location. Switch back with pop().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "42", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.CommonTreeNodeStream.pop", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int pop() {\n        int ret = calls.pop();\n        seek(ret);\n        return ret;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Seek back to previous index saved during last  {@link #push} call.Return top of stack (return index).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "43", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.CommonTreeNodeStream.getKnownPositionElement", "methodParameterType": "boolean#", "methodParameterName": "allowApproximateLocation#", "methodBody": "@Override\n\tpublic Object getKnownPositionElement(boolean allowApproximateLocation) {\n\t\tObject node = data.get(p);\n\t\tif (hasPositionInformation(node)) {\n\t\t\treturn node;\n\t\t}\n\n\t\tif (!allowApproximateLocation) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfor (int index = p - 1; index >= 0; index--) {\n\t\t\tnode = data.get(index);\n\t\t\tif (hasPositionInformation(node)) {\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\n\t\treturn previousLocationElement;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#PrefixExpression#NullLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Returns an element containing position information. If  {@code allowApproximateLocation} is {@code false}, then this method will return the  {@code LT(1)} element if it contains position information, and otherwise return {@code null}. If  {@code allowApproximateLocation} is {@code true}, then this method will return the last known element containing position information.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "44", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.CommonTreeNodeStream.toTokenTypeString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toTokenTypeString() {\n        reset();\n\t\tStringBuilder buf = new StringBuilder();\n        Object o = LT(1);\n        int type = adaptor.getType(o);\n        while ( type!=Token.EOF ) {\n            buf.append(\" \");\n            buf.append(type);\n            consume();\n            o = LT(1);\n            type = adaptor.getType(o);\n\t\t}\n\t\treturn buf.toString();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For debugging; destructive: moves tree iterator to end.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "45", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.fillBuffer", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected void fillBuffer() {\n\t\tfillBuffer(root);\n\t\t//System.out.println(\"revIndex=\"+tokenTypeToStreamIndexesMap);\n\t\tp = 0; // buffer of nodes intialized now\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Walk tree with depth-first-search and fill nodes buffer. Don't do DOWN, UP nodes if its a list (t is isNil).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "46", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.getNodeIndex", "methodParameterType": "Object#", "methodParameterName": "node#", "methodBody": "protected int getNodeIndex(Object node) {\n\t\tif ( p==-1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\tObject t = nodes.get(i);\n\t\t\tif ( t==node ) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#Block#ForStatement#NumberLiteral#PrefixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the stream index for node? 0..n-1 Return -1 if node not found.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "47", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.addNavigationNode", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "protected void addNavigationNode(final int ttype) {\n\t\tObject navNode;\n\t\tif ( ttype==Token.DOWN ) {\n\t\t\tif ( hasUniqueNavigationNodes() ) {\n\t\t\t\tnavNode = adaptor.create(Token.DOWN, \"DOWN\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnavNode = down;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif ( hasUniqueNavigationNodes() ) {\n\t\t\t\tnavNode = adaptor.create(Token.UP, \"UP\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnavNode = up;\n\t\t\t}\n\t\t}\n\t\tnodes.add(navNode);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#Modifier#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "As we flatten the tree, we use UP, DOWN nodes to represent the tree structure.  When debugging we need unique nodes so instantiate new ones when uniqueNavigationNodes is true.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "48", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.LB", "methodParameterType": "int#", "methodParameterName": "k#", "methodBody": "protected Object LB(int k) {\n\t\tif ( k==0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( (p-k)<0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn nodes.get(p-k);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#InfixExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Look backwards k nodes", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "49", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.push", "methodParameterType": "int#", "methodParameterName": "index#", "methodBody": "public void push(int index) {\n\t\tif ( calls==null ) {\n\t\t\tcalls = new IntArray();\n\t\t}\n\t\tcalls.push(p); // save current index\n\t\tseek(index);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make stream jump to a new location, saving old location. Switch back with pop().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "50", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.pop", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int pop() {\n\t\tint ret = calls.pop();\n\t\tseek(ret);\n\t\treturn ret;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Seek back to previous index saved during last push() call. Return top of stack (return index).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "51", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.toTokenTypeString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toTokenTypeString() {\n\t\tif ( p==-1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (int i = 0; i < nodes.size(); i++) {\n\t\t\tObject t = nodes.get(i);\n\t\t\tbuf.append(\" \");\n\t\t\tbuf.append(adaptor.getType(t));\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Used for testing, just return the token type stream", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "52", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BufferedTreeNodeStream.java", "methodName": "org.antlr.runtime.tree.BufferedTreeNodeStream.toTokenString", "methodParameterType": "int#int#", "methodParameterName": "start#stop#", "methodBody": "public String toTokenString(int start, int stop) {\n\t\tif ( p==-1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (int i = start; i < nodes.size() && i <= stop; i++) {\n\t\t\tObject t = nodes.get(i);\n\t\t\tbuf.append(\" \");\n\t\t\tbuf.append(adaptor.getToken(t));\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Debugging", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "53", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeRewriter.java", "methodName": "org.antlr.runtime.tree.TreeRewriter.reportTransformation", "methodParameterType": "Object#Object#", "methodParameterName": "oldTree#newTree#", "methodBody": "public void reportTransformation(Object oldTree, Object newTree) {\n        System.out.println(((Tree)oldTree).toStringTree()+\" -> \"+\n                           ((Tree)newTree).toStringTree());\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#StringLiteral#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Override this if you need transformation tracing to go somewhere other than stdout or if you're not using Tree-derived trees.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "54", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeVisitorAction.java", "methodName": "org.antlr.runtime.tree.TreeVisitorAction.pre", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public Object pre(Object t);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Execute an action before visiting children of t.  Return t or a rewritten t.  It is up to the visitor to decide what to do with the return value.  Children of returned value will be visited if using TreeVisitor.visit().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "55", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeVisitorAction.java", "methodName": "org.antlr.runtime.tree.TreeVisitorAction.post", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public Object post(Object t);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Execute an action after visiting children of t.  Return t or a rewritten t.  It is up to the visitor to decide what to do with the return value.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "56", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.BaseTree", "methodParameterType": "Tree#", "methodParameterName": "node#", "methodBody": "public BaseTree(Tree node) {\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block)Block)MethodDeclaration", "methodDoc": "Create a new node from an existing node does nothing for BaseTree as there are no fields other than the children list, which cannot be copied as the children are not considered part of this node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "57", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.getChildren", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<? extends Object> getChildren() {\n\t\treturn children;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the children internal List; note that if you directly mess with the list, do so at your own risk.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "58", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.addChild", "methodParameterType": "Tree#", "methodParameterName": "t#", "methodBody": "@Override\n\tpublic void addChild(Tree t) {\n\t\t//System.out.println(\"add child \"+t.toStringTree()+\" \"+this.toStringTree());\n\t\t//System.out.println(\"existing children: \"+children);\n\t\tif ( t==null ) {\n\t\t\treturn; // do nothing upon addChild(null)\n\t\t}\n\t\tBaseTree childTree = (BaseTree)t;\n\t\tif ( childTree.isNil() ) { // t is an empty node possibly with children\n\t\t\tif ( this.children!=null && this.children == childTree.children ) {\n\t\t\t\tthrow new RuntimeException(\"attempt to add child list to itself\");\n\t\t\t}\n\t\t\t// just add all of childTree's children to this\n\t\t\tif ( childTree.children!=null ) {\n\t\t\t\tif ( this.children!=null ) { // must copy, this has children already\n\t\t\t\t\tint n = childTree.children.size();\n\t\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\t\tTree c = (Tree)childTree.children.get(i);\n\t\t\t\t\t\tthis.children.add(c);\n\t\t\t\t\t\t// handle double-link stuff for each child of nil root\n\t\t\t\t\t\tc.setParent(this);\n\t\t\t\t\t\tc.setChildIndex(children.size()-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// no children for this but t has children; just set pointer\n\t\t\t\t\t// call general freshener routine\n\t\t\t\t\tthis.children = childTree.children;\n\t\t\t\t\tthis.freshenParentAndChildIndexes();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse { // child is not nil (don't care about children)\n\t\t\tif ( children==null ) {\n\t\t\t\tchildren = createChildrenList(); // create children list on demand\n\t\t\t}\n\t\t\tchildren.add(t);\n\t\t\tchildTree.setParent(this);\n\t\t\tchildTree.setChildIndex(children.size()-1);\n\t\t}\n\t\t// System.out.println(\"now children are: \"+children);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ThisExpression#SimpleName#FieldAccess#NullLiteral#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#ThisExpression#SimpleName#FieldAccess#NullLiteral#InfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#ThisExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)ForStatement)Block(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Add t as child of this node. Warning: if t has no children, but child does and child isNil then this routine moves children to t via t.children = child.children; i.e., without copying the array.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "59", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.addChildren", "methodParameterType": "List<? extends Tree>#", "methodParameterName": "kids#", "methodBody": "public void addChildren(List<? extends Tree> kids) {\n\t\tfor (int i = 0; i < kids.size(); i++) {\n\t\t\tTree t = kids.get(i);\n\t\t\taddChild(t);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Add all elements of kids list as children of this node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "60", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.insertChild", "methodParameterType": "int#Object#", "methodParameterName": "i#t#", "methodBody": "public void insertChild(int i, Object t) {\n\t\tif (i < 0 || i > getChildCount()) {\n\t\t\tthrow new IndexOutOfBoundsException(i+\" out or range\");\n\t\t}\n\n\t\tif (children == null) {\n\t\t\tchildren = createChildrenList();\n\t\t}\n\n\t\tchildren.add(i, t);\n\t\t// walk others to increment their child indexes\n\t\t// set index, parent of this one too\n\t\tthis.freshenParentAndChildIndexes(i);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Insert child t at child position i (0..n-1) by shifting children i+1..n-1 to the right one position. Set parent / indexes properly but does NOT collapse nil-rooted t's that come in here like addChild.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "61", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.replaceChildren", "methodParameterType": "int#int#Object#", "methodParameterName": "startChildIndex#stopChildIndex#t#", "methodBody": "@Override\n\tpublic void replaceChildren(int startChildIndex, int stopChildIndex, Object t) {\n\t\t/*\n\t\tSystem.out.println(\"replaceChildren \"+startChildIndex+\", \"+stopChildIndex+\n\t\t\t\t\t\t   \" with \"+((BaseTree)t).toStringTree());\n\t\tSystem.out.println(\"in=\"+toStringTree());\n\t\t*/\n\t\tif ( children==null ) {\n\t\t\tthrow new IllegalArgumentException(\"indexes invalid; no children in list\");\n\t\t}\n\t\tint replacingHowMany = stopChildIndex - startChildIndex + 1;\n\t\tint replacingWithHowMany;\n\t\tBaseTree newTree = (BaseTree)t;\n\t\tList<Object> newChildren;\n\t\t// normalize to a list of children to add: newChildren\n\t\tif ( newTree.isNil() ) {\n\t\t\tnewChildren = newTree.children;\n\t\t}\n\t\telse {\n\t\t\tnewChildren = new ArrayList<Object>(1);\n\t\t\tnewChildren.add(newTree);\n\t\t}\n\t\treplacingWithHowMany = newChildren.size();\n\t\tint numNewChildren = newChildren.size();\n\t\tint delta = replacingHowMany - replacingWithHowMany;\n\t\t// if same number of nodes, do direct replace\n\t\tif ( delta == 0 ) {\n\t\t\tint j = 0; // index into new children\n\t\t\tfor (int i=startChildIndex; i<=stopChildIndex; i++) {\n\t\t\t\tBaseTree child = (BaseTree)newChildren.get(j);\n\t\t\t\tchildren.set(i, child);\n\t\t\t\tchild.setParent(this);\n\t\t\t\tchild.setChildIndex(i);\n                j++;\n            }\n\t\t}\n\t\telse if ( delta > 0 ) { // fewer new nodes than there were\n\t\t\t// set children and then delete extra\n\t\t\tfor (int j=0; j<numNewChildren; j++) {\n\t\t\t\tchildren.set(startChildIndex+j, newChildren.get(j));\n\t\t\t}\n\t\t\tint indexToDelete = startChildIndex+numNewChildren;\n\t\t\tfor (int c=indexToDelete; c<=stopChildIndex; c++) {\n\t\t\t\t// delete same index, shifting everybody down each time\n\t\t\t\tchildren.remove(indexToDelete);\n\t\t\t}\n\t\t\tfreshenParentAndChildIndexes(startChildIndex);\n\t\t}\n\t\telse { // more new nodes than were there before\n\t\t\t// fill in as many children as we can (replacingHowMany) w/o moving data\n\t\t\tfor (int j=0; j<replacingHowMany; j++) {\n\t\t\t\tchildren.set(startChildIndex+j, newChildren.get(j));\n\t\t\t}\n\t\t\tint numToInsert = replacingWithHowMany-replacingHowMany;\n\t\t\tfor (int j=replacingHowMany; j<replacingWithHowMany; j++) {\n\t\t\t\tchildren.add(startChildIndex+j, newChildren.get(j));\n\t\t\t}\n\t\t\tfreshenParentAndChildIndexes(startChildIndex);\n\t\t}\n\t\t//System.out.println(\"out=\"+toStringTree());\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#NumberLiteral#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#ForStatement#Block#SimpleName#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(NumberLiteral)NumberLiteral)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)ForStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Delete children from start to stop and replace with t even if t is a list (nil-root tree).  num of children can increase or decrease. For huge child lists, inserting children can force walking rest of children to set their childindex; could be slow.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "62", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.createChildrenList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected List<Object> createChildrenList() {\n\t\treturn new ArrayList<Object>();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Override in a subclass to change the impl of children list", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "63", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.freshenParentAndChildIndexes", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic void freshenParentAndChildIndexes() {\n\t\tfreshenParentAndChildIndexes(0);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the parent and child index values for all child of t", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "64", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.getChildIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic int getChildIndex() {\n\t\treturn 0;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#NumberLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "BaseTree doesn't track child indexes.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "65", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.getParent", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic Tree getParent() {\n\t\treturn null;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "BaseTree doesn't track parent pointers.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "66", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.hasAncestor", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "@Override\n    public boolean hasAncestor(int ttype) { return getAncestor(ttype)!=null; }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Walk upwards looking for ancestor with this token type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "67", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.getAncestor", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "@Override\n    public Tree getAncestor(int ttype) {\n        Tree t = this;\n        t = t.getParent();\n        while ( t!=null ) {\n            if ( t.getType()==ttype ) return t;\n            t = t.getParent();\n        }\n        return null;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#ReturnStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(ReturnStatement(SimpleName)SimpleName)ReturnStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Walk upwards and get first ancestor with this token type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "68", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.getAncestors", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public List<? extends Tree> getAncestors() {\n        if ( getParent()==null ) return null;\n        List<Tree> ancestors = new ArrayList<Tree>();\n        Tree t = this;\n        t = t.getParent();\n        while ( t!=null ) {\n            ancestors.add(0, t); // insert at start\n            t = t.getParent();\n        }\n        return ancestors;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of all ancestors of this node.  The first node of list is the root and the last is the parent of this node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "69", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.toStringTree", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public String toStringTree() {\n\t\tif ( children==null || children.isEmpty() ) {\n\t\t\treturn this.toString();\n\t\t}\n\t\tStringBuilder buf = new StringBuilder();\n\t\tif ( !isNil() ) {\n\t\t\tbuf.append(\"(\");\n\t\t\tbuf.append(this.toString());\n\t\t\tbuf.append(' ');\n\t\t}\n\t\tfor (int i = 0; children!=null && i < children.size(); i++) {\n\t\t\tTree t = (Tree)children.get(i);\n\t\t\tif ( i>0 ) {\n\t\t\t\tbuf.append(' ');\n\t\t\t}\n\t\t\tbuf.append(t.toStringTree());\n\t\t}\n\t\tif ( !isNil() ) {\n\t\t\tbuf.append(\")\");\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#ThisExpression#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#ThisExpression#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ReturnStatement(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Print out a whole tree not just a node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "70", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTree.java", "methodName": "org.antlr.runtime.tree.BaseTree.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic abstract String toString();", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Override to say how a node (not a tree) should look as text", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "71", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeVisitor.java", "methodName": "org.antlr.runtime.tree.TreeVisitor.visit", "methodParameterType": "Object#TreeVisitorAction#", "methodParameterName": "t#action#", "methodBody": "public Object visit(Object t, TreeVisitorAction action) {\n        // System.out.println(\"visit \"+((Tree)t).toStringTree());\n        boolean isNil = adaptor.isNil(t);\n        if ( action!=null && !isNil ) {\n            t = action.pre(t); // if rewritten, walk children of new t\n        }\n        for (int i=0; i<adaptor.getChildCount(t); i++) {\n            Object child = adaptor.getChild(t, i);\n            Object visitResult = visit(child, action);\n            Object childAfterVisit = adaptor.getChild(t, i);\n            if ( visitResult !=  childAfterVisit ) { // result & child differ?\n                adaptor.setChild(t, i, visitResult);\n            }\n        }\n        if ( action!=null && !isNil ) t = action.post(t);\n        return t;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Visit every node in tree t and trigger an action for each node before/after having visited all of its children. Execute both actions even if t has no children. If a child visit yields a new child, it can update its parent's child list or just return the new child.  The child update code works even if the child visit alters its parent and returns the new tree. Return result of applying post action to this node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "72", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.get", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "public Object get(int i);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get a tree node at an absolute index  {@code i}; 0..n-1. If you don't want to buffer up nodes, then this method makes no sense for you.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "73", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.LT", "methodParameterType": "int#", "methodParameterName": "k#", "methodBody": "public Object LT(int k);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get tree node at current input pointer +  {@code k} ahead where{@code k==1} is next node. {@code k<0} indicates nodes in the past. So{@code LT(-1)} is previous node, but implementations are not required toprovide results for  {@code k < -1}.  {@code LT(0)} is undefined. For{@code k<=n}, return  {@code null}. Return  {@code null} for {@code LT(0)}and any index that results in an absolute address that is negative. <p> This is analogous to  {@link TokenStream#LT}, but this returns a tree node instead of a  {@link Token}. Makes code generation identical for both parser and tree grammars.</p>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "74", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.getTreeSource", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object getTreeSource();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Where is this stream pulling nodes from?  This is not the name, but the object that provides node objects.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "75", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.getTokenStream", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public TokenStream getTokenStream();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "If the tree associated with this stream was created from a {@link TokenStream}, you can specify it here. Used to do rule {@code $text} attribute in tree parser. Optional unless you use treeparser rule  {@code $text} attribute or {@code output=template} and{@code rewrite=true} options.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "76", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.getTreeAdaptor", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public TreeAdaptor getTreeAdaptor();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "What adaptor can tell me how to interpret/navigate nodes and trees.  E.g., get text of a node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "77", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.setUniqueNavigationNodes", "methodParameterType": "boolean#", "methodParameterName": "uniqueNavigationNodes#", "methodBody": "public void setUniqueNavigationNodes(boolean uniqueNavigationNodes);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "As we flatten the tree, we use  {@link Token#UP},  {@link Token#DOWN} nodesto represent the tree structure. When debugging we need unique nodes so we have to instantiate new ones. When doing normal tree parsing, it's slow and a waste of memory to create unique navigation nodes. Default should be  {@code false}.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "78", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.reset", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void reset();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Reset the tree node stream in such a way that it acts like a freshly constructed stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "79", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.toString", "methodParameterType": "Object#Object#", "methodParameterName": "start#stop#", "methodBody": "public String toString(Object start, Object stop);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Return the text of all nodes from  {@code start} to {@code stop}, inclusive. If the stream does not buffer all the nodes then it can still walk recursively from start until stop. You can always return {@code null} or {@code \"\"} too, but users should not access{@code $ruleLabel.text} in an action of course in that case.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "80", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeNodeStream.java", "methodName": "org.antlr.runtime.tree.TreeNodeStream.replaceChildren", "methodParameterType": "Object#int#int#Object#", "methodParameterName": "parent#startChildIndex#stopChildIndex#t#", "methodBody": "public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Replace children of  {@code parent} from index {@code startChildIndex} to{@code stopChildIndex} with {@code t}, which might be a list. Number of children may be different after this call. The stream is notified because it is walking the tree and might need to know you are monkeying with the underlying tree. Also, it might be able to modify the node stream to avoid restreaming for future phases. <p> If  {@code parent} is {@code null}, don't do anything; must be at root of overall tree. Can't replace whatever points to the parent externally. Do nothing.</p>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "81", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/PositionTrackingStream.java", "methodName": "org.antlr.runtime.tree.PositionTrackingStream.getKnownPositionElement", "methodParameterType": "boolean#", "methodParameterName": "allowApproximateLocation#", "methodBody": "T getKnownPositionElement(boolean allowApproximateLocation);", "AST": "Javadoc#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Returns an element containing concrete information about the current position in the stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "82", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/PositionTrackingStream.java", "methodName": "org.antlr.runtime.tree.PositionTrackingStream.hasPositionInformation", "methodParameterType": "T#", "methodParameterName": "element#", "methodBody": "boolean hasPositionInformation(T element);", "AST": "Javadoc#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Determines if the specified  {@code element} contains concrete positioninformation.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "83", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/DOTTreeGenerator.java", "methodName": "org.antlr.runtime.tree.DOTTreeGenerator.toDOT", "methodParameterType": "Tree#", "methodParameterName": "tree#", "methodBody": "public StringTemplate toDOT(Tree tree) {\n\t\treturn toDOT(tree, new CommonTreeAdaptor());\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Generate DOT (graphviz) for a whole tree not just a node. For example, 3+4", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "84", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.setTreeNodeStream", "methodParameterType": "TreeNodeStream#", "methodParameterName": "input#", "methodBody": "public void setTreeNodeStream(TreeNodeStream input) {\n\t\tthis.input = input;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the input stream", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "85", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.matchAny", "methodParameterType": "IntStream#", "methodParameterName": "ignore#", "methodBody": "@Override\n\tpublic void matchAny(IntStream ignore) { // ignore stream, copy of input\n\t\tstate.errorRecovery = false;\n\t\tstate.failed = false;\n\t\tObject look = input.LT(1);\n\t\tif ( input.getTreeAdaptor().getChildCount(look)==0 ) {\n\t\t\tinput.consume(); // not subtree, consume 1 node and return\n\t\t\treturn;\n\t\t}\n\t\t// current node is a subtree, skip to corresponding UP.\n\t\t// must count nesting level to get right UP\n\t\tint level=0;\n\t\tint tokenType = input.getTreeAdaptor().getType(look);\n\t\twhile ( tokenType!=Token.EOF && !(tokenType==UP && level==0) ) {\n\t\t\tinput.consume();\n\t\t\tlook = input.LT(1);\n\t\t\ttokenType = input.getTreeAdaptor().getType(look);\n\t\t\tif ( tokenType == DOWN ) {\n\t\t\t\tlevel++;\n\t\t\t}\n\t\t\telse if ( tokenType == UP ) {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t}\n\t\tinput.consume(); // consume UP\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#PrefixExpression#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#IfStatement#Block#WhileStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PrefixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)IfStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Match '.' in tree parser has special meaning.  Skip node or entire tree if node has children.  If children, scan until corresponding UP node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "86", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.recoverFromMismatchedToken", "methodParameterType": "IntStream#int#BitSet#", "methodParameterName": "input#ttype#follow#", "methodBody": "@Override\n    protected Object recoverFromMismatchedToken(IntStream input,\n                                                int ttype,\n                                                BitSet follow)\n        throws RecognitionException\n    {\n        throw new MismatchedTreeNodeException(ttype, (TreeNodeStream)input);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ClassInstanceCreation#ThrowStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ClassInstanceCreation)ThrowStatement)Block)MethodDeclaration", "methodDoc": "We have DOWN/UP nodes in the stream that have no line info; override. plus we want to alter the exception type.  Don't try to recover from tree parser errors inline...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "87", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.getErrorHeader", "methodParameterType": "RecognitionException#", "methodParameterName": "e#", "methodBody": "@Override\n\tpublic String getErrorHeader(RecognitionException e) {\n\t\treturn getGrammarFileName()+\": node from \"+\n\t\t\t   (e.approximateLineInfo?\"after \":\"\")+\"line \"+e.line+\":\"+e.charPositionInLine;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#StringLiteral#ConditionalExpression#ParenthesizedExpression#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(ParenthesizedExpression(ConditionalExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)ConditionalExpression)ParenthesizedExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Prefix error message with the grammar name because message is always intended for the programmer because the parser built the input tree not the user.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "88", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.getErrorMessage", "methodParameterType": "RecognitionException#String[]#", "methodParameterName": "e#tokenNames#", "methodBody": "@Override\n\tpublic String getErrorMessage(RecognitionException e, String[] tokenNames) {\n\t\tif ( this instanceof TreeParser ) {\n\t\t\tTreeAdaptor adaptor = ((TreeNodeStream)e.input).getTreeAdaptor();\n\t\t\te.token = adaptor.getToken(e.node);\n\t\t\tif ( e.token==null ) { // could be an UP/DOWN node\n\t\t\t\te.token = new CommonToken(adaptor.getType(e.node),\n\t\t\t\t\t\t\t\t\t\t  adaptor.getText(e.node));\n\t\t\t}\n\t\t}\n\t\treturn super.getErrorMessage(e, tokenNames);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InstanceofExpression(ThisExpression)ThisExpression(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Tree parsers parse nodes they usually have a token object as payload. Set the exception token and do the default behavior.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "89", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.inContext", "methodParameterType": "String#", "methodParameterName": "context#", "methodBody": "public boolean inContext(String context) {\n\t\treturn inContext(input.getTreeAdaptor(), getTokenNames(), input.LT(1), context);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Check if current node in input has a context.  Context means sequence of nodes towards root of tree.  For example, you might say context is \"MULT\" which means my parent must be MULT.  \"CLASS VARDEF\" says current node must be child of a VARDEF and whose parent is a CLASS node. You can use \"...\" to mean zero-or-more nodes.  \"METHOD ... VARDEF\" means my parent is VARDEF and somewhere above that is a METHOD node. The first node in the context is not necessarily the root.  The context matcher stops matching and returns true when it runs out of context. There is no way to force the first node to be the root.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "90", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.inContext", "methodParameterType": "TreeAdaptor#String[]#Object#String#", "methodParameterName": "adaptor#tokenNames#t#context#", "methodBody": "public static boolean inContext(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t\tString[] tokenNames,\n\t\t\t\t\t\t\t\t\tObject t,\n\t\t\t\t\t\t\t\t\tString context)\n\t{\n\t\tMatcher dotdotMatcher = dotdotPattern.matcher(context);\n\t\tMatcher doubleEtcMatcher = doubleEtcPattern.matcher(context);\n\t\tif ( dotdotMatcher.find() ) { // don't allow \"..\", must be \"...\"\n\t\t\tthrow new IllegalArgumentException(\"invalid syntax: ..\");\n\t\t}\n\t\tif ( doubleEtcMatcher.find() ) { // don't allow double \"...\"\n\t\t\tthrow new IllegalArgumentException(\"invalid syntax: ... ...\");\n\t\t}\n\t\tcontext = context.replaceAll(\"\\\\.\\\\.\\\\.\", \" ... \"); // ensure spaces around ...\n\t\tcontext = context.trim();\n\t\tString[] nodes = context.split(\"\\\\s+\");\n\t\tint ni = nodes.length-1;\n\t\tt = adaptor.getParent(t);\n\t\twhile ( ni>=0 && t!=null ) {\n\t\t\tif ( nodes[ni].equals(\"...\") ) {\n\t\t\t\t// walk upwards until we see nodes[ni-1] then continue walking\n\t\t\t\tif ( ni==0 ) return true; // ... at start is no-op\n\t\t\t\tString goal = nodes[ni-1];\n\t\t\t\tObject ancestor = getAncestor(adaptor, tokenNames, t, goal);\n\t\t\t\tif ( ancestor==null ) return false;\n\t\t\t\tt = ancestor;\n\t\t\t\tni--;\n\t\t\t}\n\t\t\tString name = tokenNames[adaptor.getType(t)];\n\t\t\tif ( !name.equals(nodes[ni]) ) {\n\t\t\t\t//System.err.println(\"not matched: \"+nodes[ni]+\" at \"+t);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// advance to parent and to previous element in context node list\n\t\t\tni--;\n\t\t\tt = adaptor.getParent(t);\n\t\t}\n\n\t\tif ( t==null && ni>=0 ) return false; // at root but more nodes to match\n\t\treturn true;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#StringLiteral#MethodInvocation#SimpleName#NumberLiteral#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#MethodInvocation#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(IfStatement(MethodInvocation(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The worker for inContext.  It's static and full of parameters for testing purposes.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "91", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeParser.java", "methodName": "org.antlr.runtime.tree.TreeParser.getAncestor", "methodParameterType": "TreeAdaptor#String[]#Object#String#", "methodParameterName": "adaptor#tokenNames#t#goal#", "methodBody": "protected static Object getAncestor(TreeAdaptor adaptor, String[] tokenNames, Object t, String goal) {\n\t\twhile ( t!=null ) {\n\t\t\tString name = tokenNames[adaptor.getType(t)];\n\t\t\tif ( name.equals(goal) ) return t;\n\t\t\tt = adaptor.getParent(t);\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(ReturnStatement(SimpleName)SimpleName)ReturnStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Helper for static inContext", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "92", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/ParseTree.java", "methodName": "org.antlr.runtime.tree.ParseTree.toStringWithHiddenTokens", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toStringWithHiddenTokens() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tif ( hiddenTokens!=null ) {\n\t\t\tfor (int i = 0; i < hiddenTokens.size(); i++) {\n\t\t\t\tToken hidden = hiddenTokens.get(i);\n\t\t\t\tbuf.append(hidden.getText());\n\t\t\t}\n\t\t}\n\t\tString nodeText = this.toString();\n\t\tif ( !nodeText.equals(\"<EOF>\") ) buf.append(nodeText);\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#ThisExpression#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Emit a token and all hidden nodes before.  EOF node holds all hidden tokens after last real token.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "93", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/ParseTree.java", "methodName": "org.antlr.runtime.tree.ParseTree.toInputString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toInputString() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\t_toStringLeaves(buf);\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Print out the leaves of this tree, which means printing original input back out.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "94", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTree.java", "methodName": "org.antlr.runtime.tree.CommonTree.setUnknownTokenBoundaries", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void setUnknownTokenBoundaries() {\n        if ( children==null ) {\n            if ( startIndex<0 || stopIndex<0 ) {\n                startIndex = stopIndex = token.getTokenIndex();\n            }\n            return;\n        }\n        for (int i=0; i<children.size(); i++) {\n            ((CommonTree)children.get(i)).setUnknownTokenBoundaries();\n        }\n        if ( startIndex>=0 && stopIndex>=0 ) return; // already set\n        if ( children.size() > 0 ) {\n            CommonTree firstChild = (CommonTree)children.get(0);\n            CommonTree lastChild = (CommonTree)children.get(children.size()-1);\n            startIndex = firstChild.getTokenStartIndex();\n            stopIndex = lastChild.getTokenStopIndex();\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#Assignment#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ReturnStatement)ReturnStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "For every node in this subtree, make sure it's start/stop token's are set.  Walk depth first, visit bottom up.  Only updates nodes with at least one token index &lt; 0.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "95", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.errorNode", "methodParameterType": "TokenStream#Token#Token#RecognitionException#", "methodParameterName": "input#start#stop#e#", "methodBody": "@Override\n\tpublic Object errorNode(TokenStream input, Token start, Token stop,\n\t\t\t\t\t\t\tRecognitionException e)\n\t{\n\t\tCommonErrorNode t = new CommonErrorNode(input, start, stop, e);\n\t\t//System.out.println(\"returning error node '\"+t+\"' @index=\"+input.index());\n\t\treturn t;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "create tree node that holds the start and stop tokens associated with an error. If you specify your own kind of tree nodes, you will likely have to override this method. CommonTree returns Token.INVALID_TOKEN_TYPE if no token payload but you might have to set token type for diff node type. You don't have to subclass CommonErrorNode; you will likely need to subclass your own tree node class to avoid class cast exception.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "96", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.dupTree", "methodParameterType": "Object#Object#", "methodParameterName": "t#parent#", "methodBody": "public Object dupTree(Object t, Object parent) {\n\t\tif ( t==null ) {\n\t\t\treturn null;\n\t\t}\n\t\tObject newTree = dupNode(t);\n\t\t// ensure new subtree root has parent/child index set\n\t\tsetChildIndex(newTree, getChildIndex(t)); // same index in new tree\n\t\tsetParent(newTree, parent);\n\t\tint n = getChildCount(t);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tObject child = getChild(t, i);\n\t\t\tObject newSubTree = dupTree(child, t);\n\t\t\taddChild(newTree, newSubTree);\n\t\t}\n\t\treturn newTree;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "This is generic in the sense that it will work with any kind of tree (not just Tree interface).  It invokes the adaptor routines not the tree node routines to do the construction.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "97", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.addChild", "methodParameterType": "Object#Object#", "methodParameterName": "t#child#", "methodBody": "@Override\n\tpublic void addChild(Object t, Object child) {\n\t\tif ( t!=null && child!=null ) {\n\t\t\t((Tree)t).addChild((Tree)child);\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Add a child to the tree t.  If child is a flat tree (a list), make all in list children of t.  Warning: if t has no children, but child does and child isNil then you can decide it is ok to move children to t via t.children = child.children; i.e., without copying the array.  Just make sure that this is consistent with have the user will build ASTs.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "98", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.becomeRoot", "methodParameterType": "Object#Object#", "methodParameterName": "newRoot#oldRoot#", "methodBody": "@Override\n\tpublic Object becomeRoot(Object newRoot, Object oldRoot) {\n        //System.out.println(\"becomeroot new \"+newRoot.toString()+\" old \"+oldRoot);\n        Tree newRootTree = (Tree)newRoot;\n\t\tTree oldRootTree = (Tree)oldRoot;\n\t\tif ( oldRoot==null ) {\n\t\t\treturn newRoot;\n\t\t}\n\t\t// handle ^(nil real-node)\n\t\tif ( newRootTree.isNil() ) {\n            int nc = newRootTree.getChildCount();\n            if ( nc==1 ) newRootTree = newRootTree.getChild(0);\n            else if ( nc >1 ) {\n\t\t\t\t// TODO: make tree run time exceptions hierarchy\n\t\t\t\tthrow new RuntimeException(\"more than one node as root (TODO: make exception hierarchy)\");\n\t\t\t}\n        }\n\t\t// add oldRoot to newRoot; addChild takes care of case where oldRoot\n\t\t// is a flat list (i.e., nil-rooted tree).  All children of oldRoot\n\t\t// are added to newRoot.\n\t\tnewRootTree.addChild(oldRootTree);\n\t\treturn newRootTree;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If oldRoot is a nil root, just copy or move the children to newRoot. If not a nil root, make oldRoot a child of newRoot. old=^(nil a b c), new=r yields ^(r a b c) old=^(a b c), new=r yields ^(r ^(a b c)) If newRoot is a nil-rooted single child tree, use the single child as the new root node. old=^(nil a b c), new=^(nil r) yields ^(r a b c) old=^(a b c), new=^(nil r) yields ^(r ^(a b c)) If oldRoot was null, it's ok, just return newRoot (even if isNil). old=null, new=r yields r old=null, new=^(nil r) yields ^(nil r) Return newRoot.  Throw an exception if newRoot is not a simple node or nil root with a single child node--it must be a root node.  If newRoot is ^(nil x) return x as newRoot. Be advised that it's ok for newRoot to point at oldRoot's children; i.e., you don't have to copy the list.  We are constructing these nodes so we should have this control for efficiency.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "99", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.rulePostProcessing", "methodParameterType": "Object#", "methodParameterName": "root#", "methodBody": "@Override\n\tpublic Object rulePostProcessing(Object root) {\n\t\t//System.out.println(\"rulePostProcessing: \"+((Tree)root).toStringTree());\n\t\tTree r = (Tree)root;\n\t\tif ( r!=null && r.isNil() ) {\n\t\t\tif ( r.getChildCount()==0 ) {\n\t\t\t\tr = null;\n\t\t\t}\n\t\t\telse if ( r.getChildCount()==1 ) {\n\t\t\t\tr = r.getChild(0);\n\t\t\t\t// whoever invokes rule will set parent and child index\n\t\t\t\tr.setParent(null);\n\t\t\t\tr.setChildIndex(-1);\n\t\t\t}\n\t\t}\n\t\treturn r;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#NullLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#NullLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#PrefixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Transform ^(nil x) to x and nil to null", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "100", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.createToken", "methodParameterType": "int#String#", "methodParameterName": "tokenType#text#", "methodBody": "public abstract Token createToken(int tokenType, String text);", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Tell me how to create a token for use with imaginary token nodes. For example, there is probably no input symbol associated with imaginary token DECL, but you need to create it as a payload or whatever for the DECL node as in ^(DECL type ID). If you care what the token payload objects' type is, you should override this method and any other createToken variant.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "101", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/BaseTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.BaseTreeAdaptor.createToken", "methodParameterType": "Token#", "methodParameterName": "fromToken#", "methodBody": "public abstract Token createToken(Token fromToken);", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Tell me how to create a token for use with imaginary token nodes. For example, there is probably no input symbol associated with imaginary token DECL, but you need to create it as a payload or whatever for the DECL node as in ^(DECL type ID). This is a variant of createToken where the new token is derived from an actual real input token.  Typically this is for converting '{' tokens to BLOCK etc...  You'll see r : lc='{' ID+ '}' -&gt; ^(BLOCK[$lc] ID+) ; If you care what the token payload objects' type is, you should override this method and any other createToken variant.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "102", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.CommonTreeAdaptor.dupNode", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "@Override\n\tpublic Object dupNode(Object t) {\n\t\tif ( t==null ) return null;\n\t\treturn ((Tree)t).dupNode();\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Duplicate a node.  This is part of the factory; override if you want another kind of node to be built. I could use reflection to prevent having to override this but reflection is slow.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "103", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.CommonTreeAdaptor.createToken", "methodParameterType": "int#String#", "methodParameterName": "tokenType#text#", "methodBody": "@Override\n\tpublic Token createToken(int tokenType, String text) {\n\t\treturn new CommonToken(tokenType, text);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Tell me how to create a token for use with imaginary token nodes. For example, there is probably no input symbol associated with imaginary token DECL, but you need to create it as a payload or whatever for the DECL node as in ^(DECL type ID). If you care what the token payload objects' type is, you should override this method and any other createToken variant.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "104", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.CommonTreeAdaptor.createToken", "methodParameterType": "Token#", "methodParameterName": "fromToken#", "methodBody": "@Override\n\tpublic Token createToken(Token fromToken) {\n\t\treturn new CommonToken(fromToken);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Tell me how to create a token for use with imaginary token nodes. For example, there is probably no input symbol associated with imaginary token DECL, but you need to create it as a payload or whatever for the DECL node as in ^(DECL type ID). This is a variant of createToken where the new token is derived from an actual real input token.  Typically this is for converting '{' tokens to BLOCK etc...  You'll see r : lc='{' ID+ '}' -&gt; ^(BLOCK[$lc] ID+) ; If you care what the token payload objects' type is, you should override this method and any other createToken variant.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "105", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.CommonTreeAdaptor.setTokenBoundaries", "methodParameterType": "Object#Token#Token#", "methodParameterName": "t#startToken#stopToken#", "methodBody": "@Override\n\tpublic void setTokenBoundaries(Object t, Token startToken, Token stopToken) {\n\t\tif ( t==null ) return;\n\t\tint start = 0;\n\t\tint stop = 0;\n\t\tif ( startToken!=null ) start = startToken.getTokenIndex();\n\t\tif ( stopToken!=null ) stop = stopToken.getTokenIndex();\n\t\t((Tree)t).setTokenStartIndex(start);\n\t\t((Tree)t).setTokenStopIndex(stop);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#IfStatement#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement)ReturnStatement)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)IfStatement(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Track start/stop token for subtree root created for a rule. Only works with Tree nodes.  For rules that match nothing, seems like this will yield start=i and stop=i-1 in a nil node. Might be useful info so I'll not force to be i..i.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "106", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/CommonTreeAdaptor.java", "methodName": "org.antlr.runtime.tree.CommonTreeAdaptor.getToken", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "@Override\n\tpublic Token getToken(Object t) {\n\t\tif ( t instanceof CommonTree ) {\n\t\t\treturn ((CommonTree)t).getToken();\n\t\t}\n\t\treturn null; // no idea what to do\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ReturnStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the Token associated with this node?  If you are not using CommonTree, then you must override this in your own adaptor.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "107", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleTokenStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleTokenStream.RewriteRuleTokenStream", "methodParameterType": "TreeAdaptor#String#Object#", "methodParameterName": "adaptor#elementDescription#oneElement#", "methodBody": "public RewriteRuleTokenStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t  String elementDescription,\n\t\t\t\t\t\t\t\t  Object oneElement)\n\t{\n\t\tsuper(adaptor, elementDescription, oneElement);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream with one element", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "108", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleTokenStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleTokenStream.RewriteRuleTokenStream", "methodParameterType": "TreeAdaptor#String#List<Object>#", "methodParameterName": "adaptor#elementDescription#elements#", "methodBody": "public RewriteRuleTokenStream(TreeAdaptor adaptor,\n\t\t\t\t\t\t\t\t  String elementDescription,\n\t\t\t\t\t\t\t\t  List<Object> elements)\n\t{\n\t\tsuper(adaptor, elementDescription, elements);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a stream, but feed off an existing list", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "109", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleTokenStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleTokenStream.nextNode", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object nextNode() {\n\t\tToken t = (Token)_next();\n\t\treturn adaptor.create(t);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get next token from stream and make a node for it", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "110", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/RewriteRuleTokenStream.java", "methodName": "org.antlr.runtime.tree.RewriteRuleTokenStream.toTree", "methodParameterType": "Object#", "methodParameterName": "el#", "methodBody": "@Override\n\tprotected Object toTree(Object el) {\n\t\treturn el;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Don't convert to a tree unless they explicitly call nextTree. This way we can do hetero tree nodes in rewrite.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "111", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.create", "methodParameterType": "Token#", "methodParameterName": "payload#", "methodBody": "public Object create(Token payload);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Create a tree node from Token object; for CommonTree type trees, then the token just becomes the payload.  This is the most common create call. Override if you want another kind of node to be built.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "112", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.dupNode", "methodParameterType": "Object#", "methodParameterName": "treeNode#", "methodBody": "public Object dupNode(Object treeNode);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Duplicate a single tree node. Override if you want another kind of node to be built.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "113", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.dupTree", "methodParameterType": "Object#", "methodParameterName": "tree#", "methodBody": "public Object dupTree(Object tree);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Duplicate tree recursively, using dupNode() for each node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "114", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.nil", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object nil();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return a nil node (an empty but non-null node) that can hold a list of element as the children.  If you want a flat tree (a list) use \"t=adaptor.nil(); t.addChild(x); t.addChild(y);\"", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "115", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.errorNode", "methodParameterType": "TokenStream#Token#Token#RecognitionException#", "methodParameterName": "input#start#stop#e#", "methodBody": "public Object errorNode(TokenStream input, Token start, Token stop, RecognitionException e);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Return a tree node representing an error.  This node records the tokens consumed during error recovery.  The start token indicates the input symbol at which the error was detected.  The stop token indicates the last symbol consumed during recovery. You must specify the input stream so that the erroneous text can be packaged up in the error node.  The exception could be useful to some applications; default implementation stores ptr to it in the CommonErrorNode. This only makes sense during token parsing, not tree parsing. Tree parsing should happen only when parsing and tree construction succeed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "116", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.isNil", "methodParameterType": "Object#", "methodParameterName": "tree#", "methodBody": "public boolean isNil(Object tree);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Is tree considered a nil node used to make lists of child nodes?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "117", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.addChild", "methodParameterType": "Object#Object#", "methodParameterName": "t#child#", "methodBody": "public void addChild(Object t, Object child);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Add a child to the tree t.  If child is a flat tree (a list), make all in list children of t.  Warning: if t has no children, but child does and child isNil then you can decide it is ok to move children to t via t.children = child.children; i.e., without copying the array.  Just make sure that this is consistent with have the user will build ASTs.  Do nothing if t or child is null.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "118", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.becomeRoot", "methodParameterType": "Object#Object#", "methodParameterName": "newRoot#oldRoot#", "methodBody": "public Object becomeRoot(Object newRoot, Object oldRoot);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "If oldRoot is a nil root, just copy or move the children to newRoot. If not a nil root, make oldRoot a child of newRoot. old=^(nil a b c), new=r yields ^(r a b c) old=^(a b c), new=r yields ^(r ^(a b c)) If newRoot is a nil-rooted single child tree, use the single child as the new root node. old=^(nil a b c), new=^(nil r) yields ^(r a b c) old=^(a b c), new=^(nil r) yields ^(r ^(a b c)) If oldRoot was null, it's ok, just return newRoot (even if isNil). old=null, new=r yields r old=null, new=^(nil r) yields ^(nil r) Return newRoot.  Throw an exception if newRoot is not a simple node or nil root with a single child node--it must be a root node.  If newRoot is ^(nil x) return x as newRoot. Be advised that it's ok for newRoot to point at oldRoot's children; i.e., you don't have to copy the list.  We are constructing these nodes so we should have this control for efficiency.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "119", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.rulePostProcessing", "methodParameterType": "Object#", "methodParameterName": "root#", "methodBody": "public Object rulePostProcessing(Object root);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Given the root of the subtree created for this rule, post process it to do any simplifications or whatever you want.  A required behavior is to convert ^(nil singleSubtree) to singleSubtree as the setting of start/stop indexes relies on a single non-nil root for non-flat trees. Flat trees such as for lists like \"idlist : ID+ ;\" are left alone unless there is only one ID.  For a list, the start/stop indexes are set in the nil node. This method is executed after all rule tree construction and right before setTokenBoundaries().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "120", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getUniqueID", "methodParameterType": "Object#", "methodParameterName": "node#", "methodBody": "public int getUniqueID(Object node);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "For identifying trees. How to identify nodes so we can say \"add node to a prior node\"? Even becomeRoot is an issue.  Use System.identityHashCode(node) usually.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "121", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.becomeRoot", "methodParameterType": "Token#Object#", "methodParameterName": "newRoot#oldRoot#", "methodBody": "public Object becomeRoot(Token newRoot, Object oldRoot);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Create a node for newRoot make it the root of oldRoot. If oldRoot is a nil root, just copy or move the children to newRoot. If not a nil root, make oldRoot a child of newRoot. Return node created for newRoot. Be advised: when debugging ASTs, the DebugTreeAdaptor manually calls create(Token child) and then plain becomeRoot(node, node) because it needs to trap calls to create, but it can't since it delegates to not inherits from the TreeAdaptor.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "122", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.create", "methodParameterType": "int#Token#", "methodParameterName": "tokenType#fromToken#", "methodBody": "public Object create(int tokenType, Token fromToken);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Create a new node derived from a token, with a new token type. This is invoked from an imaginary node ref on right side of a rewrite rule as IMAG[$tokenLabel]. This should invoke createToken(Token).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "123", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.create", "methodParameterType": "int#Token#String#", "methodParameterName": "tokenType#fromToken#text#", "methodBody": "public Object create(int tokenType, Token fromToken, String text);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Same as create(tokenType,fromToken) except set the text too. This is invoked from an imaginary node ref on right side of a rewrite rule as IMAG[$tokenLabel, \"IMAG\"]. This should invoke createToken(Token).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "124", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.create", "methodParameterType": "int#String#", "methodParameterName": "tokenType#text#", "methodBody": "public Object create(int tokenType, String text);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Create a new node derived from a token, with a new token type. This is invoked from an imaginary node ref on right side of a rewrite rule as IMAG[\"IMAG\"]. This should invoke createToken(int,String).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "125", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getType", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public int getType(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "For tree parsing, I need to know the token type of a node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "126", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.setType", "methodParameterType": "Object#int#", "methodParameterName": "t#type#", "methodBody": "public void setType(Object t, int type);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Node constructors can set the type of a node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "127", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.setText", "methodParameterType": "Object#String#", "methodParameterName": "t#text#", "methodBody": "public void setText(Object t, String text);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Node constructors can set the text of a node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "128", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getToken", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public Token getToken(Object t);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Return the token object from which this node was created. Currently used only for printing an error message. The error display routine in BaseRecognizer needs to display where the input the error occurred. If your tree of limitation does not store information that can lead you to the token, you can create a token filled with the appropriate information and pass that back.  See BaseRecognizer.getErrorMessage().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "129", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.setTokenBoundaries", "methodParameterType": "Object#Token#Token#", "methodParameterName": "t#startToken#stopToken#", "methodBody": "public void setTokenBoundaries(Object t, Token startToken, Token stopToken);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Where are the bounds in the input token stream for this node and all children?  Each rule that creates AST nodes will call this method right before returning.  Flat trees (i.e., lists) will still usually have a nil root node just to hold the children list. That node would contain the start/stop indexes then.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "130", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getTokenStartIndex", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public int getTokenStartIndex(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get the token start index for this subtree; return -1 if no such index", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "131", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getTokenStopIndex", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public int getTokenStopIndex(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get the token stop index for this subtree; return -1 if no such index", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "132", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getChild", "methodParameterType": "Object#int#", "methodParameterName": "t#i#", "methodBody": "public Object getChild(Object t, int i);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get a child 0..n-1 node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "133", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.setChild", "methodParameterType": "Object#int#Object#", "methodParameterName": "t#i#child#", "methodBody": "public void setChild(Object t, int i, Object child);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Set ith child (0..n-1) to t; t must be non-null and non-nil node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "134", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.deleteChild", "methodParameterType": "Object#int#", "methodParameterName": "t#i#", "methodBody": "public Object deleteChild(Object t, int i);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Remove ith child and shift children down from right.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "135", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getChildCount", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public int getChildCount(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "How many children?  If 0, then this is a leaf node", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "136", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getParent", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public Object getParent(Object t);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Who is the parent node of this node; if null, implies node is root. If your node type doesn't handle this, it's ok but the tree rewrites in tree parsers need this functionality.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "137", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.getChildIndex", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public int getChildIndex(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "What index is this node in the child list? Range: 0..n-1 If your node type doesn't handle this, it's ok but the tree rewrites in tree parsers need this functionality.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "138", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/tree/TreeAdaptor.java", "methodName": "org.antlr.runtime.tree.TreeAdaptor.replaceChildren", "methodParameterType": "Object#int#int#Object#", "methodParameterName": "parent#startChildIndex#stopChildIndex#t#", "methodBody": "public void replaceChildren(Object parent, int startChildIndex, int stopChildIndex, Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Replace from start to stop child index of parent with t, which might be a list.  Number of children may be different after this call. If parent is null, don't do anything; must be at root of overall tree. Can't replace whatever points to the parent externally.  Do nothing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "139", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CommonToken.java", "methodName": "org.antlr.runtime.CommonToken.setText", "methodParameterType": "String#", "methodParameterName": "text#", "methodBody": "@Override\n\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Override the text for this token.  getText() will return this text rather than pulling from the buffer.  Note that this does not mean that start/stop indexes are not valid.  It means that that input was converted to a new string in the token object.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "140", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/IntArray.java", "methodName": "org.antlr.runtime.misc.IntArray.size", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int size() {\n\t\treturn p;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "This only tracks elements added via push/add.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "141", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java", "methodName": "org.antlr.runtime.misc.FastQueue.remove", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public T remove() {\n        T o = elementAt(0);\n        p++;\n        // have we hit end of buffer?\n        if ( p == data.size() ) {\n            // if so, it's an opportunity to start filling at index 0 again\n            clear(); // size goes to 0, but retains memory\n        }\n        return o;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get and remove first element in queue", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "142", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java", "methodName": "org.antlr.runtime.misc.FastQueue.elementAt", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "public T elementAt(int i) {\n\t\tint absIndex = p + i;\n\t\tif ( absIndex >= data.size() ) {\n            throw new NoSuchElementException(\"queue index \"+ absIndex +\" > last index \"+(data.size()-1));\n        }\n        if ( absIndex < 0 ) {\n            throw new NoSuchElementException(\"queue index \"+ absIndex +\" < 0\");\n        }\n\t\tif ( absIndex>range ) range = absIndex;\n        return data.get(absIndex);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ParenthesizedExpression#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return element  {@code i} elements ahead of current element. {@code i==0}gets current element. This is not an absolute index into  {@link #data}since  {@code p} defines the start of the real list.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "143", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/FastQueue.java", "methodName": "org.antlr.runtime.misc.FastQueue.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        int n = size();\n        for (int i=0; i<n; i++) {\n            buf.append(elementAt(i));\n            if ( (i+1)<n ) buf.append(\" \");\n        }\n        return buf.toString();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)IfStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return string of current buffer contents; non-destructive", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "144", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/DoubleKeyMap.java", "methodName": "org.antlr.runtime.misc.DoubleKeyMap.values", "methodParameterType": "Key1#", "methodParameterName": "k1#", "methodBody": "public Collection<Value> values(Key1 k1) {\n\t\tMap<Key2, Value> data2 = data.get(k1);\n\t\tif ( data2==null ) return null;\n\t\treturn data2.values();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get all values associated with primary key", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "145", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/DoubleKeyMap.java", "methodName": "org.antlr.runtime.misc.DoubleKeyMap.keySet", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<Key1> keySet() {\n\t\treturn data.keySet();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "get all primary keys", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "146", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/DoubleKeyMap.java", "methodName": "org.antlr.runtime.misc.DoubleKeyMap.keySet", "methodParameterType": "Key1#", "methodParameterName": "k1#", "methodBody": "public Set<Key2> keySet(Key1 k1) {\n\t\tMap<Key2, Value> data2 = data.get(k1);\n\t\tif ( data2==null ) return null;\n\t\treturn data2.keySet();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "get all secondary keys associated with a primary key", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "147", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/Stats.java", "methodName": "org.antlr.runtime.misc.Stats.stddev", "methodParameterType": "int[]#", "methodParameterName": "X#", "methodBody": "public static double stddev(int[] X) {\n\t\tint m = X.length;\n\t\tif ( m<=1 ) {\n\t\t\treturn 0;\n\t\t}\n\t\tdouble xbar = avg(X);\n\t\tdouble s2 = 0.0;\n\t\tfor (int i=0; i<m; i++){\n\t\t\ts2 += (X[i] - xbar)*(X[i] - xbar);\n\t\t}\n\t\ts2 = s2/(m-1);\n\t\treturn Math.sqrt(s2);\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#NumberLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(ParenthesizedExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression(ParenthesizedExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression)Assignment)ExpressionStatement)Block)ForStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)InfixExpression)Assignment)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute the sample (unbiased estimator) standard deviation following: Computing Deviations: Standard Accuracy Tony F. Chan and John Gregg Lewis Stanford University Communications of ACM September 1979 of Volume 22 the ACM Number 9 The \"two-pass\" method from the paper; supposed to have better numerical properties than the textbook summation/sqrt.  To me this looks like the textbook method, but I ain't no numerical methods guy.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "148", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/Stats.java", "methodName": "org.antlr.runtime.misc.Stats.avg", "methodParameterType": "int[]#", "methodParameterName": "X#", "methodBody": "public static double avg(int[] X) {\n\t\tdouble xbar = 0.0;\n\t\tint m = X.length;\n\t\tif ( m==0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i=0; i<m; i++){\n\t\t\txbar += X[i];\n\t\t}\n\t\tif ( xbar>=0.0 ) {\n\t\t\treturn xbar / m;\n\t\t}\n\t\treturn 0.0;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#NumberLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#ArrayAccess#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#IfStatement#NumberLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)Assignment)ExpressionStatement)Block)ForStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)IfStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute the sample mean", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "149", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/Stats.java", "methodName": "org.antlr.runtime.misc.Stats.avg", "methodParameterType": "List<Integer>#", "methodParameterName": "X#", "methodBody": "public static double avg(List<Integer> X) {\n\t\tdouble xbar = 0.0;\n\t\tint m = X.size();\n\t\tif ( m==0 ) {\n\t\t\treturn 0;\n\t\t}\n\t\tfor (int i=0; i<m; i++){\n\t\t\txbar += X.get(i);\n\t\t}\n\t\tif ( xbar>=0.0 ) {\n\t\t\treturn xbar / m;\n\t\t}\n\t\treturn 0.0;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#NumberLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#IfStatement#NumberLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)IfStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute the sample mean", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "150", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.nextElement", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public abstract T nextElement();", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Implement nextElement to supply a stream of elements to this lookahead buffer.  Return EOF upon end of the stream we're pulling from.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "151", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.remove", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public T remove() {\n        T o = elementAt(0);\n        p++;\n        // have we hit end of buffer and not backtracking?\n        if ( p == data.size() && markDepth==0 ) {\n            prevElement = o;\n            // if so, it's an opportunity to start filling at index 0 again\n            clear(); // size goes to 0, but retains memory\n        }\n        return o;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get and remove first element in queue; override {@link FastQueue#remove()}; it's the same, just checks for backtracking.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "152", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.consume", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void consume() {\n        syncAhead(1);\n        remove();\n        currentElementIndex++;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make sure we have at least one element to remove, even if EOF", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "153", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.syncAhead", "methodParameterType": "int#", "methodParameterName": "need#", "methodBody": "protected void syncAhead(int need) {\n        int n = (p+need-1) - data.size() + 1; // how many more elements we need?\n        if ( n > 0 ) fill(n);                 // out of elements?\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Make sure we have 'need' elements from current position p. Last valid p index is data.size()-1.  p+need-1 is the data index 'need' elements ahead.  If we need 1 element, (p+1-1)==p must be &lt; data.size().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "154", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.fill", "methodParameterType": "int#", "methodParameterName": "n#", "methodBody": "public void fill(int n) {\n        for (int i=1; i<=n; i++) {\n            T o = nextElement();\n            if ( isEOF(o) ) eof = o;\n            data.add(o);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#Assignment#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "add n elements to buffer", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "155", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.size", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int size() { throw new UnsupportedOperationException(\"streams are of unknown size\"); }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)MethodDeclaration", "methodDoc": "Size of entire stream is unknown; we only know buffer size from FastQueue.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "156", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/misc/LookaheadStream.java", "methodName": "org.antlr.runtime.misc.LookaheadStream.seek", "methodParameterType": "int#", "methodParameterName": "index#", "methodBody": "public void seek(int index) {\n        if (index < 0) {\n            throw new IllegalArgumentException(\"can't seek before the beginning of the input\");\n        }\n\n        int delta = currentElementIndex - index;\n        if (p - delta < 0) {\n            throw new UnsupportedOperationException(\"can't seek before the beginning of this stream's buffer\");\n        }\n\n        p -= delta;\n        currentElementIndex = index;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Seek to a 0-indexed absolute token index. Normally used to seek backwards in the buffer. Does not force loading of nodes. <p> To preserve backward compatibility, this method allows seeking past the end of the currently buffered data. In this case, the input pointer will be moved but the data will only actually be loaded upon the next call to {@link #consume} or {@link #LT} for {@code k>0}.</p>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "157", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/UnwantedTokenException.java", "methodName": "org.antlr.runtime.UnwantedTokenException.UnwantedTokenException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public UnwantedTokenException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "158", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/MismatchedRangeException.java", "methodName": "org.antlr.runtime.MismatchedRangeException.MismatchedRangeException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public MismatchedRangeException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "159", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/NoViableAltException.java", "methodName": "org.antlr.runtime.NoViableAltException.NoViableAltException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public NoViableAltException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "160", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.consume", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public void consume() {\n        if ( p == -1 ) setup();\n        p++;\n        sync(p);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Move the input pointer to the next incoming token.  The stream must become active with LT(1) available.  consume() simply moves the input pointer so that LT(1) points at the next input symbol. Consume at least one token. Walk past any token not on the channel the parser is listening to.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "161", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.sync", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "protected void sync(int i) {\n        int n = i - tokens.size() + 1; // how many more elements we need?\n        //System.out.println(\"sync(\"+i+\") needs \"+n);\n        if ( n > 0 ) fetch(n);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Make sure index i in tokens has a token.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "162", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.fetch", "methodParameterType": "int#", "methodParameterName": "n#", "methodBody": "protected void fetch(int n) {\n        for (int i=1; i<=n; i++) {\n            Token t = tokenSource.nextToken();\n            t.setTokenIndex(tokens.size());\n            //System.out.println(\"adding \"+t+\" at index \"+tokens.size());\n            tokens.add(t);\n            if ( t.getType()==Token.EOF ) break;\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#BreakStatement#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(BreakStatement)BreakStatement)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "add n elements to buffer", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "163", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.get", "methodParameterType": "int#int#", "methodParameterName": "start#stop#", "methodBody": "public List<? extends Token> get(int start, int stop) {\n\t\tif ( start<0 || stop<0 ) return null;\n\t\tif ( p == -1 ) setup();\n\t\tList<Token> subset = new ArrayList<Token>();\n\t\tif ( stop>=tokens.size() ) stop = tokens.size()-1;\n\t\tfor (int i = start; i <= stop; i++) {\n\t\t\tToken t = tokens.get(i);\n\t\t\tif ( t.getType()==Token.EOF ) break;\n\t\t\tsubset.add(t);\n\t\t}\n\t\treturn subset;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#BreakStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(BreakStatement)BreakStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get all tokens from start..stop inclusively", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "164", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.setTokenSource", "methodParameterType": "TokenSource#", "methodParameterName": "tokenSource#", "methodBody": "public void setTokenSource(TokenSource tokenSource) {\n        this.tokenSource = tokenSource;\n        tokens.clear();\n        p = -1;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#PrefixExpression#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset this token stream by setting its token source.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "165", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.getTokens", "methodParameterType": "int#int#BitSet#", "methodParameterName": "start#stop#types#", "methodBody": "public List<? extends Token> getTokens(int start, int stop, BitSet types) {\n        if ( p == -1 ) setup();\n        if ( stop>=tokens.size() ) stop=tokens.size()-1;\n        if ( start<0 ) start=0;\n        if ( start>stop ) return null;\n\n        // list = tokens[start:stop]:{Token t, t.getType() in types}\n        List<Token> filteredTokens = new ArrayList<Token>();\n        for (int i=start; i<=stop; i++) {\n            Token t = tokens.get(i);\n            if ( types==null || types.member(t.getType()) ) {\n                filteredTokens.add(t);\n            }\n        }\n        if ( filteredTokens.isEmpty() ) {\n            filteredTokens = null;\n        }\n        return filteredTokens;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#Assignment#ExpressionStatement#IfStatement#SimpleName#SimpleName#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a start and stop index, return a List of all tokens in the token type BitSet.  Return null if no tokens were found.  This method looks at both on and off channel tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "166", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public String toString() {\n        if ( p == -1 ) setup();\n        fill();\n        return toString(0, tokens.size()-1);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Grab", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "167", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BufferedTokenStream.java", "methodName": "org.antlr.runtime.BufferedTokenStream.fill", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void fill() {\n        if ( p == -1 ) setup();\n        if ( tokens.get(p).getType()==Token.EOF ) return;\n\n        int i = p+1;\n        sync(i);\n        while ( tokens.get(i).getType()!=Token.EOF ) {\n            i++;\n            sync(i);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#IfStatement#PrimitiveType#SimpleName#SimpleName#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(ReturnStatement)ReturnStatement)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "Get all tokens from lexer until EOF", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "168", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.BitSet", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public BitSet() {\n        this(BITS);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(ConstructorInvocation(SimpleName)SimpleName)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Construct a bitset of size one word (64 bits)", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "169", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.BitSet", "methodParameterType": "long[]#", "methodParameterName": "bits_#", "methodBody": "public BitSet(long[] bits_) {\n        bits = bits_;\n    }", "AST": "Javadoc#Modifier#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Construction from a static array of longs", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "170", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.BitSet", "methodParameterType": "List<Integer>#", "methodParameterName": "items#", "methodBody": "public BitSet(List<Integer> items) {\n\t\tthis();\n\t\tfor (int i = 0; i < items.size(); i++) {\n\t\t\tInteger v = items.get(i);\n\t\t\tadd(v);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#ConstructorInvocation#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation)ConstructorInvocation(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Construction from a list of integers", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "171", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.BitSet", "methodParameterType": "int#", "methodParameterName": "nbits#", "methodBody": "public BitSet(int nbits) {\n        bits = new long[((nbits - 1) >> LOG_BITS) + 1];\n    }", "AST": "Javadoc#Modifier#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#ArrayCreation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(InfixExpression(ParenthesizedExpression(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression)ArrayCreation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Construct a bitset given the size", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "172", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.or", "methodParameterType": "BitSet#", "methodParameterName": "a#", "methodBody": "public BitSet or(BitSet a) {\n\t\tif ( a==null ) {\n\t\t\treturn this;\n\t\t}\n\t\tBitSet s = (BitSet)this.clone();\n\t\ts.orInPlace(a);\n\t\treturn s;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ThisExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(ThisExpression)ThisExpression)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return this | a in a new set", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "173", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.add", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "public void add(int el) {\n\t\tint n = wordNumber(el);\n\t\tif (n >= bits.length) {\n\t\t\tgrowToInclude(el);\n\t\t}\n\t\tbits[n] |= bitMask(el);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "or this element into this set (grow as necessary to accommodate)", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "174", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.growToInclude", "methodParameterType": "int#", "methodParameterName": "bit#", "methodBody": "public void growToInclude(int bit) {\n\t\tint newSize = Math.max(bits.length << 1, numWordsToHold(bit));\n\t\tlong newbits[] = new long[newSize];\n\t\tSystem.arraycopy(bits, 0, newbits, 0, bits.length);\n\t\tbits = newbits;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#Dimension#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(Dimension)Dimension(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Grows the set to a larger number of bits.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "175", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.setSize", "methodParameterType": "int#", "methodParameterName": "nwords#", "methodBody": "private void setSize(int nwords) {\n\t\tlong newbits[] = new long[nwords];\n\t\tint n = Math.min(nwords, bits.length);\n\t\tSystem.arraycopy(bits, 0, newbits, 0, n);\n\t\tbits = newbits;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#Dimension#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#NumberLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(Dimension)Dimension(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets the size of a set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "176", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.lengthInLongWords", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int lengthInLongWords() {\n        return bits.length;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return how much space is being used by the bits array not how many actually have member bits on.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "177", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BitSet.java", "methodName": "org.antlr.runtime.BitSet.toArray", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "/*\n\tpublic boolean subset(BitSet a) {\n        if (a == null || !(a instanceof BitSet)) return false;\n        return this.and(a).equals(this);\n    }\n\t*/\n\n    public int[] toArray() {\n        int[] elems = new int[size()];\n        int en = 0;\n        for (int i = 0; i < (bits.length << LOG_BITS); i++) {\n            if (member(i)) {\n                elems[en++] = i;\n            }\n        }\n        return elems;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#Dimension#ArrayType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#MethodInvocation#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#PostfixExpression#ArrayAccess#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is this contained within a?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "178", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/MismatchedTokenException.java", "methodName": "org.antlr.runtime.MismatchedTokenException.MismatchedTokenException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public MismatchedTokenException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "179", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.LT", "methodParameterType": "int#", "methodParameterName": "k#", "methodBody": "public Token LT(int k);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get Token at current input pointer + i ahead where i=1 is next Token. i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken. Return null for LT(0) and any index that results in an absolute address that is negative.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "180", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.range", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int range();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "How far ahead has the stream been asked to look?  The return value is a valid index from 0..n-1.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "181", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.get", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "public Token get(int i);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get a token at an absolute index i; 0..n-1.  This is really only needed for profiling and debugging and token stream rewriting. If you don't want to buffer up tokens, then this method makes no sense for you.  Naturally you can't use the rewrite stream feature. I believe DebugTokenStream can easily be altered to not use this method, removing the dependency.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "182", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.getTokenSource", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public TokenSource getTokenSource();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Where is this stream pulling tokens from?  This is not the name, but the object that provides Token objects.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "183", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.toString", "methodParameterType": "int#int#", "methodParameterName": "start#stop#", "methodBody": "public String toString(int start, int stop);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Return the text of all tokens from start to stop, inclusive. If the stream does not buffer all the tokens then it can just return \"\" or null;  Users should not access $ruleLabel.text in an action of course in that case.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "184", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenStream.java", "methodName": "org.antlr.runtime.TokenStream.toString", "methodParameterType": "Token#Token#", "methodParameterName": "start#stop#", "methodBody": "public String toString(Token start, Token stop);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Because the user is not required to use a token with an index stored in it, we must provide a means for two token objects themselves to indicate the start/end location.  Most often this will just delegate to the other toString(int,int).  This is also parallel with the TreeNodeStream.toString(Object,Object).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "185", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.setTokenSource", "methodParameterType": "TokenSource#", "methodParameterName": "tokenSource#", "methodBody": "public void setTokenSource(TokenSource tokenSource) {\n\t\tthis.tokenSource = tokenSource;\n\t\ttokens.clear();\n\t\tp = -1;\n\t\tchannel = Token.DEFAULT_CHANNEL;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#PrefixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset this token stream by setting its token source.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "186", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.fillBuffer", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected void fillBuffer() {\n\t\tint index = 0;\n\t\tToken t = tokenSource.nextToken();\n\t\twhile ( t!=null && t.getType()!=CharStream.EOF ) {\n\t\t\tboolean discard = false;\n\t\t\t// is there a channel override for token type?\n\t\t\tif ( channelOverrideMap!=null ) {\n\t\t\t\tInteger channelI = channelOverrideMap.get(t.getType());\n\t\t\t\tif ( channelI!=null ) {\n\t\t\t\t\tt.setChannel(channelI);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( discardSet!=null &&\n\t\t\t\t discardSet.contains(new Integer(t.getType())) )\n\t\t\t{\n\t\t\t\tdiscard = true;\n\t\t\t}\n\t\t\telse if ( discardOffChannelTokens && t.getChannel()!=this.channel ) {\n\t\t\t\tdiscard = true;\n\t\t\t}\n\t\t\tif ( !discard )\t{\n\t\t\t\tt.setTokenIndex(index);\n\t\t\t\ttokens.add(t);\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tt = tokenSource.nextToken();\n\t\t}\n\t\t// leave p pointing at first token on channel\n\t\tp = 0;\n\t\tp = skipOffTokenChannels(p);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#MethodInvocation#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ThisExpression#SimpleName#FieldAccess#InfixExpression#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Load all tokens from the token source and put in tokens. This is done upon first LT request because you might want to set some token type / channel overrides before filling buffer.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "187", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.consume", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic void consume() {\n\t\tif ( p<tokens.size() ) {\n            p++;\n\t\t\tp = skipOffTokenChannels(p); // leave p on valid token\n        }\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Move the input pointer to the next incoming token.  The stream must become active with LT(1) available.  consume() simply moves the input pointer so that LT(1) points at the next input symbol. Consume at least one token. Walk past any token not on the channel the parser is listening to.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "188", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.skipOffTokenChannels", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "protected int skipOffTokenChannels(int i) {\n\t\tint n = tokens.size();\n\t\twhile ( i<n && tokens.get(i).getChannel()!=channel ) {\n\t\t\ti++;\n\t\t}\n\t\treturn i;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a starting index, return the index of the first on-channel token.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "189", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.setTokenTypeChannel", "methodParameterType": "int#int#", "methodParameterName": "ttype#channel#", "methodBody": "public void setTokenTypeChannel(int ttype, int channel) {\n\t\tif ( channelOverrideMap==null ) {\n\t\t\tchannelOverrideMap = new HashMap<Integer, Integer>();\n\t\t}\n        channelOverrideMap.put(ttype, channel);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "A simple filter mechanism whereby you can tell this token stream to force all tokens of type ttype to be on channel.  For example, when interpreting, we cannot exec actions so we need to tell the stream to force all WS and NEWLINE to be a different, ignored channel.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "190", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.getTokens", "methodParameterType": "int#int#BitSet#", "methodParameterName": "start#stop#types#", "methodBody": "public List<? extends Token> getTokens(int start, int stop, BitSet types) {\n\t\tif ( p == -1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tif ( stop>=tokens.size() ) {\n\t\t\tstop=tokens.size()-1;\n\t\t}\n\t\tif ( start<0 ) {\n\t\t\tstart=0;\n\t\t}\n\t\tif ( start>stop ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// list = tokens[start:stop]:{Token t, t.getType() in types}\n\t\tList<Token> filteredTokens = new ArrayList<Token>();\n\t\tfor (int i=start; i<=stop; i++) {\n\t\t\tToken t = tokens.get(i);\n\t\t\tif ( types==null || types.member(t.getType()) ) {\n\t\t\t\tfilteredTokens.add(t);\n\t\t\t}\n\t\t}\n\t\tif ( filteredTokens.isEmpty() ) {\n\t\t\tfilteredTokens = null;\n\t\t}\n\t\treturn filteredTokens;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a start and stop index, return a List of all tokens in the token type BitSet.  Return null if no tokens were found.  This method looks at both on and off channel tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "191", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.LT", "methodParameterType": "int#", "methodParameterName": "k#", "methodBody": "@Override\n\tpublic Token LT(int k) {\n\t\tif ( p == -1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tif ( k==0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( k<0 ) {\n\t\t\treturn LB(-k);\n\t\t}\n\t\t//System.out.print(\"LT(p=\"+p+\",\"+k+\")=\");\n\t\tif ( (p+k-1) >= tokens.size() ) {\n            return tokens.get(tokens.size()-1);\n\t\t}\n\t\t//System.out.println(tokens.get(p+k-1));\n\t\tint i = p;\n\t\tint n = 1;\n\t\t// find k good tokens\n\t\twhile ( n<k ) {\n\t\t\t// skip off-channel tokens\n\t\t\ti = skipOffTokenChannels(i+1); // leave p on valid token\n\t\t\tn++;\n\t\t}\n\t\tif ( i>=tokens.size() ) {\n            return tokens.get(tokens.size()-1); // must be EOF\n\t\t}\n\n\t\tif ( i>range ) range = i;\n        return tokens.get(i);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#PrefixExpression#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(PrefixExpression(SimpleName)SimpleName)PrefixExpression)MethodInvocation)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the ith token from the current position 1..n where k=1 is the first symbol of lookahead.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "192", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.LB", "methodParameterType": "int#", "methodParameterName": "k#", "methodBody": "protected Token LB(int k) {\n\t\t//System.out.print(\"LB(p=\"+p+\",\"+k+\") \");\n\t\tif ( p == -1 ) {\n\t\t\tfillBuffer();\n\t\t}\n\t\tif ( k==0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tif ( (p-k)<0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tint i = p;\n\t\tint n = 1;\n\t\t// find k good tokens looking backwards\n\t\twhile ( n<=k ) {\n\t\t\t// skip off-channel tokens\n\t\t\ti = skipOffTokenChannelsReverse(i-1); // leave p on valid token\n\t\t\tn++;\n\t\t}\n\t\tif ( i<0 ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn tokens.get(i);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Look backwards k tokens on-channel tokens", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "193", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.get", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "@Override\n\tpublic Token get(int i) {\n\t\treturn tokens.get(i);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return absolute token i; ignore which channel the tokens are on; that is, count all tokens not just on-channel tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "194", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/LegacyCommonTokenStream.java", "methodName": "org.antlr.runtime.LegacyCommonTokenStream.get", "methodParameterType": "int#int#", "methodParameterName": "start#stop#", "methodBody": "public List<? extends Token> get(int start, int stop) {\n\t\tif ( p == -1 ) fillBuffer();\n\t\tif ( start<0 || stop<0 ) return null;\n\t\treturn tokens.subList(start, stop);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get all tokens from start..stop inclusively", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "195", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/DFA.java", "methodName": "org.antlr.runtime.DFA.predict", "methodParameterType": "IntStream#", "methodParameterName": "input#", "methodBody": "public int predict(IntStream input)\n\t\tthrows RecognitionException\n\t{\n\t\tif ( debug ) {\n\t\t\tSystem.err.println(\"Enter DFA.predict for decision \"+decisionNumber);\n\t\t}\n\t\tint mark = input.mark(); // remember where decision started in input\n\t\tint s = 0; // we always start at s0\n\t\ttry {\n\t\t\twhile ( true ) {\n\t\t\t\tif ( debug ) System.err.println(\"DFA \"+decisionNumber+\" state \"+s+\" LA(1)=\"+(char)input.LA(1)+\"(\"+input.LA(1)+\n\t\t\t\t\t\t\t\t\t\t\t\t\"), index=\"+input.index());\n\t\t\t\tint specialState = special[s];\n\t\t\t\tif ( specialState>=0 ) {\n\t\t\t\t\tif ( debug ) {\n\t\t\t\t\t\tSystem.err.println(\"DFA \"+decisionNumber+\n\t\t\t\t\t\t\t\" state \"+s+\" is special state \"+specialState);\n\t\t\t\t\t}\n\t\t\t\t\ts = specialStateTransition(specialState,input);\n\t\t\t\t\tif ( debug ) {\n\t\t\t\t\t\tSystem.err.println(\"DFA \"+decisionNumber+\n\t\t\t\t\t\t\t\" returns from special state \"+specialState+\" to \"+s);\n\t\t\t\t\t}\n\t\t\t\t\tif ( s==-1 ) {\n\t\t\t\t\t\tnoViableAlt(s,input);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\tinput.consume();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( accept[s] >= 1 ) {\n\t\t\t\t\tif ( debug ) System.err.println(\"accept; predict \"+accept[s]+\" from state \"+s);\n\t\t\t\t\treturn accept[s];\n\t\t\t\t}\n\t\t\t\t// look for a normal char transition\n\t\t\t\tchar c = (char)input.LA(1); // -1 == \\uFFFF, all tokens fit in 65000 space\n\t\t\t\tif (c>=min[s] && c<=max[s]) {\n\t\t\t\t\tint snext = transition[s][c-min[s]]; // move to next state\n\t\t\t\t\tif ( snext < 0 ) {\n\t\t\t\t\t\t// was in range but not a normal transition\n\t\t\t\t\t\t// must check EOT, which is like the else clause.\n\t\t\t\t\t\t// eot[s]>=0 indicates that an EOT edge goes to another\n\t\t\t\t\t\t// state.\n\t\t\t\t\t\tif ( eot[s]>=0 ) {  // EOT Transition to accept state?\n\t\t\t\t\t\t\tif ( debug ) System.err.println(\"EOT transition\");\n\t\t\t\t\t\t\ts = eot[s];\n\t\t\t\t\t\t\tinput.consume();\n\t\t\t\t\t\t\t// TODO: I had this as return accept[eot[s]]\n\t\t\t\t\t\t\t// which assumed here that the EOT edge always\n\t\t\t\t\t\t\t// went to an accept...faster to do this, but\n\t\t\t\t\t\t\t// what about predicated edges coming from EOT\n\t\t\t\t\t\t\t// target?\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnoViableAlt(s,input);\n\t\t\t\t\t\treturn 0;\n\t\t\t\t\t}\n\t\t\t\t\ts = snext;\n\t\t\t\t\tinput.consume();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( eot[s]>=0 ) {  // EOT Transition?\n\t\t\t\t\tif ( debug ) System.err.println(\"EOT transition\");\n\t\t\t\t\ts = eot[s];\n\t\t\t\t\tinput.consume();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( c==(char)Token.EOF && eof[s]>=0 ) {  // EOF Transition to accept state?\n\t\t\t\t\tif ( debug ) System.err.println(\"accept via EOF; predict \"+accept[eof[s]]+\" from \"+eof[s]);\n\t\t\t\t\treturn accept[eof[s]];\n\t\t\t\t}\n\t\t\t\t// not in range and not EOF/EOT, must be invalid symbol\n\t\t\t\tif ( debug ) {\n\t\t\t\t\tSystem.err.println(\"min[\"+s+\"]=\"+min[s]);\n\t\t\t\t\tSystem.err.println(\"max[\"+s+\"]=\"+max[s]);\n\t\t\t\t\tSystem.err.println(\"eot[\"+s+\"]=\"+eot[s]);\n\t\t\t\t\tSystem.err.println(\"eof[\"+s+\"]=\"+eof[s]);\n\t\t\t\t\tfor (int p=0; p<transition[s].length; p++) {\n\t\t\t\t\t\tSystem.err.print(transition[s][p]+\" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.err.println();\n\t\t\t\t}\n\t\t\t\tnoViableAlt(s,input);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tfinally {\n\t\t\tinput.rewind(mark);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#BooleanLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#PrimitiveType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CastExpression#StringLiteral#SimpleName#SimpleName#NumberLiteral#MethodInvocation#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#NumberLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#ArrayAccess#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#ArrayAccess#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#ArrayAccess#InfixExpression#SimpleName#SimpleName#SimpleName#ArrayAccess#InfixExpression#InfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#SimpleName#ArrayAccess#InfixExpression#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#ArrayAccess#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#ArrayAccess#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#NumberLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#ArrayAccess#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#PrimitiveType#SimpleName#SimpleName#QualifiedName#CastExpression#InfixExpression#SimpleName#SimpleName#ArrayAccess#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#ArrayAccess#ArrayAccess#StringLiteral#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#ArrayAccess#ArrayAccess#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#FieldAccess#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#ArrayAccess#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#NumberLiteral#ReturnStatement#Block#WhileStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(WhileStatement(BooleanLiteral)BooleanLiteral(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)CastExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ReturnStatement(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression(InfixExpression(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(InfixExpression(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)InfixExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ArrayAccess(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ReturnStatement(ArrayAccess(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ArrayAccess)ReturnStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(FieldAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)FieldAccess)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(ArrayAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)ArrayAccess(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)WhileStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)TryStatement)Block)MethodDeclaration", "methodDoc": "From the input stream, predict what alternative will succeed using this DFA (representing the covering regular approximation to the underlying CFL).  Return an alternative number 1..n.  Throw an exception upon error.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "196", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/DFA.java", "methodName": "org.antlr.runtime.DFA.error", "methodParameterType": "NoViableAltException#", "methodParameterName": "nvae#", "methodBody": "protected void error(NoViableAltException nvae) { ; }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "A hook for debugging interface", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "197", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/DFA.java", "methodName": "org.antlr.runtime.DFA.unpackEncodedString", "methodParameterType": "String#", "methodParameterName": "encodedString#", "methodBody": "public static short[] unpackEncodedString(String encodedString) {\n\t\t// walk first to find how big it is.\n\t\tint size = 0;\n\t\tfor (int i=0; i<encodedString.length(); i+=2) {\n\t\t\tsize += encodedString.charAt(i);\n\t\t}\n\t\tshort[] data = new short[size];\n\t\tint di = 0;\n\t\tfor (int i=0; i<encodedString.length(); i+=2) {\n\t\t\tchar n = encodedString.charAt(i);\n\t\t\tchar v = encodedString.charAt(i+1);\n\t\t\t// add v n times to data\n\t\t\tfor (int j=1; j<=n; j++) {\n\t\t\t\tdata[di++] = (short)v;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#NumberLiteral#Assignment#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#PrimitiveType#Dimension#ArrayType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#NumberLiteral#Assignment#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#PostfixExpression#ArrayAccess#PrimitiveType#SimpleName#CastExpression#Assignment#ExpressionStatement#Block#ForStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ArrayAccess(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)Assignment)ExpressionStatement)Block)ForStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a String that has a run-length-encoding of some unsigned shorts like \"\\1\\2\\3\\9\", convert to short[] {2,9,9,9}.  We do this to avoid static short[] which generates so much init code that the class won't compile. :(", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "198", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/DFA.java", "methodName": "org.antlr.runtime.DFA.unpackEncodedStringToUnsignedChars", "methodParameterType": "String#", "methodParameterName": "encodedString#", "methodBody": "public static char[] unpackEncodedStringToUnsignedChars(String encodedString) {\n\t\t// walk first to find how big it is.\n\t\tint size = 0;\n\t\tfor (int i=0; i<encodedString.length(); i+=2) {\n\t\t\tsize += encodedString.charAt(i);\n\t\t}\n\t\tchar[] data = new char[size];\n\t\tint di = 0;\n\t\tfor (int i=0; i<encodedString.length(); i+=2) {\n\t\t\tchar n = encodedString.charAt(i);\n\t\t\tchar v = encodedString.charAt(i+1);\n\t\t\t// add v n times to data\n\t\t\tfor (int j=1; j<=n; j++) {\n\t\t\t\tdata[di++] = v;\n\t\t\t}\n\t\t}\n\t\treturn data;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#NumberLiteral#Assignment#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#PrimitiveType#Dimension#ArrayType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#NumberLiteral#Assignment#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#PostfixExpression#ArrayAccess#SimpleName#Assignment#ExpressionStatement#Block#ForStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)ForStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Hideous duplication of code, but I need different typed arrays out :(", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "199", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Parser.java", "methodName": "org.antlr.runtime.Parser.setTokenStream", "methodParameterType": "TokenStream#", "methodParameterName": "input#", "methodBody": "public void setTokenStream(TokenStream input) {\n\t\tthis.input = null;\n\t\treset();\n\t\tthis.input = input;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#NullLiteral#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the token stream and reset the parser", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "200", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CharStream.java", "methodName": "org.antlr.runtime.CharStream.substring", "methodParameterType": "int#int#", "methodParameterName": "start#stop#", "methodBody": "public String substring(int start, int stop);", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "For infinite streams, you don't need this; primarily I'm providing a useful interface for action code.  Just make sure actions don't use this on streams that don't support it.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "201", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CharStream.java", "methodName": "org.antlr.runtime.CharStream.LT", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "public int LT(int i);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get the ith character of lookahead.  This is the same usually as LA(i).  This will be used for labels in the generated lexer code.  I'd prefer to return a char here type-wise, but it's probably better to be 32-bit clean and be consistent with LA.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "202", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CharStream.java", "methodName": "org.antlr.runtime.CharStream.getLine", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getLine();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "ANTLR tracks the line information automatically", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "203", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CharStream.java", "methodName": "org.antlr.runtime.CharStream.setLine", "methodParameterType": "int#", "methodParameterName": "line#", "methodBody": "void setLine(int line);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Because this stream can rewind, we need to be able to reset the line", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "204", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CharStream.java", "methodName": "org.antlr.runtime.CharStream.getCharPositionInLine", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int getCharPositionInLine();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "The index of the character relative to the beginning of the line 0..n-1", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "205", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.LA", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "int LA(int i);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Get int at current input pointer + i ahead where i=1 is next int. Negative indexes are allowed.  LA(-1) is previous token (token just matched).  LA(-i) where i is before first token should yield -1, invalid char / EOF.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "206", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.mark", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int mark();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Tell the stream to start buffering if it hasn't already.  Return current input position, index(), or some other marker so that when passed to rewind() you get back to the same spot. rewind(mark()) should not affect the input cursor.  The Lexer track line/col info as well as input index so its markers are not pure input indexes.  Same for tree node streams.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "207", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.index", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int index();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return the current input symbol index 0..n where n indicates the last symbol has been read.  The index is the symbol about to be read not the most recently read symbol.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "208", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.rewind", "methodParameterType": "int#", "methodParameterName": "marker#", "methodBody": "void rewind(int marker);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Reset the stream so that next call to index would return marker. The marker will usually be index() but it doesn't have to be.  It's just a marker to indicate what state the stream was in.  This is essentially calling release() and seek().  If there are markers created after this marker argument, this routine must unroll them like a stack.  Assume the state the stream was in when this marker was created.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "209", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.rewind", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "void rewind();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Rewind to the input position of the last marker. Used currently only after a cyclic DFA and just before starting a sem/syn predicate to get the input position back to the start of the decision. Do not \"pop\" the marker off the state.  mark(i) and rewind(i) should balance still. It is like invoking rewind(last marker) but it should not \"pop\" the marker off.  It's like seek(last marker's input position).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "210", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.release", "methodParameterType": "int#", "methodParameterName": "marker#", "methodBody": "void release(int marker);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "You may want to commit to a backtrack but don't want to force the stream to keep bookkeeping objects around for a marker that is no longer necessary.  This will have the same behavior as rewind() except it releases resources without the backward seek. This must throw away resources for all markers back to the marker argument.  So if you're nested 5 levels of mark(), and then release(2) you have to release resources for depths 2..5.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "211", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.seek", "methodParameterType": "int#", "methodParameterName": "index#", "methodBody": "void seek(int index);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Set the input cursor to the position indicated by index.  This is normally used to seek ahead in the input stream.  No buffering is required to do this unless you know your stream will use seek to move backwards such as when backtracking. This is different from rewind in its multi-directional requirement and in that its argument is strictly an input cursor (index). For char streams, seeking forward must update the stream state such as line number.  For seeking backwards, you will be presumably backtracking using the mark/rewind mechanism that restores state and so this method does not need to update state when seeking backwards. Currently, this method is only used for efficient backtracking using memoization, but in the future it may be used for incremental parsing. The index is 0..n-1.  A seek to position i means that LA(1) will return the ith symbol.  So, seeking to 0 means LA(1) will return the first element in the stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "212", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.size", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int size();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Only makes sense for streams that buffer everything up probably, but might be useful to display the entire stream or for testing.  This value includes a single EOF.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "213", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/IntStream.java", "methodName": "org.antlr.runtime.IntStream.getSourceName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getSourceName();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Where are you getting symbols from?  Normally, implementations will pass the buck all the way to the lexer who can ask its input stream for the file name or whatever.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "214", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/FailedPredicateException.java", "methodName": "org.antlr.runtime.FailedPredicateException.FailedPredicateException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public FailedPredicateException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "215", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenSource.java", "methodName": "org.antlr.runtime.TokenSource.nextToken", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Token nextToken();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return a Token object from your input stream (usually a CharStream). Do not fail/return upon lexing error; keep chewing on the characters until you get a good one; errors are not passed through to the parser.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "216", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenSource.java", "methodName": "org.antlr.runtime.TokenSource.getSourceName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getSourceName();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Where are you getting tokens from? normally the implication will simply ask lexers input stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "217", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/MismatchedNotSetException.java", "methodName": "org.antlr.runtime.MismatchedNotSetException.MismatchedNotSetException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public MismatchedNotSetException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "218", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java", "methodName": "org.antlr.runtime.TokenRewriteStream.rollback", "methodParameterType": "String#int#", "methodParameterName": "programName#instructionIndex#", "methodBody": "public void rollback(String programName, int instructionIndex) {\n\t\tList<RewriteOperation> is = programs.get(programName);\n\t\tif ( is!=null ) {\n\t\t\tprograms.put(programName, is.subList(MIN_TOKEN_INDEX,instructionIndex));\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Rollback the instruction stream for a program so that the indicated instruction (via instructionIndex) is no longer in the stream.  UNTESTED!", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "219", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java", "methodName": "org.antlr.runtime.TokenRewriteStream.deleteProgram", "methodParameterType": "String#", "methodParameterName": "programName#", "methodBody": "public void deleteProgram(String programName) {\n\t\trollback(programName, MIN_TOKEN_INDEX);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset the program so that no instructions exist", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "220", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java", "methodName": "org.antlr.runtime.TokenRewriteStream.reduceToSingleOperationPerIndex", "methodParameterType": "List<? extends RewriteOperation>#", "methodParameterName": "rewrites#", "methodBody": "protected Map<Integer, ? extends RewriteOperation> reduceToSingleOperationPerIndex(List<? extends RewriteOperation> rewrites) {\n//\t\tSystem.out.println(\"rewrites=\"+rewrites);\n\n\t\t// WALK REPLACES\n\t\tfor (int i = 0; i < rewrites.size(); i++) {\n\t\t\tRewriteOperation op = rewrites.get(i);\n\t\t\tif ( op==null ) continue;\n\t\t\tif ( !(op instanceof ReplaceOp) ) continue;\n\t\t\tReplaceOp rop = (ReplaceOp)rewrites.get(i);\n\t\t\t// Wipe prior inserts within range\n\t\t\tList<? extends InsertBeforeOp> inserts = getKindOfOps(rewrites, InsertBeforeOp.class, i);\n\t\t\tfor (int j = 0; j < inserts.size(); j++) {\n\t\t\t\tInsertBeforeOp iop = inserts.get(j);\n\t\t\t\tif ( iop.index == rop.index ) {\n\t\t\t\t\t// E.g., insert before 2, delete 2..2; update replace\n\t\t\t\t\t// text to include insert before, kill insert\n\t\t\t\t\trewrites.set(iop.instructionIndex, null);\n\t\t\t\t\trop.text = iop.text.toString() + (rop.text!=null?rop.text.toString():\"\");\n\t\t\t\t}\n\t\t\t\telse if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {\n                    // delete insert as it's a no-op.\n                    rewrites.set(iop.instructionIndex, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Drop any prior replaces contained within\n\t\t\tList<? extends ReplaceOp> prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);\n\t\t\tfor (int j = 0; j < prevReplaces.size(); j++) {\n\t\t\t\tReplaceOp prevRop = prevReplaces.get(j);\n\t\t\t\tif ( prevRop.index>=rop.index && prevRop.lastIndex <= rop.lastIndex ) {\n                    // delete replace as it's a no-op.\n                    rewrites.set(prevRop.instructionIndex, null);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// throw exception unless disjoint or identical\n\t\t\t\tboolean disjoint =\n\t\t\t\t\tprevRop.lastIndex<rop.index || prevRop.index > rop.lastIndex;\n\t\t\t\tboolean same =\n\t\t\t\t\tprevRop.index==rop.index && prevRop.lastIndex==rop.lastIndex;\n\t\t\t\t// Delete special case of replace (text==null):\n\t\t\t\t// D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right)\n\t\t\t\tif ( prevRop.text==null && rop.text==null && !disjoint ) {\n\t\t\t\t\t//System.out.println(\"overlapping deletes: \"+prevRop+\", \"+rop);\n\t\t\t\t\trewrites.set(prevRop.instructionIndex, null); // kill first delete\n\t\t\t\t\trop.index = Math.min(prevRop.index, rop.index);\n\t\t\t\t\trop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);\n\t\t\t\t\tSystem.out.println(\"new rop \"+rop);\n\t\t\t\t}\n\t\t\t\telse if ( !disjoint && !same ) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"replace op boundaries of \"+rop+\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \" overlap with previous \"+prevRop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// WALK INSERTS\n\t\tfor (int i = 0; i < rewrites.size(); i++) {\n\t\t\tRewriteOperation op = rewrites.get(i);\n\t\t\tif ( op==null ) continue;\n\t\t\tif ( !(op instanceof InsertBeforeOp) ) continue;\n\t\t\tInsertBeforeOp iop = (InsertBeforeOp)rewrites.get(i);\n\t\t\t// combine current insert with prior if any at same index\n\t\t\tList<? extends InsertBeforeOp> prevInserts = getKindOfOps(rewrites, InsertBeforeOp.class, i);\n\t\t\tfor (int j = 0; j < prevInserts.size(); j++) {\n\t\t\t\tInsertBeforeOp prevIop = prevInserts.get(j);\n\t\t\t\tif ( prevIop.index == iop.index ) { // combine objects\n\t\t\t\t\t// convert to strings...we're in process of toString'ing\n\t\t\t\t\t// whole token buffer so no lazy eval issue with any templates\n\t\t\t\t\tiop.text = catOpText(iop.text,prevIop.text);\n                    // delete redundant prior insert\n                    rewrites.set(prevIop.instructionIndex, null);\n\t\t\t\t}\n\t\t\t}\n\t\t\t// look for replaces where iop.index is in range; error\n\t\t\tList<? extends ReplaceOp> prevReplaces = getKindOfOps(rewrites, ReplaceOp.class, i);\n\t\t\tfor (int j = 0; j < prevReplaces.size(); j++) {\n\t\t\t\tReplaceOp rop = prevReplaces.get(j);\n\t\t\t\tif ( iop.index == rop.index ) {\n\t\t\t\t\trop.text = catOpText(iop.text,rop.text);\n\t\t\t\t\trewrites.set(i, null);  // delete current insert\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {\n\t\t\t\t\tthrow new IllegalArgumentException(\"insert op \"+iop+\n\t\t\t\t\t\t\t\t\t\t\t\t\t   \" within boundaries of previous \"+rop);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// System.out.println(\"rewrites after=\"+rewrites);\n\t\tMap<Integer, RewriteOperation> m = new HashMap<Integer, RewriteOperation>();\n\t\tfor (int i = 0; i < rewrites.size(); i++) {\n\t\t\tRewriteOperation op = rewrites.get(i);\n\t\t\tif ( op==null ) continue; // ignore deleted ops\n\t\t\tif ( m.get(op.index)!=null ) {\n\t\t\t\tthrow new Error(\"should only be one op per index\");\n\t\t\t}\n\t\t\tm.put(op.index, op);\n\t\t}\n\t\t//System.out.println(\"index to op: \"+m);\n\t\treturn m;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#ContinueStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#StringLiteral#ConditionalExpression#ParenthesizedExpression#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#PrefixExpression#SimpleName#PrefixExpression#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#IfStatement#Block#ForStatement#Block#ForStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#ContinueStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Block#ForStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(ContinueStatement)ContinueStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(ParenthesizedExpression(ConditionalExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)ConditionalExpression)ParenthesizedExpression)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement)IfStatement)Block)ForStatement)Block)ForStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(ContinueStatement)ContinueStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement)Block)ForStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "We need to combine operations and report invalid operations (like overlapping replaces that are not completed nested).  Inserts to same index need to be combined etc...   Here are the cases: I.i.u I.j.v\t\t\t\t\t\t\t\tleave alone, nonoverlapping I.i.u I.i.v\t\t\t\t\t\t\t\tcombine: Iivu R.i-j.u R.x-y.v\t| i-j in x-y\t\t\tdelete first R R.i-j.u R.i-j.v\t\t\t\t\t\t\tdelete first R R.i-j.u R.x-y.v\t| x-y in i-j\t\t\tERROR R.i-j.u R.x-y.v\t| boundaries overlap\tERROR Delete special case of replace (text==null): D.i-j.u D.x-y.v\t| boundaries overlap\tcombine to max(min)..max(right) I.i.u R.x-y.v | i in (x+1)-y\t\t\tdelete I (since insert before we're not deleting i) I.i.u R.x-y.v | i not in (x+1)-y\t\tleave alone, nonoverlapping R.x-y.v I.i.u | i in x-y\t\t\t\tERROR R.x-y.v I.x.u \t\t\t\t\t\t\tR.x-y.uv (combine, delete I) R.x-y.v I.i.u | i not in x-y\t\t\tleave alone, nonoverlapping I.i.u = insert u before op @ index i R.x-y.u = replace x-y indexed tokens with u First we need to examine replaces.  For any replace op: 1. wipe out any insertions before op within that range. 2. Drop any replace op before that is contained completely within that range. 3. Throw exception upon boundary overlap with any previous replace. Then we can deal with inserts: 1. for any inserts to same index, combine even if not adjacent. 2. for any prior replace with same left boundary, combine this insert with replace and delete this replace. 3. throw exception if index in same range as previous replace Don't actually delete; make op null in list. Easier to walk list. Later we can throw as we add to index &rarr; op map. Note that I.2 R.2-2 will wipe out I.2 even though, technically, the inserted stuff would be before the replace range.  But, if you add tokens in front of a method body '{' and then delete the method body, I think the stuff before the '{' you added should disappear too. Return a map from token index to operation.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "221", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/TokenRewriteStream.java", "methodName": "org.antlr.runtime.TokenRewriteStream.getKindOfOps", "methodParameterType": "List<? extends RewriteOperation>#Class<T>#int#", "methodParameterName": "rewrites#kind#before#", "methodBody": "protected <T extends RewriteOperation> List<? extends T> getKindOfOps(List<? extends RewriteOperation> rewrites, Class<T> kind, int before) {\n\t\tList<T> ops = new ArrayList<T>();\n\t\tfor (int i=0; i<before && i<rewrites.size(); i++) {\n\t\t\tRewriteOperation op = rewrites.get(i);\n\t\t\tif ( op==null ) continue; // ignore deleted\n\t\t\tif ( kind.isInstance(op) ) ops.add(kind.cast(op));\n\t\t}\t\t\n\t\treturn ops;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#TypeParameter#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(TypeParameter(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)TypeParameter(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get all operations before an index of a particular kind", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "222", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RecognitionException.java", "methodName": "org.antlr.runtime.RecognitionException.RecognitionException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public RecognitionException() {\n\t}", "AST": "Javadoc#Modifier#SimpleName#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "223", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RecognitionException.java", "methodName": "org.antlr.runtime.RecognitionException.getUnexpectedType", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getUnexpectedType() {\n\t\tif ( input instanceof TokenStream ) {\n\t\t\treturn token.getType();\n\t\t}\n\t\telse if ( input instanceof TreeNodeStream ) {\n\t\t\tTreeNodeStream nodes = (TreeNodeStream)input;\n\t\t\tTreeAdaptor adaptor = nodes.getTreeAdaptor();\n\t\t\treturn adaptor.getType(node);\n\t\t}\n\t\telse {\n\t\t\treturn c;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#SimpleName#ReturnStatement#Block#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Return the token type or char of the unexpected input element", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "224", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/EarlyExitException.java", "methodName": "org.antlr.runtime.EarlyExitException.EarlyExitException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public EarlyExitException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "225", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.reset", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void reset() {\n\t\t// wack everything related to error recovery\n\t\tif ( state==null ) {\n\t\t\treturn; // no shared state work to do\n\t\t}\n\t\tstate._fsp = -1;\n\t\tstate.errorRecovery = false;\n\t\tstate.lastErrorIndex = -1;\n\t\tstate.failed = false;\n\t\tstate.syntaxErrors = 0;\n\t\t// wack everything related to backtracking and memoization\n\t\tstate.backtracking = 0;\n\t\tfor (int i = 0; state.ruleMemo!=null && i < state.ruleMemo.length; i++) { // wipe cache\n\t\t\tstate.ruleMemo[i] = null;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#PrefixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#PrefixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#NullLiteral#Assignment#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "reset the parser's state; subclasses must rewinds the input stream", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "226", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.match", "methodParameterType": "IntStream#int#BitSet#", "methodParameterName": "input#ttype#follow#", "methodBody": "public Object match(IntStream input, int ttype, BitSet follow)\n\t\tthrows RecognitionException\n\t{\n\t\t//System.out.println(\"match \"+((TokenStream)input).LT(1));\n\t\tObject matchedSymbol = getCurrentInputSymbol(input);\n\t\tif ( input.LA(1)==ttype ) {\n\t\t\tinput.consume();\n\t\t\tstate.errorRecovery = false;\n\t\t\tstate.failed = false;\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\tif ( state.backtracking>0 ) {\n\t\t\tstate.failed = true;\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\tmatchedSymbol = recoverFromMismatchedToken(input, ttype, follow);\n\t\treturn matchedSymbol;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Match current input symbol against ttype.  Attempt single token insertion or deletion error recovery.  If that fails, throw MismatchedTokenException. To turn off single token insertion or deletion error recovery, override recoverFromMismatchedToken() and have it throw an exception. See TreeParser.recoverFromMismatchedToken(). This way any error in a rule will cause an exception and immediate exit from rule.  Rule would recover by resynchronizing to the set of symbols that can follow rule ref.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "227", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.matchAny", "methodParameterType": "IntStream#", "methodParameterName": "input#", "methodBody": "public void matchAny(IntStream input) {\n\t\tstate.errorRecovery = false;\n\t\tstate.failed = false;\n\t\tinput.consume();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Match the wildcard: in a symbol", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "228", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.reportError", "methodParameterType": "RecognitionException#", "methodParameterName": "e#", "methodBody": "public void reportError(RecognitionException e) {\n\t\t// if we've already reported an error and have not matched a token\n\t\t// yet successfully, don't report any errors.\n\t\tif ( state.errorRecovery ) {\n\t\t\t//System.err.print(\"[SPURIOUS] \");\n\t\t\treturn;\n\t\t}\n\t\tstate.syntaxErrors++; // don't count spurious\n\t\tstate.errorRecovery = true;\n\n\t\tdisplayRecognitionError(this.getTokenNames(), e);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#ThisExpression#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Report a recognition problem. This method sets errorRecovery to indicate the parser is recovering not parsing.  Once in recovery mode, no errors are generated. To get out of recovery mode, the parser must successfully match a token (after a resync).  So it will go: 1. error occurs 2. enter recovery mode, report error 3. consume until token found in resynch set 4. try to resume parsing 5. next match() will reset errorRecovery mode If you override, make sure to update syntaxErrors if you care about that.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "229", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getErrorMessage", "methodParameterType": "RecognitionException#String[]#", "methodParameterName": "e#tokenNames#", "methodBody": "public String getErrorMessage(RecognitionException e, String[] tokenNames) {\n\t\tString msg = e.getMessage();\n\t\tif ( e instanceof UnwantedTokenException ) {\n\t\t\tUnwantedTokenException ute = (UnwantedTokenException)e;\n\t\t\tString tokenName;\n\t\t\tif ( ute.expecting== Token.EOF ) {\n\t\t\t\ttokenName = \"EOF\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttokenName = tokenNames[ute.expecting];\n\t\t\t}\n\t\t\tmsg = \"extraneous input \"+getTokenErrorDisplay(ute.getUnexpectedToken())+\n\t\t\t\t\" expecting \"+tokenName;\n\t\t}\n\t\telse if ( e instanceof MissingTokenException ) {\n\t\t\tMissingTokenException mte = (MissingTokenException)e;\n\t\t\tString tokenName;\n\t\t\tif ( mte.expecting== Token.EOF ) {\n\t\t\t\ttokenName = \"EOF\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttokenName = tokenNames[mte.expecting];\n\t\t\t}\n\t\t\tmsg = \"missing \"+tokenName+\" at \"+getTokenErrorDisplay(e.token);\n\t\t}\n\t\telse if ( e instanceof MismatchedTokenException ) {\n\t\t\tMismatchedTokenException mte = (MismatchedTokenException)e;\n\t\t\tString tokenName;\n\t\t\tif ( mte.expecting== Token.EOF ) {\n\t\t\t\ttokenName = \"EOF\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttokenName = tokenNames[mte.expecting];\n\t\t\t}\n\t\t\tmsg = \"mismatched input \"+getTokenErrorDisplay(e.token)+\n\t\t\t\t\" expecting \"+tokenName;\n\t\t}\n\t\telse if ( e instanceof MismatchedTreeNodeException ) {\n\t\t\tMismatchedTreeNodeException mtne = (MismatchedTreeNodeException)e;\n\t\t\tString tokenName;\n\t\t\tif ( mtne.expecting==Token.EOF ) {\n\t\t\t\ttokenName = \"EOF\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttokenName = tokenNames[mtne.expecting];\n\t\t\t}\n\t\t\tmsg = \"mismatched tree node: \"+mtne.node+\n\t\t\t\t\" expecting \"+tokenName;\n\t\t}\n\t\telse if ( e instanceof NoViableAltException ) {\n\t\t\t//NoViableAltException nvae = (NoViableAltException)e;\n\t\t\t// for development, can add \"decision=<<\"+nvae.grammarDecisionDescription+\">>\"\n\t\t\t// and \"(decision=\"+nvae.decisionNumber+\") and\n\t\t\t// \"state \"+nvae.stateNumber\n\t\t\tmsg = \"no viable alternative at input \"+getTokenErrorDisplay(e.token);\n\t\t}\n\t\telse if ( e instanceof EarlyExitException ) {\n\t\t\t//EarlyExitException eee = (EarlyExitException)e;\n\t\t\t// for development, can add \"(decision=\"+eee.decisionNumber+\")\"\n\t\t\tmsg = \"required (...)+ loop did not match anything at input \"+\n\t\t\t\tgetTokenErrorDisplay(e.token);\n\t\t}\n\t\telse if ( e instanceof MismatchedSetException ) {\n\t\t\tMismatchedSetException mse = (MismatchedSetException)e;\n\t\t\tmsg = \"mismatched input \"+getTokenErrorDisplay(e.token)+\n\t\t\t\t\" expecting set \"+mse.expecting;\n\t\t}\n\t\telse if ( e instanceof MismatchedNotSetException ) {\n\t\t\tMismatchedNotSetException mse = (MismatchedNotSetException)e;\n\t\t\tmsg = \"mismatched input \"+getTokenErrorDisplay(e.token)+\n\t\t\t\t\" expecting set \"+mse.expecting;\n\t\t}\n\t\telse if ( e instanceof FailedPredicateException ) {\n\t\t\tFailedPredicateException fpe = (FailedPredicateException)e;\n\t\t\tmsg = \"rule \"+fpe.ruleName+\" failed predicate: {\"+\n\t\t\t\tfpe.predicateText+\"}?\";\n\t\t}\n\t\treturn msg;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ArrayAccess#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#StringLiteral#SimpleName#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ArrayAccess#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ArrayAccess#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#StringLiteral#SimpleName#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ArrayAccess#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What error message should be generated for the various exception types? Not very object-oriented code, but I like having all error message generation within one method rather than spread among all of the exception classes. This also makes it much easier for the exception handling because the exception classes do not have to have pointers back to this object to access utility routines and so on. Also, changing the message for an exception type would be difficult because you would have to subclassing exception, but then somehow get ANTLR to make those kinds of exception objects instead of the default. This looks weird, but trust me--it makes the most sense in terms of flexibility. For grammar debugging, you will want to override this to add more information such as the stack frame with getRuleInvocationStack(e, this.getClass().getName()) and, for no viable alts, the decision description and state etc... Override this to change the message generated for one or more exception types.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "230", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getNumberOfSyntaxErrors", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getNumberOfSyntaxErrors() {\n\t\treturn state.syntaxErrors;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get number of recognition errors (lexer, parser, tree parser).  Each recognizer tracks its own number.  So parser and lexer each have separate count.  Does not count the spurious errors found between an error and next valid token match See also reportError()", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "231", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getErrorHeader", "methodParameterType": "RecognitionException#", "methodParameterName": "e#", "methodBody": "public String getErrorHeader(RecognitionException e) {\n\t\tif ( getSourceName()!=null )\n\t\t\treturn getSourceName()+\" line \"+e.line+\":\"+e.charPositionInLine;\n\t\t\t\t\n\t\treturn \"line \"+e.line+\":\"+e.charPositionInLine;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#MethodInvocation#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#IfStatement#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)IfStatement(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the error header, normally line/character position information?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "232", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getTokenErrorDisplay", "methodParameterType": "Token#", "methodParameterName": "t#", "methodBody": "public String getTokenErrorDisplay(Token t) {\n\t\tString s = t.getText();\n\t\tif ( s==null ) {\n\t\t\tif ( t.getType()==Token.EOF ) {\n\t\t\t\ts = \"<EOF>\";\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts = \"<\"+t.getType()+\">\";\n\t\t\t}\n\t\t}\n\t\ts = s.replaceAll(\"\\n\",\"\\\\\\\\n\");\n\t\ts = s.replaceAll(\"\\r\",\"\\\\\\\\r\");\n\t\ts = s.replaceAll(\"\\t\",\"\\\\\\\\t\");\n\t\treturn \"'\"+s+\"'\";\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#StringLiteral#SimpleName#StringLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "How should a token be displayed in an error message? The default is to display just the text, but during development you might want to have a lot of information spit out.  Override in that case to use t.toString() (which, for CommonToken, dumps everything about the token). This is better than forcing you to override a method in your token objects because you don't have to go modify your lexer so that it creates a new Java type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "233", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.emitErrorMessage", "methodParameterType": "String#", "methodParameterName": "msg#", "methodBody": "public void emitErrorMessage(String msg) {\n\t\tSystem.err.println(msg);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Override this method to change where error messages go", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "234", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.recover", "methodParameterType": "IntStream#RecognitionException#", "methodParameterName": "input#re#", "methodBody": "public void recover(IntStream input, RecognitionException re) {\n\t\tif ( state.lastErrorIndex==input.index() ) {\n\t\t\t// uh oh, another error at same token index; must be a case\n\t\t\t// where LT(1) is in the recovery token set so nothing is\n\t\t\t// consumed; consume a single token so at least to prevent\n\t\t\t// an infinite loop; this is a failsafe.\n\t\t\tinput.consume();\n\t\t}\n\t\tstate.lastErrorIndex = input.index();\n\t\tBitSet followSet = computeErrorRecoverySet();\n\t\tbeginResync();\n\t\tconsumeUntil(input, followSet);\n\t\tendResync();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Recover from an error found on the input stream.  This is for NoViableAlt and mismatched symbol exceptions.  If you enable single token insertion and deletion, this will usually not handle mismatched symbol exceptions but there could be a mismatched token that the match() routine could not recover from.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "235", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.beginResync", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void beginResync() {\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block)Block)MethodDeclaration", "methodDoc": "A hook to listen in on the token consumption during error recovery. The DebugParser subclasses this to fire events to the listenter.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "236", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.computeContextSensitiveRuleFOLLOW", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected BitSet computeContextSensitiveRuleFOLLOW() {\n\t\treturn combineFollows(true);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute the context-sensitive FOLLOW set for current rule. This is set of token types that can follow a specific rule reference given a specific call chain.  You get the set of viable tokens that can possibly come next (lookahead depth 1) given the current call chain.  Contrast this with the definition of plain FOLLOW for rule r: FOLLOW(r)={x | S=&gt;", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "237", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.recoverFromMismatchedToken", "methodParameterType": "IntStream#int#BitSet#", "methodParameterName": "input#ttype#follow#", "methodBody": "protected Object recoverFromMismatchedToken(IntStream input, int ttype, BitSet follow)\n\t\tthrows RecognitionException\n\t{\n\t\tRecognitionException e = null;\n\t\t// if next token is what we are looking for then \"delete\" this token\n\t\tif ( mismatchIsUnwantedToken(input, ttype) ) {\n\t\t\te = new UnwantedTokenException(ttype, input);\n\t\t\t/*\n\t\t\tSystem.err.println(\"recoverFromMismatchedToken deleting \"+\n\t\t\t\t\t\t\t   ((TokenStream)input).LT(1)+\n\t\t\t\t\t\t\t   \" since \"+((TokenStream)input).LT(2)+\" is what we want\");\n\t\t\t */\n\t\t\tbeginResync();\n\t\t\tinput.consume(); // simply delete extra token\n\t\t\tendResync();\n\t\t\treportError(e);  // report after consuming so AW sees the token in the exception\n\t\t\t// we want to return the token we're actually matching\n\t\t\tObject matchedSymbol = getCurrentInputSymbol(input);\n\t\t\tinput.consume(); // move past ttype token as if all were ok\n\t\t\treturn matchedSymbol;\n\t\t}\n\t\t// can't recover with single token deletion, try insertion\n\t\tif ( mismatchIsMissingToken(input, follow) ) {\n\t\t\tObject inserted = getMissingSymbol(input, e, ttype, follow);\n\t\t\te = new MissingTokenException(ttype, input, inserted);\n\t\t\treportError(e);  // report after inserting so AW sees the token in the exception\n\t\t\treturn inserted;\n\t\t}\n\t\t// even that didn't work; must throw the exception\n\t\te = new MismatchedTokenException(ttype, input);\n\t\tthrow e;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#ThrowStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block)MethodDeclaration", "methodDoc": "Attempt to recover from a single missing or extra token. EXTRA TOKEN LA(1) is not what we are looking for.  If LA(2) has the right token, however, then assume LA(1) is some extra spurious token.  Delete it and LA(2) as if we were doing a normal match(), which advances the input. MISSING TOKEN If current token is consistent with what could come after ttype then it is ok to \"insert\" the missing token, else throw exception For example, Input \"i=(3;\" is clearly missing the ')'.  When the parser returns from the nested call to expr, it will have call chain: stat &rarr; expr &rarr; atom and it will be trying to match the ')' at this point in the derivation: =&gt; ID '=' '(' INT ')' ('+' atom)", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "238", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.recoverFromMismatchedSet", "methodParameterType": "IntStream#RecognitionException#BitSet#", "methodParameterName": "input#e#follow#", "methodBody": "public Object recoverFromMismatchedSet(IntStream input,\n\t\t\t\t\t\t\t\t\t\t   RecognitionException e,\n\t\t\t\t\t\t\t\t\t\t   BitSet follow)\n\t\tthrows RecognitionException\n\t{\n\t\tif ( mismatchIsMissingToken(input, follow) ) {\n\t\t\t// System.out.println(\"missing token\");\n\t\t\treportError(e);\n\t\t\t// we don't know how to conjure up a token for sets yet\n\t\t\treturn getMissingSymbol(input, e, Token.INVALID_TOKEN_TYPE, follow);\n\t\t}\n\t\t// TODO do single token deletion like above for Token mismatch\n\t\tthrow e;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ThrowStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block)MethodDeclaration", "methodDoc": "Not currently used", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "239", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getCurrentInputSymbol", "methodParameterType": "IntStream#", "methodParameterName": "input#", "methodBody": "protected Object getCurrentInputSymbol(IntStream input) { return null; }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Match needs to return the current input symbol, which gets put into the label for the associated token ref; e.g., x=ID.  Token and tree parsers need to return different objects. Rather than test for input stream type or change the IntStream interface, I use a simple method to ask the recognizer to tell me what the current input symbol is. This is ignored for lexers.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "240", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getMissingSymbol", "methodParameterType": "IntStream#RecognitionException#int#BitSet#", "methodParameterName": "input#e#expectedTokenType#follow#", "methodBody": "protected Object getMissingSymbol(IntStream input,\n\t\t\t\t\t\t\t\t\t  RecognitionException e,\n\t\t\t\t\t\t\t\t\t  int expectedTokenType,\n\t\t\t\t\t\t\t\t\t  BitSet follow)\n\t{\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Conjure up a missing token during error recovery. The recognizer attempts to recover from single missing symbols. But, actions might refer to that missing symbol. For example, x=ID {f($x);}. The action clearly assumes that there has been an identifier matched previously and that $x points at that token. If that token is missing, but the next token in the stream is what we want we assume that this token is missing and we keep going. Because we have to return some token to replace the missing token, we have to conjure one up. This method gives the user control over the tokens returned for missing tokens. Mostly, you will want to create something special for identifier tokens. For literals such as '{' and ',', the default action in the parser or tree parser works. It simply creates a CommonToken of the appropriate type. The text will be the token. If you change what tokens must be created by the lexer, override this method to create the appropriate tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "241", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.consumeUntil", "methodParameterType": "IntStream#BitSet#", "methodParameterName": "input#set#", "methodBody": "public void consumeUntil(IntStream input, BitSet set) {\n\t\t//System.out.println(\"consumeUntil(\"+set.toString(getTokenNames())+\")\");\n\t\tint ttype = input.LA(1);\n\t\twhile (ttype != Token.EOF && !set.member(ttype) ) {\n\t\t\t//System.out.println(\"consume during recover LA(1)=\"+getTokenNames()[input.LA(1)]);\n\t\t\tinput.consume();\n\t\t\tttype = input.LA(1);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "Consume tokens until one matches the given token set", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "242", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.pushFollow", "methodParameterType": "BitSet#", "methodParameterName": "fset#", "methodBody": "protected void pushFollow(BitSet fset) {\n\t\tif ( (state._fsp +1)>=state.following.length ) {\n\t\t\tBitSet[] f = new BitSet[state.following.length*2];\n\t\t\tSystem.arraycopy(state.following, 0, f, 0, state.following.length);\n\t\t\tstate.following = f;\n\t\t}\n\t\tstate.following[++state._fsp] = fset;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#PrefixExpression#ArrayAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Push a rule's follow set using our own hardcoded stack", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "243", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getRuleInvocationStack", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<String> getRuleInvocationStack() {\n\t\tString parserClassName = getClass().getName();\n\t\treturn getRuleInvocationStack(new Throwable(), parserClassName);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return List&lt;String&gt; of the rules in your parser instance leading up to a call to this method.  You could override if you want more details such as the file/line info of where in the parser java code a rule is invoked. This is very useful for error messages and for context-sensitive error recovery.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "244", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getRuleInvocationStack", "methodParameterType": "Throwable#String#", "methodParameterName": "e#recognizerClassName#", "methodBody": "public static List<String> getRuleInvocationStack(Throwable e,\n\t\t\t\t\t\t\t\t\t\t\t  String recognizerClassName)\n\t{\n\t\tList<String> rules = new ArrayList<String>();\n\t\tStackTraceElement[] stack = e.getStackTrace();\n\t\tint i;\n\t\tfor (i=stack.length-1; i>=0; i--) {\n\t\t\tStackTraceElement t = stack[i];\n\t\t\tif ( t.getClassName().startsWith(\"org.antlr.runtime.\") ) {\n\t\t\t\tcontinue; // skip support code such as this method\n\t\t\t}\n\t\t\tif ( t.getMethodName().equals(NEXT_TOKEN_RULE_NAME) ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( !t.getClassName().equals(recognizerClassName) ) {\n\t\t\t\tcontinue; // must not be part of this parser\n\t\t\t}\n            rules.add(t.getMethodName());\n\t\t}\n\t\treturn rules;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#Assignment#SimpleName#NumberLiteral#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#PrefixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(Assignment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)Assignment(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A more general version of getRuleInvocationStack where you can pass in, for example, a RecognitionException to get it's rule stack trace.  This routine is shared with all recognizers, hence, static. TODO: move to a utility class or something; weird having lexer call this", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "245", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.failed", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean failed() { return state.failed; }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return whether or not a backtracking attempt failed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "246", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getTokenNames", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String[] getTokenNames() {\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Used to print out token names like ID during debugging and error reporting.  The generated parsers implement a method that overrides this to point to their String[] tokenNames.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "247", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getGrammarFileName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getGrammarFileName() {\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For debugging and other purposes, might want the grammar name. Have ANTLR generate an implementation for this method.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "248", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.toStrings", "methodParameterType": "List<? extends Token>#", "methodParameterName": "tokens#", "methodBody": "public List<String> toStrings(List<? extends Token> tokens) {\n\t\tif ( tokens==null ) return null;\n\t\tList<String> strings = new ArrayList<String>(tokens.size());\n\t\tfor (int i=0; i<tokens.size(); i++) {\n\t\t\tstrings.add(tokens.get(i).getText());\n\t\t}\n\t\treturn strings;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A convenience method for use most often with template rewrites. Convert a List&lt;Token&gt; to List&lt;String&gt;", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "249", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getRuleMemoization", "methodParameterType": "int#int#", "methodParameterName": "ruleIndex#ruleStartIndex#", "methodBody": "public int getRuleMemoization(int ruleIndex, int ruleStartIndex) {\n\t\tif ( state.ruleMemo[ruleIndex]==null ) {\n\t\t\tstate.ruleMemo[ruleIndex] = new HashMap<Integer, Integer>();\n\t\t}\n\t\tInteger stopIndexI =\n\t\t\tstate.ruleMemo[ruleIndex].get(ruleStartIndex);\n\t\tif ( stopIndexI==null ) {\n\t\t\treturn MEMO_RULE_UNKNOWN;\n\t\t}\n\t\treturn stopIndexI;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a rule number and a start token index number, return MEMO_RULE_UNKNOWN if the rule has not parsed input starting from start index.  If this rule has parsed input starting from the start index before, then return where the rule stopped parsing. It returns the index of the last token matched by the rule. For now we use a hashtable and just the slow Object-based one. Later, we can make a special one for ints and also one that tosses out data after we commit past input position i.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "250", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.alreadyParsedRule", "methodParameterType": "IntStream#int#", "methodParameterName": "input#ruleIndex#", "methodBody": "public boolean alreadyParsedRule(IntStream input, int ruleIndex) {\n\t\tint stopIndex = getRuleMemoization(ruleIndex, input.index());\n\t\tif ( stopIndex==MEMO_RULE_UNKNOWN ) {\n\t\t\treturn false;\n\t\t}\n\t\tif ( stopIndex==MEMO_RULE_FAILED ) {\n\t\t\t//System.out.println(\"rule \"+ruleIndex+\" will never succeed\");\n\t\t\tstate.failed=true;\n\t\t}\n\t\telse {\n\t\t\t//System.out.println(\"seen rule \"+ruleIndex+\" before; skipping ahead to @\"+(stopIndex+1)+\" failed=\"+state.failed);\n\t\t\tinput.seek(stopIndex+1); // jump to one past stop token\n\t\t}\n\t\treturn true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Has this rule already parsed input at the current index in the input stream?  Return the stop token index or MEMO_RULE_UNKNOWN. If we attempted but failed to parse properly before, return MEMO_RULE_FAILED. This method has a side-effect: if we have seen this input for this rule and successfully parsed before, then seek ahead to 1 past the stop token matched for this rule last time.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "251", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.memoize", "methodParameterType": "IntStream#int#int#", "methodParameterName": "input#ruleIndex#ruleStartIndex#", "methodBody": "public void memoize(IntStream input,\n\t\t\t\t\t\tint ruleIndex,\n\t\t\t\t\t\tint ruleStartIndex)\n\t{\n\t\tint stopTokenIndex = state.failed?MEMO_RULE_FAILED:input.index()-1;\n\t\tif ( state.ruleMemo==null ) {\n\t\t\tSystem.err.println(\"!!!!!!!!! memo array is null for \"+ getGrammarFileName());\n\t\t}\n\t\tif ( ruleIndex >= state.ruleMemo.length ) {\n\t\t\tSystem.err.println(\"!!!!!!!!! memo size is \"+state.ruleMemo.length+\", but rule index is \"+ruleIndex);\n\t\t}\n\t\tif ( state.ruleMemo[ruleIndex]!=null ) {\n\t\t\tstate.ruleMemo[ruleIndex].put(ruleStartIndex, stopTokenIndex);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Record whether or not this rule parsed the input at this position successfully.  Use a standard java hashtable for now.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "252", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/BaseRecognizer.java", "methodName": "org.antlr.runtime.BaseRecognizer.getRuleMemoizationCacheSize", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getRuleMemoizationCacheSize() {\n\t\tint n = 0;\n\t\tfor (int i = 0; state.ruleMemo!=null && i < state.ruleMemo.length; i++) {\n\t\t\tMap<Integer, Integer> ruleMap = state.ruleMemo[i];\n\t\t\tif ( ruleMap!=null ) {\n\t\t\t\tn += ruleMap.size(); // how many input indexes are recorded?\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return how many rule/input-index pairs there are in total. TODO: this includes synpreds. :(", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "253", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CommonTokenStream.java", "methodName": "org.antlr.runtime.CommonTokenStream.consume", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public void consume() {\n        if ( p == -1 ) setup();\n        p++;\n        sync(p);\n        while ( tokens.get(p).getChannel()!=channel ) {\n            p++;\n            sync(p);\n        }\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "Always leave p on an on-channel token.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "254", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CommonTokenStream.java", "methodName": "org.antlr.runtime.CommonTokenStream.skipOffTokenChannels", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "protected int skipOffTokenChannels(int i) {\n        sync(i);\n        while ( tokens.get(i).getChannel()!=channel ) { // also stops at EOF (it's onchannel)\n            i++;\n            sync(i);\n        }\n        return i;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a starting index, return the index of the first on-channel token.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "255", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CommonTokenStream.java", "methodName": "org.antlr.runtime.CommonTokenStream.getNumberOfOnChannelTokens", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getNumberOfOnChannelTokens() {\n\t\tint n = 0;\n\t\tfill();\n\t\tfor (int i = 0; i < tokens.size(); i++) {\n\t\t\tToken t = tokens.get(i);\n\t\t\tif ( t.getChannel()==channel ) n++;\n\t\t\tif ( t.getType()==Token.EOF ) break;\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#BreakStatement#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(BreakStatement)BreakStatement)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Count EOF just once.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "256", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/CommonTokenStream.java", "methodName": "org.antlr.runtime.CommonTokenStream.setTokenSource", "methodParameterType": "TokenSource#", "methodParameterName": "tokenSource#", "methodBody": "@Override\n    public void setTokenSource(TokenSource tokenSource) {\n        super.setTokenSource(tokenSource);\n        channel = Token.DEFAULT_CHANNEL;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset this token stream by setting its token source.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "257", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Token.java", "methodName": "org.antlr.runtime.Token.getText", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getText();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Get the text of the token", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "258", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Token.java", "methodName": "org.antlr.runtime.Token.getLine", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getLine();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "The line number on which this token was matched; line=1..n", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "259", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Token.java", "methodName": "org.antlr.runtime.Token.getCharPositionInLine", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getCharPositionInLine();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "The index of the first character relative to the beginning of the line 0..n-1", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "260", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Token.java", "methodName": "org.antlr.runtime.Token.getTokenIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getTokenIndex();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "An index from 0..n-1 of the token object in the input stream. This must be valid in order to use the ANTLRWorks debugger.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "261", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Token.java", "methodName": "org.antlr.runtime.Token.getInputStream", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public CharStream getInputStream();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "From what character stream was this token created?  You don't have to implement but it's nice to know where a Token comes from if you have include files etc... on the input.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "262", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RuleReturnScope.java", "methodName": "org.antlr.runtime.RuleReturnScope.getStart", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object getStart() { return null; }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the start token or tree", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "263", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RuleReturnScope.java", "methodName": "org.antlr.runtime.RuleReturnScope.getStop", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object getStop() { return null; }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the stop token or tree", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "264", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RuleReturnScope.java", "methodName": "org.antlr.runtime.RuleReturnScope.getTree", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object getTree() { return null; }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Has a value potentially if output=AST;", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "265", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/RuleReturnScope.java", "methodName": "org.antlr.runtime.RuleReturnScope.getTemplate", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Object getTemplate() { return null; }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Has a value potentially if output=template; Don't use StringTemplate type as it then causes a dependency with ST lib.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "266", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/MissingTokenException.java", "methodName": "org.antlr.runtime.MissingTokenException.MissingTokenException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public MissingTokenException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "267", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.nextToken", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Token nextToken() {\n\t\twhile (true) {\n\t\t\tstate.token = null;\n\t\t\tstate.channel = Token.DEFAULT_CHANNEL;\n\t\t\tstate.tokenStartCharIndex = input.index();\n\t\t\tstate.tokenStartCharPositionInLine = input.getCharPositionInLine();\n\t\t\tstate.tokenStartLine = input.getLine();\n\t\t\tstate.text = null;\n\t\t\tif ( input.LA(1)==CharStream.EOF ) {\n\t\t\t\treturn getEOFToken();\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tmTokens();\n\t\t\t\tif ( state.token==null ) {\n\t\t\t\t\temit();\n\t\t\t\t}\n\t\t\t\telse if ( state.token==Token.SKIP_TOKEN ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\treturn state.token;\n\t\t\t}\n\t\t\tcatch (MismatchedRangeException re) {\n\t\t\t\treportError(re);\n\t\t\t\t// matchRange() routine has already called recover()\n\t\t\t}\n\t\t\tcatch (MismatchedTokenException re) {\n\t\t\t\treportError(re);\n\t\t\t\t// match() routine has already called recover()\n\t\t\t}\n\t\t\tcatch (RecognitionException re) {\n\t\t\t\treportError(re);\n\t\t\t\trecover(re); // throw out current char and try again\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#BooleanLiteral#SimpleName#SimpleName#QualifiedName#NullLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ContinueStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(WhileStatement(BooleanLiteral)BooleanLiteral(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement)IfStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "Return a token from this source; i.e., match a token on the char stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "268", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.getEOFToken", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Token getEOFToken() {\n\t\tToken eof = new CommonToken(input,Token.EOF,\n\t\t\t\t\t\t\t\t\tToken.DEFAULT_CHANNEL,\n\t\t\t\t\t\t\t\t\tinput.index(),input.index());\n\t\teof.setLine(getLine());\n\t\teof.setCharPositionInLine(getCharPositionInLine());\n\t\treturn eof;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Returns the EOF token (default), if you need to return a custom token instead override this method.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "269", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.skip", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void skip() {\n\t\tstate.token = Token.SKIP_TOKEN;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Instruct the lexer to skip creating a token for current lexer rule and look for another token.  nextToken() knows to keep looking when a lexer rule finishes with token set to SKIP_TOKEN.  Recall that if token==null at end of any token rule, it creates one for you and emits it.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "270", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.mTokens", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public abstract void mTokens() throws RecognitionException;", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)MethodDeclaration", "methodDoc": "This is the lexer entry point that sets instance var 'token'", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "271", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.setCharStream", "methodParameterType": "CharStream#", "methodParameterName": "input#", "methodBody": "public void setCharStream(CharStream input) {\n\t\tthis.input = null;\n\t\treset();\n\t\tthis.input = input;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#NullLiteral#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the char stream and reset the lexer", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "272", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.emit", "methodParameterType": "Token#", "methodParameterName": "token#", "methodBody": "public void emit(Token token) {\n\t\tstate.token = token;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Currently does not support multiple emits per nextToken invocation for efficiency reasons.  Subclass and override this method and nextToken (to push tokens into a list and pull from that list rather than a single variable as this implementation does).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "273", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.emit", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Token emit() {\n\t\tToken t = new CommonToken(input, state.type, state.channel, state.tokenStartCharIndex, getCharIndex()-1);\n\t\tt.setLine(state.tokenStartLine);\n\t\tt.setText(state.text);\n\t\tt.setCharPositionInLine(state.tokenStartCharPositionInLine);\n\t\temit(t);\n\t\treturn t;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The standard method called to automatically emit a token at the outermost lexical rule.  The token object should point into the char buffer start..stop.  If there is a text override in 'text', use that to set the token's text.  Override this method to emit custom Token objects. If you are building trees, then you should also override Parser or TreeParser.getMissingSymbol().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "274", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.getCharIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getCharIndex() {\n\t\treturn input.index();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the index of the current character of lookahead?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "275", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.getText", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getText() {\n\t\tif ( state.text!=null ) {\n\t\t\treturn state.text;\n\t\t}\n\t\treturn input.substring(state.tokenStartCharIndex,getCharIndex()-1);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the text matched so far for the current token or any text override.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "276", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.setText", "methodParameterType": "String#", "methodParameterName": "text#", "methodBody": "public void setText(String text) {\n\t\tstate.text = text;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the complete text of this token; it wipes any previous changes to the text.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "277", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/Lexer.java", "methodName": "org.antlr.runtime.Lexer.recover", "methodParameterType": "RecognitionException#", "methodParameterName": "re#", "methodBody": "public void recover(RecognitionException re) {\n\t\t//System.out.println(\"consuming char \"+(char)input.LA(1)+\" during recovery\");\n\t\t//re.printStackTrace();\n\t\tinput.consume();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Lexers can normally match any char in it's vocabulary after matching a token, so do the easy thing and just kill a character and hope it all works out.  You can instead use the rule invocation stack to do sophisticated error recovery if you are in a fragment rule.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "278", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/RemoteDebugEventSocketListener.java", "methodName": "org.antlr.runtime.debug.RemoteDebugEventSocketListener.start", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void start() {\n\t\tThread t = new Thread(this);\n\t\tt.start();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a thread to listen to the remote running recognizer", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "279", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/ParseTreeBuilder.java", "methodName": "org.antlr.runtime.debug.ParseTreeBuilder.create", "methodParameterType": "Object#", "methodParameterName": "payload#", "methodBody": "public ParseTree create(Object payload) {\n\t\treturn new ParseTree(payload);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What kind of node to create.  You might want to override so I factored out creation here.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "280", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/ParseTreeBuilder.java", "methodName": "org.antlr.runtime.debug.ParseTreeBuilder.enterDecision", "methodParameterType": "int#boolean#", "methodParameterName": "d#couldBacktrack#", "methodBody": "@Override\n\tpublic void enterDecision(int d, boolean couldBacktrack) { backtracking++; }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#PostfixExpression#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Backtracking or cyclic DFA, don't want to add nodes to tree", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "281", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeParser.java", "methodName": "org.antlr.runtime.debug.DebugTreeParser.DebugTreeParser", "methodParameterType": "TreeNodeStream#DebugEventListener#RecognizerSharedState#", "methodParameterName": "input#dbg#state#", "methodBody": "public DebugTreeParser(TreeNodeStream input, DebugEventListener dbg, RecognizerSharedState state) {\n\t\tsuper(input instanceof DebugTreeNodeStream?input:new DebugTreeNodeStream(input,dbg), state);\n\t\tsetDebugListener(dbg);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ConditionalExpression#SimpleName#SuperConstructorInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(ConditionalExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ConditionalExpression(SimpleName)SimpleName)SuperConstructorInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a normal parser except wrap the token stream in a debug proxy that fires consume events.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "282", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeParser.java", "methodName": "org.antlr.runtime.debug.DebugTreeParser.setDebugListener", "methodParameterType": "DebugEventListener#", "methodParameterName": "dbg#", "methodBody": "public void setDebugListener(DebugEventListener dbg) {\n\t\tif ( input instanceof DebugTreeNodeStream ) {\n\t\t\t((DebugTreeNodeStream)input).setDebugListener(dbg);\n\t\t}\n\t\tthis.dbg = dbg;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Provide a new debug event listener for this parser.  Notify the input stream too that it should send events to this listener.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "283", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.enterRule", "methodParameterType": "String#String#", "methodParameterName": "grammarFileName#ruleName#", "methodBody": "public void enterRule(String grammarFileName, String ruleName);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "The parser has just entered a rule.  No decision has been made about which alt is predicted.  This is fired AFTER init actions have been executed.  Attributes are defined and available etc... The grammarFileName allows composite grammars to jump around among multiple grammar files.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "284", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.enterAlt", "methodParameterType": "int#", "methodParameterName": "alt#", "methodBody": "public void enterAlt(int alt);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Because rules can have lots of alternatives, it is very useful to know which alt you are entering.  This is 1..n for n alts.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "285", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.exitRule", "methodParameterType": "String#String#", "methodParameterName": "grammarFileName#ruleName#", "methodBody": "public void exitRule(String grammarFileName, String ruleName);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "This is the last thing executed before leaving a rule.  It is executed even if an exception is thrown.  This is triggered after error reporting and recovery have occurred (unless the exception is not caught in this rule).  This implies an \"exitAlt\" event. The grammarFileName allows composite grammars to jump around among multiple grammar files.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "286", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.enterSubRule", "methodParameterType": "int#", "methodParameterName": "decisionNumber#", "methodBody": "public void enterSubRule(int decisionNumber);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Track entry into any (...) subrule other EBNF construct", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "287", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.enterDecision", "methodParameterType": "int#boolean#", "methodParameterName": "decisionNumber#couldBacktrack#", "methodBody": "public void enterDecision(int decisionNumber, boolean couldBacktrack);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Every decision, fixed k or arbitrary, has an enter/exit event so that a GUI can easily track what LT/consume events are associated with prediction.  You will see a single enter/exit subrule but multiple enter/exit decision events, one for each loop iteration.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "288", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.consumeToken", "methodParameterType": "Token#", "methodParameterName": "t#", "methodBody": "public void consumeToken(Token t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "An input token was consumed; matched by any kind of element. Trigger after the token was matched by things like match(), matchAny().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "289", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.consumeHiddenToken", "methodParameterType": "Token#", "methodParameterName": "t#", "methodBody": "public void consumeHiddenToken(Token t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "An off-channel input token was consumed. Trigger after the token was matched by things like match(), matchAny(). (unless of course the hidden token is first stuff in the input stream).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "290", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.LT", "methodParameterType": "int#Token#", "methodParameterName": "i#t#", "methodBody": "public void LT(int i, Token t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Somebody (anybody) looked ahead.  Note that this actually gets triggered by both LA and LT calls.  The debugger will want to know which Token object was examined.  Like consumeToken, this indicates what token was seen at that depth.  A remote debugger cannot look ahead into a file it doesn't have so LT events must pass the token even if the info is redundant.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "291", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.mark", "methodParameterType": "int#", "methodParameterName": "marker#", "methodBody": "public void mark(int marker);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "The parser is going to look arbitrarily ahead; mark this location, the token stream's marker is sent in case you need it.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "292", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.rewind", "methodParameterType": "int#", "methodParameterName": "marker#", "methodBody": "public void rewind(int marker);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "After an arbitrairly long lookahead as with a cyclic DFA (or with any backtrack), this informs the debugger that stream should be rewound to the position associated with marker.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "293", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.rewind", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void rewind();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Rewind to the input position of the last marker. Used currently only after a cyclic DFA and just before starting a sem/syn predicate to get the input position back to the start of the decision. Do not \"pop\" the marker off the state.  mark(i) and rewind(i) should balance still.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "294", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.location", "methodParameterType": "int#int#", "methodParameterName": "line#pos#", "methodBody": "public void location(int line, int pos);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "To watch a parser move through the grammar, the parser needs to inform the debugger what line/charPos it is passing in the grammar. For now, this does not know how to switch from one grammar to the other and back for island grammars etc... This should also allow breakpoints because the debugger can stop the parser whenever it hits this line/pos.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "295", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.recognitionException", "methodParameterType": "RecognitionException#", "methodParameterName": "e#", "methodBody": "public void recognitionException(RecognitionException e);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "A recognition exception occurred such as NoViableAltException.  I made this a generic event so that I can alter the exception hierachy later without having to alter all the debug objects. Upon error, the stack of enter rule/subrule must be properly unwound. If no viable alt occurs it is within an enter/exit decision, which also must be rewound.  Even the rewind for each mark must be unwount. In the Java target this is pretty easy using try/finally, if a bit ugly in the generated code.  The rewind is generated in DFA.predict() actually so no code needs to be generated for that.  For languages w/o this \"finally\" feature (C++?), the target implementor will have to build an event stack or something. Across a socket for remote debugging, only the RecognitionException data fields are transmitted.  The token object or whatever that caused the problem was the last object referenced by LT.  The immediately preceding LT event should hold the unexpected Token or char. Here is a sample event trace for grammar: b : C ({;}A|B) // {;} is there to prevent A|B becoming a set | D ; The sequence for this rule (with no viable alt in the subrule) for input 'c c' (there are 3 tokens) is: commence LT(1) enterRule b location 7 1 enter decision 3 LT(1) exit decision 3 enterAlt1 location 7 5 LT(1) consumeToken [c/&lt;4&gt;,1:0] location 7 7 enterSubRule 2 enter decision 2 LT(1) LT(1) recognitionException NoViableAltException 2 1 2 exit decision 2 exitSubRule 2 beginResync LT(1) consumeToken [c/&lt;4&gt;,1:1] LT(1) endResync LT(-1) exitRule b terminate", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "296", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.beginResync", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void beginResync();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Indicates the recognizer is about to consume tokens to resynchronize the parser.  Any consume events from here until the recovered event are not part of the parse--they are dead tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "297", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.endResync", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void endResync();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Indicates that the recognizer has finished consuming tokens in order to resychronize.  There may be multiple beginResync/endResync pairs before the recognizer comes out of errorRecovery mode (in which multiple errors are suppressed).  This will be useful in a gui where you want to probably grey out tokens that are consumed but not matched to anything in grammar.  Anything between a beginResync/endResync pair was tossed out by the parser.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "298", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.semanticPredicate", "methodParameterType": "boolean#String#", "methodParameterName": "result#predicate#", "methodBody": "public void semanticPredicate(boolean result, String predicate);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "A semantic predicate was evaluate with this result and action text", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "299", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.commence", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void commence();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Announce that parsing has begun.  Not technically useful except for sending events over a socket.  A GUI for example will launch a thread to connect and communicate with a remote parser.  The thread will want to notify the GUI when a connection is made.  ANTLR parsers trigger this upon entry to the first rule (the ruleLevel is used to figure this out).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "300", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.terminate", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void terminate();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Parsing is over; successfully or not.  Mostly useful for telling remote debugging listeners that it's time to quit.  When the rule invocation level goes to zero at the end of a rule, we are done parsing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "301", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.consumeNode", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public void consumeNode(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Input for a tree parser is an AST, but we know nothing for sure about a node except its type and text (obtained from the adaptor). This is the analog of the consumeToken method.  Again, the ID is the hashCode usually of the node so it only works if hashCode is not implemented.  If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "302", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.LT", "methodParameterType": "int#Object#", "methodParameterName": "i#t#", "methodBody": "public void LT(int i, Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "The tree parser lookedahead.  If the type is UP or DOWN, then the ID is not really meaningful as it's fixed--there is just one UP node and one DOWN navigation node.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "303", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.nilNode", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public void nilNode(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "A nil was created (even nil nodes have a unique ID... they are not \"null\" per se).  As of 4/28/2006, this seems to be uniquely triggered when starting a new subtree such as when entering a subrule in automatic mode and when building a tree in rewrite mode. If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "304", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.errorNode", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public void errorNode(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Upon syntax error, recognizers bracket the error with an error node if they are building ASTs.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "305", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.createNode", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "public void createNode(Object t);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Announce a new node built from token elements such as type etc... If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID, type, text are set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "306", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.createNode", "methodParameterType": "Object#Token#", "methodParameterName": "node#token#", "methodBody": "public void createNode(Object node, Token token);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Announce a new node built from an existing token. If you are receiving this event over a socket via RemoteDebugEventSocketListener then only node.ID and token.tokenIndex are set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "307", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.becomeRoot", "methodParameterType": "Object#Object#", "methodParameterName": "newRoot#oldRoot#", "methodBody": "public void becomeRoot(Object newRoot, Object oldRoot);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Make a node the new root of an existing root.  See Note: the newRootID parameter is possibly different than the TreeAdaptor.becomeRoot() newRoot parameter. In our case, it will always be the result of calling TreeAdaptor.becomeRoot() and not root_n or whatever. The listener should assume that this event occurs only when the current subrule (or rule) subtree is being reset to newRootID. If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "308", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.addChild", "methodParameterType": "Object#Object#", "methodParameterName": "root#child#", "methodBody": "public void addChild(Object root, Object child);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Make childID a child of rootID. If you are receiving this event over a socket via RemoteDebugEventSocketListener then only IDs are set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "309", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventListener.java", "methodName": "org.antlr.runtime.debug.DebugEventListener.setTokenBoundaries", "methodParameterType": "Object#int#int#", "methodParameterName": "t#tokenStartIndex#tokenStopIndex#", "methodBody": "public void setTokenBoundaries(Object t, int tokenStartIndex, int tokenStopIndex);", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Set the token start/stop token index for a subtree root or node. If you are receiving this event over a socket via RemoteDebugEventSocketListener then only t.ID is set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "310", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.examineRuleMemoization", "methodParameterType": "IntStream#int#int#String#", "methodParameterName": "input#ruleIndex#stopIndex#ruleName#", "methodBody": "public void examineRuleMemoization(IntStream input,\n\t\t\t\t\t\t\t\t\t   int ruleIndex,\n\t\t\t\t\t\t\t\t\t   int stopIndex, // index or MEMO_RULE_UNKNOWN...\n\t\t\t\t\t\t\t\t\t   String ruleName)\n\t{\n\t\tif (dump) System.out.println(\"examine memo \"+ruleName+\" at \"+input.index()+\": \"+stopIndex);\n\t\tif ( stopIndex==BaseRecognizer.MEMO_RULE_UNKNOWN ) {\n\t\t\t//System.out.println(\"rule \"+ruleIndex+\" missed @ \"+input.index());\n\t\t\tstats.numMemoizationCacheMisses++;\n\t\t\tstats.numGuessingRuleInvocations++; // we'll have to enter\n\t\t\tcurrentDecision().numMemoizationCacheMisses++;\n\t\t}\n\t\telse {\n\t\t\t// regardless of rule success/failure, if in cache, we have a cache hit\n\t\t\t//System.out.println(\"rule \"+ruleIndex+\" hit @ \"+input.index());\n\t\t\tstats.numMemoizationCacheHits++;\n\t\t\tcurrentDecision().numMemoizationCacheHits++;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#FieldAccess#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#FieldAccess#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(PostfixExpression(FieldAccess(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess)PostfixExpression)ExpressionStatement)Block(Block(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(PostfixExpression(FieldAccess(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track memoization; this is not part of standard debug interface but is triggered by profiling.  Code gen inserts an override for this method in the recognizer, which triggers this method. Called from alreadyParsedRule().", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "311", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.memoize", "methodParameterType": "IntStream#int#int#String#", "methodParameterName": "input#ruleIndex#ruleStartIndex#ruleName#", "methodBody": "public void memoize(IntStream input,\n\t\t\t\t\t\tint ruleIndex,\n\t\t\t\t\t\tint ruleStartIndex,\n\t\t\t\t\t\tString ruleName)\n\t{\n\t\t// count how many entries go into table\n\t\tif (dump) System.out.println(\"memoize \"+ruleName);\n\t\tstats.numMemoizationCacheEntries++;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Warning: doesn't track success/failure, just unique recording event", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "312", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.inDecision", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean inDecision() {\n\t\treturn decisionStack.size()>0;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The parser is in a decision if the decision depth &gt; 0.  This works for backtracking also, which can have nested decisions.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "313", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.LT", "methodParameterType": "int#Token#", "methodParameterName": "i#t#", "methodBody": "@Override\n\tpublic void LT(int i, Token t) {\n\t\tif ( inDecision() && i>0 ) {\n\t\t\tDecisionEvent d = currentDecision();\n\t\t\tif (dump) System.out.println(\"LT(\"+i+\")=\"+t+\" index \"+t.getTokenIndex()+\" relative to \"+d.decision.ruleName+\"-\"+\n\t\t\t\t\t\t\t   d.decision.decision+\" start index \"+d.startIndex);\n\t\t\tif ( lastRealTokenTouchedInDecision==null ||\n\t\t\t\t lastRealTokenTouchedInDecision.getTokenIndex() < t.getTokenIndex() )\n\t\t\t{\n\t\t\t\tlastRealTokenTouchedInDecision = t;\n\t\t\t\tif (dump) System.out.println(\"set last token \"+lastRealTokenTouchedInDecision);\n\t\t\t}\n\t\t\t// get starting index off stack\n//\t\t\tint stackTop = lookaheadStack.size()-1;\n//\t\t\tInteger startingIndex = (Integer)lookaheadStack.get(stackTop);\n//\t\t\t// compute lookahead depth\n//\t\t\tint thisRefIndex = parser.getTokenStream().index();\n//\t\t\tint numHidden =\n//\t\t\t\tgetNumberOfHiddenTokens(startingIndex.intValue(), thisRefIndex);\n//\t\t\tint depth = i + thisRefIndex - startingIndex.intValue() - numHidden;\n//\t\t\t/*\n//\t\t\tSystem.out.println(\"LT(\"+i+\") @ index \"+thisRefIndex+\" is depth \"+depth+\n//\t\t\t\t\" max is \"+maxLookaheadInCurrentDecision);\n//\t\t\t*/\n//\t\t\tif ( depth>maxLookaheadInCurrentDecision ) {\n//\t\t\t\tmaxLookaheadInCurrentDecision = depth;\n//\t\t\t}\n//\t\t\td.maxk = currentDecision()/\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#Block#IfStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement)Block)IfStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track refs to lookahead if in a fixed/nonfixed decision.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "314", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.beginBacktrack", "methodParameterType": "int#", "methodParameterName": "level#", "methodBody": "@Override\n\tpublic void beginBacktrack(int level) {\n\t\tif (dump) System.out.println(\"enter backtrack \"+level);\n\t\tbacktrackDepth++;\n\t\tDecisionEvent e = currentDecision();\n\t\tif ( e.decision.couldBacktrack ) {\n\t\t\tstats.numBacktrackOccurrences++;\n\t\t\te.decision.numBacktrackOccurrences++;\n\t\t\te.backtracks = true;\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(Block(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(PostfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track backtracking decisions.  You'll see a fixed or cyclic decision and then a backtrack. enter rule ... enter decision LA and possibly consumes (for cyclic DFAs) begin backtrack level mark m rewind m end backtrack level, success exit decision ... exit rule", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "315", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.endBacktrack", "methodParameterType": "int#boolean#", "methodParameterName": "level#successful#", "methodBody": "@Override\n\tpublic void endBacktrack(int level, boolean successful) {\n\t\tif (dump) System.out.println(\"exit backtrack \"+level+\": \"+successful);\n\t\tbacktrackDepth--;\t\t\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Successful or not, track how much lookahead synpreds use", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "316", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/Profiler.java", "methodName": "org.antlr.runtime.debug.Profiler.getNumberOfHiddenTokens", "methodParameterType": "int#int#", "methodParameterName": "i#j#", "methodBody": "public int getNumberOfHiddenTokens(int i, int j) {\n\t\tint n = 0;\n\t\tTokenStream input = parser.getTokenStream();\n\t\tfor (int ti = i; ti<input.size() && ti <= j; ti++) {\n\t\t\tToken t = input.get(ti);\n\t\t\tif ( t.getChannel()!=Token.DEFAULT_CHANNEL ) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get num hidden tokens between i..j inclusive", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "317", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeAdaptor.java", "methodName": "org.antlr.runtime.debug.DebugTreeAdaptor.simulateTreeConstruction", "methodParameterType": "Object#", "methodParameterName": "t#", "methodBody": "protected void simulateTreeConstruction(Object t) {\n\t\tdbg.createNode(t);\n\t\tint n = adaptor.getChildCount(t);\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tObject child = adaptor.getChild(t, i);\n\t\t\tsimulateTreeConstruction(child);\n\t\t\tdbg.addChild(t, child);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "^(A B C): emit create A, create B, add child, ...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "318", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugEventHub.java", "methodName": "org.antlr.runtime.debug.DebugEventHub.addListener", "methodParameterType": "DebugEventListener#", "methodParameterName": "listener#", "methodBody": "public void addListener(DebugEventListener listener) {\n\t\tlisteners.add(listener);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Add another listener to broadcast events too.  Not thread-safe. Don't add events in one thread while parser fires events in another.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "319", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugParser.java", "methodName": "org.antlr.runtime.debug.DebugParser.DebugParser", "methodParameterType": "TokenStream#DebugEventListener#RecognizerSharedState#", "methodParameterName": "input#dbg#state#", "methodBody": "public DebugParser(TokenStream input, DebugEventListener dbg, RecognizerSharedState state) {\n\t\tsuper(input instanceof DebugTokenStream?input:new DebugTokenStream(input,dbg), state);\n\t\tsetDebugListener(dbg);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ConditionalExpression#SimpleName#SuperConstructorInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(ConditionalExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ConditionalExpression(SimpleName)SimpleName)SuperConstructorInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a normal parser except wrap the token stream in a debug proxy that fires consume events.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "320", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugParser.java", "methodName": "org.antlr.runtime.debug.DebugParser.setDebugListener", "methodParameterType": "DebugEventListener#", "methodParameterName": "dbg#", "methodBody": "public void setDebugListener(DebugEventListener dbg) {\n\t\tif ( input instanceof DebugTokenStream ) {\n\t\t\t((DebugTokenStream)input).setDebugListener(dbg);\n\t\t}\n\t\tthis.dbg = dbg;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Provide a new debug event listener for this parser.  Notify the input stream too that it should send events to this listener.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "321", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/debug/DebugTreeNodeStream.java", "methodName": "org.antlr.runtime.debug.DebugTreeNodeStream.setUniqueNavigationNodes", "methodParameterType": "boolean#", "methodParameterName": "uniqueNavigationNodes#", "methodBody": "@Override\n\tpublic void setUniqueNavigationNodes(boolean uniqueNavigationNodes) {\n\t\tinput.setUniqueNavigationNodes(uniqueNavigationNodes);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "It is normally this object that instructs the node stream to create unique nav nodes, but to satisfy interface, we have to define it.  It might be better to ignore the parameter but there might be a use for it later, so I'll leave.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "322", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java", "methodName": "org.antlr.runtime.ANTLRStringStream.ANTLRStringStream", "methodParameterType": "String#", "methodParameterName": "input#", "methodBody": "public ANTLRStringStream(String input) {\n\t\tthis();\n\t\tthis.data = input.toCharArray();\n\t\tthis.n = input.length();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ConstructorInvocation#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation)ConstructorInvocation(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Copy data in string to a local char array", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "323", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java", "methodName": "org.antlr.runtime.ANTLRStringStream.ANTLRStringStream", "methodParameterType": "char[]#int#", "methodParameterName": "data#numberOfActualCharsInArray#", "methodBody": "public ANTLRStringStream(char[] data, int numberOfActualCharsInArray) {\n\t\tthis();\n\t\tthis.data = data;\n\t\tthis.n = numberOfActualCharsInArray;\n\t}", "AST": "Javadoc#Modifier#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#ConstructorInvocation#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation)ConstructorInvocation(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "This is the preferred constructor as no data is copied", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "324", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java", "methodName": "org.antlr.runtime.ANTLRStringStream.reset", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void reset() {\n\t\tp = 0;\n\t\tline = 1;\n\t\tcharPositionInLine = 0;\n\t\tmarkDepth = 0;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Reset the stream so that it's in the same state it was when the object was created", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "325", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java", "methodName": "org.antlr.runtime.ANTLRStringStream.index", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int index() {\n        return p;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the current input symbol index 0..n where n indicates the last symbol has been read.  The index is the index of char to be returned from LA(1).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "326", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/ANTLRStringStream.java", "methodName": "org.antlr.runtime.ANTLRStringStream.seek", "methodParameterType": "int#", "methodParameterName": "index#", "methodBody": "@Override\n\tpublic void seek(int index) {\n\t\tif ( index<=p ) {\n\t\t\tp = index; // just jump; don't update stream state (line, ...)\n\t\t\treturn;\n\t\t}\n\t\t// seek forward, consume until p hits index\n\t\twhile ( p<index ) {\n\t\t\tconsume();\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "consume() ahead until p==index; can't just set p=index as we must update line and charPositionInLine.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "327", "file": "/root/repos/repos29/antlr3/runtime/Java/src/main/java/org/antlr/runtime/MismatchedSetException.java", "methodName": "org.antlr.runtime.MismatchedSetException.MismatchedSetException", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public MismatchedSetException() {;}", "AST": "Javadoc#Modifier#SimpleName#EmptyStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(EmptyStatement)EmptyStatement)Block)MethodDeclaration", "methodDoc": "Used for remote debugger deserialization", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "328", "file": "/root/repos/repos29/antlr3/gunit-maven-plugin/src/main/java/org/antlr/mojo/antlr3/GUnitExecuteMojo.java", "methodName": "org.antlr.mojo.antlr3.GUnitExecuteMojo.determineProjectCompileScopeClassLoader", "methodParameterType": "Artifact#", "methodParameterName": "antlrArtifact#", "methodBody": "private ClassLoader determineProjectCompileScopeClassLoader(Artifact antlrArtifact)\n\t\t\tthrows MojoExecutionException {\n\t\tArrayList<URL> classPathUrls = new ArrayList<URL>();\n\t\tgetLog().info( \"Adding Antlr artifact : \" + antlrArtifact.getId() );\n\t\tclassPathUrls.add( resolveLocalURL( antlrArtifact ) );\n\n\t\tfor ( String path : classpathElements() ) {\n\t\t\ttry {\n\t\t\t\tgetLog().info( \"Adding project compile classpath element : \" + path );\n\t\t\t\tclassPathUrls.add( new File( path ).toURI().toURL() );\n\t\t\t}\n\t\t\tcatch ( MalformedURLException e ) {\n\t\t\t\tthrow new MojoExecutionException( \"Unable to build path URL [\" + path + \"]\" );\n\t\t\t}\n\t\t}\n\n\t\treturn new URLClassLoader( classPathUrls.toArray( new URL[classPathUrls.size()] ), getClass().getClassLoader() );\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#CatchClause#TryStatement#Block#EnhancedForStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#MethodInvocation#ArrayCreation#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(TryStatement(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)CatchClause)TryStatement)Block)EnhancedForStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayCreation(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ArrayCreation)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Builds the classloader to pass to gUnit.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "329", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/Main.java", "methodName": "$.Main.main", "methodParameterType": "String[]#", "methodParameterName": "args#", "methodBody": "public static void main(String[] args)\n        {\n            try\n            {\n                // Create the lexer, which we can keep reusing if we like\n                //\n                lexer = new TLexer();\n\n                if  (args.length > 0)\n                {\n                    int s = 0;\n\n                    if  (args[0].startsWith(\"-dot\"))\n                    {\n                        makeDot = true;\n                        s = 1;\n                    }\n                    // Recursively parse each directory, and each file on the\n                    // command line\n                    //\n                    for (int i=s; i<args.length; i++)\n                    {\n                        parse(new File(args[i]));\n                    }\n                }\n                else\n                {\n                    System.err.println(\"Usage: java -jar ${artifactId}-${version}-jar-with-dependencies.jar <directory | filename.dmo>\");\n                }\n            }\n            catch (Exception ex)\n            {\n                System.err.println(\"ANTLR demo parser threw exception:\");\n                ex.printStackTrace();\n            }\n        }", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#ArrayAccess#SimpleName#StringLiteral#MethodInvocation#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ArrayAccess#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)MethodDeclaration", "methodDoc": "Just a simple test driver for the ASP parser to show how to call it.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "330", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public AbstractTLexer() {\n    }", "AST": "Javadoc#Modifier#SimpleName#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block)Block)MethodDeclaration", "methodDoc": "Default constructor for the lexer, when you do not yet know what the character stream to be provided is.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "331", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "CharStream#", "methodParameterName": "input#", "methodBody": "public AbstractTLexer(CharStream input) {\n        this(input, new RecognizerSharedState());\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new instance of the lexer using the given character stream as the input to lex into tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "332", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "CharStream#RecognizerSharedState#", "methodParameterName": "input#state#", "methodBody": "public AbstractTLexer(CharStream input, RecognizerSharedState state) {\n        super(input,state);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Internal constructor for ANTLR - do not use.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "333", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.AbstractTParser", "methodParameterType": "TokenStream#", "methodParameterName": "input#", "methodBody": "protected AbstractTParser(TokenStream input) {\n        super(input);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new parser instance, pre-supplying the input token stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "334", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.AbstractTParser", "methodParameterType": "TokenStream#RecognizerSharedState#", "methodParameterName": "input#state#", "methodBody": "protected AbstractTParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new parser instance, pre-supplying the input token stream and the shared state. This is only used when a grammar is imported into another grammar, but we must supply this constructor to satisfy the super class contract.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "335", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/src/main/resources/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.displayRecognitionError", "methodParameterType": "String[]#RecognitionException#", "methodParameterName": "tokenNames#e#", "methodBody": "@Override\n    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {\n\n        // This is just a place holder that shows how to override this method\n        //\n        super.displayRecognitionError(tokenNames, e);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Creates the error/warning message that we need to show users/IDEs when ANTLR has found a parsing error, has recovered from it and is now telling us that a parsing exception occurred.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "336", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/Main.java", "methodName": "$.Main.main", "methodParameterType": "String[]#", "methodParameterName": "args#", "methodBody": "public static void main(String[] args)\n        {\n            try\n            {\n                // Create the lexer, which we can keep reusing if we like\n                //\n                lexer = new TLexer();\n\n                if  (args.length > 0)\n                {\n                    int s = 0;\n\n                    if  (args[0].startsWith(\"-dot\"))\n                    {\n                        makeDot = true;\n                        s = 1;\n                    }\n                    // Recursively parse each directory, and each file on the\n                    // command line\n                    //\n                    for (int i=s; i<args.length; i++)\n                    {\n                        parse(new File(args[i]));\n                    }\n                }\n                else\n                {\n                    System.err.println(\"Usage: java -jar antlr3-maven-archetype-3.5.3-SNAPSHOT-jar-with-dependencies.jar <directory | filename.dmo>\");\n                }\n            }\n            catch (Exception ex)\n            {\n                System.err.println(\"ANTLR demo parser threw exception:\");\n                ex.printStackTrace();\n            }\n        }", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#ArrayAccess#SimpleName#StringLiteral#MethodInvocation#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ArrayAccess#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)MethodDeclaration", "methodDoc": "Just a simple test driver for the ASP parser to show how to call it.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "337", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public AbstractTLexer() {\n    }", "AST": "Javadoc#Modifier#SimpleName#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block)Block)MethodDeclaration", "methodDoc": "Default constructor for the lexer, when you do not yet know what the character stream to be provided is.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "338", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "CharStream#", "methodParameterName": "input#", "methodBody": "public AbstractTLexer(CharStream input) {\n        this(input, new RecognizerSharedState());\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ConstructorInvocation(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new instance of the lexer using the given character stream as the input to lex into tokens.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "339", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTLexer.java", "methodName": "$.AbstractTLexer.AbstractTLexer", "methodParameterType": "CharStream#RecognizerSharedState#", "methodParameterName": "input#state#", "methodBody": "public AbstractTLexer(CharStream input, RecognizerSharedState state) {\n        super(input,state);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Internal constructor for ANTLR - do not use.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "340", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.AbstractTParser", "methodParameterType": "TokenStream#", "methodParameterName": "input#", "methodBody": "protected AbstractTParser(TokenStream input) {\n        super(input);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new parser instance, pre-supplying the input token stream.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "341", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.AbstractTParser", "methodParameterType": "TokenStream#RecognizerSharedState#", "methodParameterName": "input#state#", "methodBody": "protected AbstractTParser(TokenStream input, RecognizerSharedState state) {\n        super(input, state);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SuperConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Create a new parser instance, pre-supplying the input token stream and the shared state. This is only used when a grammar is imported into another grammar, but we must supply this constructor to satisfy the super class contract.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "342", "file": "/root/repos/repos29/antlr3/antlr3-maven-archetype/target/classes/archetype-resources/src/main/java/AbstractTParser.java", "methodName": "$.AbstractTParser.displayRecognitionError", "methodParameterType": "String[]#RecognitionException#", "methodParameterName": "tokenNames#e#", "methodBody": "@Override\n    public void displayRecognitionError(String[] tokenNames, RecognitionException e) {\n\n        // This is just a place holder that shows how to override this method\n        //\n        super.displayRecognitionError(tokenNames, e);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Creates the error/warning message that we need to show users/IDEs when ANTLR has found a parsing error, has recovered from it and is now telling us that a parsing exception occurred.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "343", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/MachineProbe.java", "methodName": "org.antlr.analysis.MachineProbe.getEdgeLabels", "methodParameterType": "DFAState#", "methodParameterName": "targetState#", "methodBody": "public List<IntSet> getEdgeLabels(DFAState targetState) {\n\t\tList<DFAState> dfaStates = getAnyDFAPathToTarget(targetState);\n\t\tList<IntSet> labels = new ArrayList<IntSet>();\n\t\tfor (int i = 0; i < dfaStates.size() - 1; i++) {\n\t\t\tDFAState d = dfaStates.get(i);\n\t\t\tDFAState nextState = dfaStates.get(i + 1);\n\t\t\t// walk looking for edge whose target is next dfa state\n\t\t\tfor (int j = 0; j < d.getNumberOfTransitions(); j++) {\n\t\t\t\tTransition e = d.getTransition(j);\n\t\t\t\tif (e.target.stateNumber == nextState.stateNumber) {\n\t\t\t\t\tlabels.add(e.label.getSet());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn labels;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of edge labels from start state to targetState.", "call_func_name": ["org.antlr.analysis.MachineProbe.getAnyDFAPathToTarget", "java.util.ArrayList.<init>", "java.util.List.size", "java.util.List.get", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.getTransition", "org.antlr.analysis.Label.getSet", "java.util.List.add"], "call_func_parameter": [["org.antlr.analysis.DFAState"], [""], [""], ["int"], [""], ["int"], [""], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "344", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/MachineProbe.java", "methodName": "org.antlr.analysis.MachineProbe.getInputSequenceDisplay", "methodParameterType": "Grammar#List<IntSet>#", "methodParameterName": "g#labels#", "methodBody": "public String getInputSequenceDisplay(Grammar g, List<IntSet> labels) {\n\t\tList<String> tokens = new ArrayList<String>();\n\t\tfor (IntSet label : labels)\n\t\t\ttokens.add(label.toString(g));\n\t\treturn tokens.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)EnhancedForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given List&lt;IntSet&gt;, return a String with a useful representation of the associated input string. One could show something different for lexers and parsers, for example.", "call_func_name": ["java.util.ArrayList.<init>", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.misc.IntSet.toString", "java.util.List.add", "java.lang.Object.toString"], "call_func_parameter": [[""], [""], [""], [""], ["org.antlr.tool.Grammar"], ["java.lang.Object"], [""]], "passed_comments": "/"}, {"index": "345", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/MachineProbe.java", "methodName": "org.antlr.analysis.MachineProbe.getGrammarLocationsForInputSequence", "methodParameterType": "List<Set<NFAState>>#List<IntSet>#", "methodParameterName": "nfaStates#labels#", "methodBody": "public List<Token> getGrammarLocationsForInputSequence(\n\t\t\tList<Set<NFAState>> nfaStates, List<IntSet> labels) {\n\t\tList<Token> tokens = new ArrayList<Token>();\n\t\tfor (int i = 0; i < nfaStates.size() - 1; i++) {\n\t\t\tSet<NFAState> cur = nfaStates.get(i);\n\t\t\tSet<NFAState> next = nfaStates.get(i + 1);\n\t\t\tIntSet label = labels.get(i);\n\t\t\t// find NFA state with edge whose label matches labels[i]\n\t\t\tnfaConfigLoop: \n\t\t\t\n\t\t\tfor (NFAState p : cur) {\n\t\t\t\t// walk p's transitions, looking for label\n\t\t\t\tfor (int j = 0; j < p.getNumberOfTransitions(); j++) {\n\t\t\t\t\tTransition t = p.transition(j);\n\t\t\t\t\tif (!t.isEpsilon() && !t.label.getSet().and(label).isNil()\n\t\t\t\t\t\t\t&& next.contains(t.target)) {\n\t\t\t\t\t\tif (p.associatedASTNode != null) {\n\t\t\t\t\t\t\tToken oldtoken = p.associatedASTNode.token;\n\t\t\t\t\t\t\tCommonToken token = new CommonToken(oldtoken\n\t\t\t\t\t\t\t\t\t.getType(), oldtoken.getText());\n\t\t\t\t\t\t\ttoken.setLine(oldtoken.getLine());\n\t\t\t\t\t\t\ttoken.setCharPositionInLine(oldtoken.getCharPositionInLine());\n\t\t\t\t\t\t\ttokens.add(token);\n\t\t\t\t\t\t\tbreak nfaConfigLoop; // found path, move to next\n\t\t\t\t\t\t\t\t\t\t\t\t\t// NFAState set\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BreakStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#Block#EnhancedForStatement#LabeledStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(LabeledStatement(SimpleName)SimpleName(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(PrefixExpression(MethodInvocation(MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(BreakStatement(SimpleName)SimpleName)BreakStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement)Block)EnhancedForStatement)LabeledStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given an alternative associated with a DFA state, return the list of tokens (from grammar) associated with path through NFA following the labels sequence. The nfaStates gives the set of NFA states associated with alt that take us from start to stop. One of the NFA states in nfaStates[i] will have an edge intersecting with labels[i].", "call_func_name": ["java.util.ArrayList.<init>", "java.util.List.size", "java.util.List.get", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.analysis.NFAState.getNumberOfTransitions", "org.antlr.analysis.NFAState.transition", "org.antlr.analysis.Transition.isEpsilon", "org.antlr.analysis.Label.getSet", "org.antlr.misc.IntSet.and", "org.antlr.misc.IntSet.isNil", "java.util.Set.contains", "org.antlr.runtime.Token.getType", "org.antlr.runtime.Token.getText", "org.antlr.runtime.CommonToken.<init>", "org.antlr.runtime.Token.getLine", "org.antlr.runtime.CommonToken.setLine", "org.antlr.runtime.Token.getCharPositionInLine", "org.antlr.runtime.CommonToken.setCharPositionInLine", "java.util.List.add"], "call_func_parameter": [[""], [""], ["int"], [""], [""], [""], [""], ["int"], [""], [""], ["org.antlr.misc.IntSet"], [""], ["java.lang.Object"], [""], [""], ["int", "java.lang.String"], [""], ["int"], [""], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.IntSet.and": "Return the intersection of this set with the argument, creating a new set."}, {"org.antlr.runtime.Token.getText": "Get the text of the token"}, {"org.antlr.runtime.Token.getLine": "The line number on which this token was matched; line=1..n"}, {"org.antlr.runtime.Token.getCharPositionInLine": "The index of the first character relative to the beginning of the line 0..n-1"}]}, {"index": "346", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAState.java", "methodName": "org.antlr.analysis.NFAState.setTransition0", "methodParameterType": "Transition#", "methodParameterName": "e#", "methodBody": "public void setTransition0(Transition e) {\n\t\tif ( e==null ) {\n\t\t\tthrow new IllegalArgumentException(\"You can't use a solitary null transition\");\n\t\t}\n\t\ttransition[0] = e;\n\t\ttransition[1] = null;\n\t\tnumTransitions = 1;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#NumberLiteral#ArrayAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#NumberLiteral#ArrayAccess#NullLiteral#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Used during optimization to reset a state to have the (single) transition another state has.", "call_func_name": ["java.lang.IllegalArgumentException.<init>"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "347", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAState.java", "methodName": "org.antlr.analysis.NFAState.translateDisplayAltToWalkAlt", "methodParameterType": "int#", "methodParameterName": "displayAlt#", "methodBody": "public int translateDisplayAltToWalkAlt(int displayAlt) {\n\t\tNFAState nfaStart = this;\n\t\tif ( decisionNumber==0 || decisionStateType==0 ) {\n\t\t\treturn displayAlt;\n\t\t}\n\t\tint walkAlt = 0;\n\t\t// find the NFA loopback state associated with this DFA\n\t\t// and count number of alts (all alt numbers are computed\n\t\t// based upon the loopback's NFA state.\n\t\t/*\n\t\tDFA dfa = nfa.grammar.getLookaheadDFA(decisionNumber);\n\t\tif ( dfa==null ) {\n\t\t\tErrorManager.internalError(\"can't get DFA for decision \"+decisionNumber);\n\t\t}\n\t\t*/\n\t\tint nAlts = nfa.grammar.getNumberOfAltsForDecisionNFA(nfaStart);\n\t\tswitch ( nfaStart.decisionStateType ) {\n\t\t\tcase LOOPBACK :\n\t\t\t\twalkAlt = displayAlt % nAlts + 1; // rotate right mod 1..3\n\t\t\t\tbreak;\n\t\t\tcase BLOCK_START :\n\t\t\tcase OPTIONAL_BLOCK_START :\n\t\t\t\twalkAlt = displayAlt; // identity transformation\n\t\t\t\tbreak;\n\t\t\tcase BYPASS :\n\t\t\t\tif ( displayAlt == nAlts ) {\n\t\t\t\t\twalkAlt = 2; // bypass\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\twalkAlt = 1; // any non exit branch alt predicts entering\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn walkAlt;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SwitchCase#SimpleName#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#BreakStatement#SimpleName#SwitchCase#SimpleName#SwitchCase#SimpleName#SimpleName#Assignment#ExpressionStatement#BreakStatement#SimpleName#SwitchCase#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#BreakStatement#SwitchStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(SwitchStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SwitchCase(SimpleName)SimpleName)SwitchCase(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(SimpleName)SimpleName)SwitchCase(SwitchCase(SimpleName)SimpleName)SwitchCase(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(SimpleName)SimpleName)SwitchCase(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(BreakStatement)BreakStatement)SwitchStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The DFA decision for this NFA decision state always has an exit path for loops as n+1 for n alts in the loop. That is really useful for displaying nondeterministic alts and so on, but for walking the NFA to get a sequence of edge labels or for actually parsing, we need to get the real alt number.  The real alt number for exiting a loop is always 1 as transition 0 points at the exit branch (we compute DFAs always for loops at the loopback state). For walking/parsing the loopback state: 1 2 3 display alt (for human consumption) 2 3 1 walk alt For walking the block start: 1 2 3 display alt 1 2 3 For walking the bypass state of a (...)", "call_func_name": ["org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA"], "call_func_parameter": [["org.antlr.analysis.NFAState"]], "passed_comments": [{"org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision."}]}, {"index": "348", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAState.java", "methodName": "org.antlr.analysis.NFAState.setDecisionASTNode", "methodParameterType": "GrammarAST#", "methodParameterName": "decisionASTNode#", "methodBody": "public void setDecisionASTNode(GrammarAST decisionASTNode) {\n\t\tdecisionASTNode.setNFAStartState(this);\n\t\tthis.associatedASTNode = decisionASTNode;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "What AST node is associated with this NFAState?  When you set the AST node, I set the node to point back to this NFA state.", "call_func_name": ["org.antlr.tool.GrammarAST.setNFAStartState"], "call_func_parameter": [["org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "349", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java", "methodName": "org.antlr.analysis.LL1Analyzer.FIRST", "methodParameterType": "NFAState#", "methodParameterName": "s#", "methodBody": "public LookaheadSet FIRST(NFAState s) {\n\t\t//System.out.println(\"> FIRST(\"+s.enclosingRule.name+\") in rule \"+s.enclosingRule);\n\t\tlookBusy.clear();\n\t\tLookaheadSet look = _FIRST(s, false);\n\t\t//System.out.println(\"< FIRST(\"+s.enclosingRule.name+\") in rule \"+s.enclosingRule+\"=\"+look.toString(this.grammar));\n\t\treturn look;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From an NFA state, s, find the set of all labels reachable from s. Used to compute follow sets for error recovery.  Never computes a FOLLOW operation.  FIRST stops at end of rules, returning EOR, unless invoked from another rule.  I.e., routine properly handles a : b A ; where b is nullable. We record with EOR_TOKEN_TYPE if we hit the end of a rule so we can know at runtime (when these sets are used) to start walking up the follow chain to compute the real, correct follow set (as opposed to the FOLLOW, which is a superset). This routine will only be used on parser and tree parser grammars.", "call_func_name": ["java.util.Set.clear", "org.antlr.analysis.LL1Analyzer._FIRST"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "boolean"]], "passed_comments": "/"}, {"index": "350", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java", "methodName": "org.antlr.analysis.LL1Analyzer.detectConfoundingPredicates", "methodParameterType": "NFAState#", "methodParameterName": "s#", "methodBody": "public boolean detectConfoundingPredicates(NFAState s) {\n\t\tlookBusy.clear();\n\t\tRule r = s.enclosingRule;\n\t\treturn _detectConfoundingPredicates(s, r, false) == DETECT_PRED_FOUND;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is there a non-syn-pred predicate visible from s that is not in the rule enclosing s?  This accounts for most predicate situations and lets ANTLR do a simple LL(1)+pred computation. TODO: what about gated vs regular preds?", "call_func_name": ["java.util.Set.clear", "org.antlr.analysis.LL1Analyzer._detectConfoundingPredicates"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.tool.Rule", "boolean"]], "passed_comments": "/"}, {"index": "351", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/LL1Analyzer.java", "methodName": "org.antlr.analysis.LL1Analyzer.getPredicates", "methodParameterType": "NFAState#", "methodParameterName": "altStartState#", "methodBody": "public SemanticContext getPredicates(NFAState altStartState) {\n\t\tlookBusy.clear();\n\t\treturn _getPredicates(altStartState, altStartState);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return predicate expression found via epsilon edges from s.  Do not look into other rules for now.  Do something simple.  Include backtracking synpreds.", "call_func_name": ["java.util.Set.clear", "org.antlr.analysis.LL1Analyzer._getPredicates"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "352", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/PredicateLabel.java", "methodName": "org.antlr.analysis.PredicateLabel.PredicateLabel", "methodParameterType": "GrammarAST#", "methodParameterName": "predicateASTNode#", "methodBody": "public PredicateLabel(GrammarAST predicateASTNode) {\n\t\tsuper(SEMPRED);\n\t\tthis.semanticContext = new SemanticContext.Predicate(predicateASTNode);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SuperConstructorInvocation#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName)SuperConstructorInvocation(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make a semantic predicate label", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "353", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/PredicateLabel.java", "methodName": "org.antlr.analysis.PredicateLabel.PredicateLabel", "methodParameterType": "SemanticContext#", "methodParameterName": "semCtx#", "methodBody": "public PredicateLabel(SemanticContext semCtx) {\n\t\tsuper(SEMPRED);\n\t\tthis.semanticContext = semCtx;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SuperConstructorInvocation#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SuperConstructorInvocation(SimpleName)SimpleName)SuperConstructorInvocation(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make a semantic predicates label", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "354", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/LL1DFA.java", "methodName": "org.antlr.analysis.LL1DFA.LL1DFA", "methodParameterType": "int#NFAState#LookaheadSet[]#", "methodParameterName": "decisionNumber#decisionStartState#altLook#", "methodBody": "@SuppressWarnings(\"OverridableMethodCallInConstructor\")\n\tpublic LL1DFA(int decisionNumber, NFAState decisionStartState, LookaheadSet[] altLook) {\n\t\tDFAState s0 = newState();\n\t\tstartState = s0;\n\t\tnfa = decisionStartState.nfa;\n\t\tnAlts = nfa.grammar.getNumberOfAltsForDecisionNFA(decisionStartState);\n\t\tthis.decisionNumber = decisionNumber;\n\t\tthis.decisionNFAStartState = decisionStartState;\n\t\tinitAltRelatedInfo();\n\t\tunreachableAlts = null;\n\t\tfor (int alt=1; alt<altLook.length; alt++) {\n\t\t\tDFAState acceptAltState = newState();\n\t\t\tacceptAltState.acceptState = true;\n\t\t\tsetAcceptState(alt, acceptAltState);\n\t\t\tacceptAltState.k = 1;\n\t\t\tacceptAltState.cachedUniquelyPredicatedAlt = alt;\n\t\t\tLabel e = getLabelForSet(altLook[alt].tokenTypeSet);\n\t\t\ts0.addTransition(acceptAltState, e);\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#StringLiteral#SingleMemberAnnotation#Modifier#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#Assignment#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#FieldAccess#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(SingleMemberAnnotation(SimpleName)SimpleName(StringLiteral)StringLiteral)SingleMemberAnnotation(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(FieldAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)FieldAccess)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "From list of lookahead sets (one per alt in decision), create an LL(1) DFA.  One edge per set. s0-{alt1}-&gt;:o=&gt;1 | \\ |  -{alt2}-&gt;:o=&gt;2 | ...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "355", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/LL1DFA.java", "methodName": "org.antlr.analysis.LL1DFA.LL1DFA", "methodParameterType": "int#NFAState#MultiMap<IntervalSet,Integer>#", "methodParameterName": "decisionNumber#decisionStartState#edgeMap#", "methodBody": "@SuppressWarnings(\"OverridableMethodCallInConstructor\")\n\tpublic LL1DFA(int decisionNumber,\n\t\t\t\t  NFAState decisionStartState,\n\t\t\t\t  MultiMap<IntervalSet, Integer> edgeMap)\n\t{\n\t\tDFAState s0 = newState();\n\t\tstartState = s0;\n\t\tnfa = decisionStartState.nfa;\n\t\tnAlts = nfa.grammar.getNumberOfAltsForDecisionNFA(decisionStartState);\n\t\tthis.decisionNumber = decisionNumber;\n\t\tthis.decisionNFAStartState = decisionStartState;\n\t\tinitAltRelatedInfo();\n\t\tunreachableAlts = null;\n\t\tfor (Map.Entry<IntervalSet, List<Integer>> entry : edgeMap.entrySet()) {\n\t\t\tIntervalSet edge = entry.getKey();\n\t\t\tList<Integer> alts = entry.getValue();\n\t\t\tCollections.sort(alts); // make sure alts are attempted in order\n\t\t\t//System.out.println(edge+\" -> \"+alts);\n\t\t\tDFAState s = newState();\n\t\t\ts.k = 1;\n\t\t\tLabel e = getLabelForSet(edge);\n\t\t\ts0.addTransition(s, e);\n\t\t\tif ( alts.size()==1 ) {\n\t\t\t\ts.acceptState = true;\n\t\t\t\tint alt = alts.get(0);\n\t\t\t\tsetAcceptState(alt, s);\n\t\t\t\ts.cachedUniquelyPredicatedAlt = alt;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// resolve with syntactic predicates.  Add edges from\n\t\t\t\t// state s that test predicates.\n\t\t\t\ts.resolvedWithPredicates = true;\n\t\t\t\tfor (int i = 0; i < alts.size(); i++) {\n\t\t\t\t\tint alt = (int)alts.get(i);\n\t\t\t\t\ts.cachedUniquelyPredicatedAlt =\tNFA.INVALID_ALT_NUMBER;\n\t\t\t\t\tDFAState predDFATarget = getAcceptState(alt);\n\t\t\t\t\tif ( predDFATarget==null ) {\n\t\t\t\t\t\tpredDFATarget = newState(); // create if not there.\n\t\t\t\t\t\tpredDFATarget.acceptState = true;\n\t\t\t\t\t\tpredDFATarget.cachedUniquelyPredicatedAlt =\talt;\n\t\t\t\t\t\tsetAcceptState(alt, predDFATarget);\n\t\t\t\t\t}\n\t\t\t\t\t// add a transition to pred target from d\n\t\t\t\t\t/*\n\t\t\t\t\tint walkAlt =\n\t\t\t\t\t\tdecisionStartState.translateDisplayAltToWalkAlt(alt);\n\t\t\t\t\tNFAState altLeftEdge = nfa.grammar.getNFAStateForAltOfDecision(decisionStartState, walkAlt);\n\t\t\t\t\tNFAState altStartState = (NFAState)altLeftEdge.transition[0].target;\n\t\t\t\t\tSemanticContext ctx = nfa.grammar.ll1Analyzer.getPredicates(altStartState);\n\t\t\t\t\tSystem.out.println(\"sem ctx = \"+ctx);\n\t\t\t\t\tif ( ctx == null ) {\n\t\t\t\t\t\tctx = new SemanticContext.TruePredicate();\n\t\t\t\t\t}\n\t\t\t\t\ts.addTransition(predDFATarget, new Label(ctx));\n\t\t\t\t\t*/\n\t\t\t\t\tSemanticContext.Predicate synpred =\n\t\t\t\t\t\tgetSynPredForAlt(decisionStartState, alt);\n\t\t\t\t\tif ( synpred == null ) {\n\t\t\t\t\t\tsynpred = new SemanticContext.TruePredicate();\n\t\t\t\t\t}\n\t\t\t\t\ts.addTransition(predDFATarget, new PredicateLabel(synpred));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"dfa for preds=\\n\"+this);\n\t}", "AST": "Javadoc#SimpleName#StringLiteral#SingleMemberAnnotation#Modifier#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#IfStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(SingleMemberAnnotation(SimpleName)SimpleName(StringLiteral)StringLiteral)SingleMemberAnnotation(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)IfStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "From a set of edgeset&rarr;list-of-alts mappings, create a DFA that uses syn preds for all |list-of-alts|&gt;1.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "356", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAContext.java", "methodName": "org.antlr.analysis.NFAContext.equals", "methodParameterType": "Object#", "methodParameterName": "o#", "methodBody": "@Override\n\tpublic boolean equals(Object o) {\n\t\tNFAContext other = ((NFAContext)o);\n\t\tif ( this.cachedHashCode != other.cachedHashCode ) {\n\t\t\treturn false; // can't be same if hash is different\n\t\t}\n\t\tif ( this==other ) {\n\t\t\treturn true;\n\t\t}\n\t\t// System.out.println(\"comparing \"+this+\" with \"+other);\n\t\tNFAContext sp = this;\n\t\twhile ( sp.parent!=null && other.parent!=null ) {\n\t\t\tif ( sp.invokingState != other.invokingState ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsp = sp.parent;\n\t\t\tother = other.parent;\n\t\t}\n\t\tif ( !(sp.parent==null && other.parent==null) ) {\n\t\t\treturn false; // both pointers must be at their roots after walk\n\t\t}\n\t\treturn true;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#ThisExpression#SimpleName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ThisExpression)ThisExpression(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)WhileStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Two contexts are equals() if both have same call stack; walk upwards to the root. Recall that the root sentinel node has no invokingStates and no parent. Note that you may be comparing contexts in different alt trees. The hashCode is now cheap as it's computed once upon each context push on the stack.  Use it to make equals() more efficient.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "357", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAContext.java", "methodName": "org.antlr.analysis.NFAContext.conflictsWith", "methodParameterType": "NFAContext#", "methodParameterName": "other#", "methodBody": "public boolean conflictsWith(NFAContext other) {\n\t\treturn this.suffix(other); // || this.equals(other);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Two contexts conflict() if they are equals() or one is a stack suffix of the other.  For example, contexts [21 12 $] and [21 9 $] do not conflict, but [21 $] and [21 12 $] do conflict.  Note that I should probably not show the $ in this case.  There is a dummy node for each stack that just means empty; $ is a marker that's all. This is used in relation to checking conflicts associated with a single NFA state's configurations within a single DFA state. If there are configurations s and t within a DFA state such that s.state=t.state &amp;&amp; s.alt != t.alt &amp;&amp; s.ctx conflicts t.ctx then the DFA state predicts more than a single alt--it's nondeterministic. Two contexts conflict if they are the same or if one is a suffix of the other. When comparing contexts, if one context has a stack and the other does not then they should be considered the same context.  The only way for an NFA state p to have an empty context and a nonempty context is the case when closure falls off end of rule without a call stack and re-enters the rule with a context.  This resolves the issue I discussed with Sriram Srinivasan Feb 28, 2005 about not terminating fast enough upon nondeterminism.", "call_func_name": ["org.antlr.analysis.NFAContext.suffix"], "call_func_parameter": [["org.antlr.analysis.NFAContext"]], "passed_comments": [{"org.antlr.analysis.NFAContext.suffix": "[$] suffix any context [21 $] suffix [21 12 $] [21 12 $] suffix [21 $] [21 18 $] suffix [21 18 12 9 $] [21 18 12 9 $] suffix [21 18 $] [21 12 $] not suffix [21 9 $] Example \"[21 $] suffix [21 12 $]\" means: rule r invoked current rule from state 21.  Rule s invoked rule r from state 12 which then invoked current rule also via state 21.  While the context prior to state 21 is different, the fact that both contexts emanate from state 21 implies that they are now going to track perfectly together.  Once they converged on state 21, there is no way they can separate.  In other words, the prior stack state is not consulted when computing where to go in the closure operation.  ?$ and ??$ are considered the same stack. If ? is popped off then $ and ?$ remain; they are now an empty and nonempty context comparison.  So, if one stack is a suffix of another, then it will still degenerate to the simple empty stack comparison case."}]}, {"index": "358", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAContext.java", "methodName": "org.antlr.analysis.NFAContext.suffix", "methodParameterType": "NFAContext#", "methodParameterName": "other#", "methodBody": "protected boolean suffix(NFAContext other) {\n\t\tNFAContext sp = this;\n\t\t// if one of the contexts is empty, it never enters loop and returns true\n\t\twhile ( sp.parent!=null && other.parent!=null ) {\n\t\t\tif ( sp.invokingState != other.invokingState ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsp = sp.parent;\n\t\t\tother = other.parent;\n\t\t}\n\t\t//System.out.println(\"suffix\");\n\t\treturn true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#WhileStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "[$] suffix any context [21 $] suffix [21 12 $] [21 12 $] suffix [21 $] [21 18 $] suffix [21 18 12 9 $] [21 18 12 9 $] suffix [21 18 $] [21 12 $] not suffix [21 9 $] Example \"[21 $] suffix [21 12 $]\" means: rule r invoked current rule from state 21.  Rule s invoked rule r from state 12 which then invoked current rule also via state 21.  While the context prior to state 21 is different, the fact that both contexts emanate from state 21 implies that they are now going to track perfectly together.  Once they converged on state 21, there is no way they can separate.  In other words, the prior stack state is not consulted when computing where to go in the closure operation.  ?$ and ??$ are considered the same stack. If ? is popped off then $ and ?$ remain; they are now an empty and nonempty context comparison.  So, if one stack is a suffix of another, then it will still degenerate to the simple empty stack comparison case.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "359", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAContext.java", "methodName": "org.antlr.analysis.NFAContext.recursionDepthEmanatingFromState", "methodParameterType": "int#", "methodParameterName": "state#", "methodBody": "public int recursionDepthEmanatingFromState(int state) {\n\t\tNFAContext sp = this;\n\t\tint n = 0; // track recursive invocations of target from this state\n\t\t//System.out.println(\"this.context is \"+sp);\n\t\twhile ( sp.parent!=null ) {\n\t\t\tif ( sp.invokingState.stateNumber == state ) {\n\t\t\t\tn++;\n\t\t\t}\n\t\t\tsp = sp.parent;\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ThisExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ThisExpression)ThisExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given an NFA state number, how many times has the NFA-to-DFA conversion pushed that state on the stack?  In other words, the NFA state must be a rule invocation state and this method tells you how many times you've been to this state.  If none, then you have not called the target rule from this state before (though another NFA state could have called that target rule). If n=1, then you've been to this state before during this DFA construction and are going to invoke that rule again. Note that many NFA states can invoke rule r, but we ignore recursion unless you hit the same rule invocation state again.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "360", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAContext.java", "methodName": "org.antlr.analysis.NFAContext.isEmpty", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isEmpty() {\n\t\treturn parent==null;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A context is empty if there is no parent; meaning nobody pushed anything on the call stack.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "361", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/Label.java", "methodName": "org.antlr.analysis.Label.Label", "methodParameterType": "IntSet#", "methodParameterName": "labelSet#", "methodBody": "public Label(IntSet labelSet) {\n\t\tif ( labelSet==null ) {\n\t\t\tthis.label = SET;\n\t\t\tthis.labelSet = IntervalSet.of(INVALID);\n\t\t\treturn;\n\t\t}\n\t\tint singleAtom = labelSet.getSingleElement();\n        if ( singleAtom!=INVALID ) {\n            // convert back to a single atomic element if |labelSet|==1\n            label = singleAtom;\n            return;\n        }\n        this.label = SET;\n        this.labelSet = labelSet;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#ReturnStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Make a set label", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "362", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/Label.java", "methodName": "org.antlr.analysis.Label.getAtom", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getAtom() {\n        if ( isAtom() ) {\n            return label;\n        }\n        return INVALID;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return the single atom label or INVALID if not a single atom", "call_func_name": ["org.antlr.analysis.Label.isAtom"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "363", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/Label.java", "methodName": "org.antlr.analysis.Label.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "/*\n    protected boolean predicatesEquals(Set others) {\n        Iterator iter = semanticContext.iterator();\n        while (iter.hasNext()) {\n            AST predAST = (AST) iter.next();\n            Iterator inner = semanticContext.iterator();\n            while (inner.hasNext()) {\n                AST otherPredAST = (AST) inner.next();\n                if ( !predAST.getText().equals(otherPredAST.getText()) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n      */\n\n\t@Override\n    public String toString() {\n        switch (label) {\n            case SET :\n                return labelSet.toString();\n            default :\n                return String.valueOf(label);\n        }\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SwitchCase#SimpleName#SimpleName#MethodInvocation#ReturnStatement#SwitchCase#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#SwitchStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(SwitchStatement(SimpleName)SimpleName(SwitchCase(SimpleName)SimpleName)SwitchCase(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement(SwitchCase)SwitchCase(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)SwitchStatement)Block)MethodDeclaration", "methodDoc": "Predicates are lists of AST nodes from the NFA created from the grammar, but the same predicate could be cut/paste into multiple places in the grammar.  I must compare the text of all the predicates to truly answer whether {p1,p2} .equals {p1,p2}. Unfortunately, I cannot rely on the AST.equals() to work properly so I must do a brute force O(n^2) nested traversal of the Set doing a String compare. At this point, Labels are not compared for equals when they are predicates, but here's the code for future use.", "call_func_name": ["org.antlr.misc.IntSet.toString", "java.lang.String.valueOf"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "364", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.resetStateNumbersToBeContiguous", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void resetStateNumbersToBeContiguous() {\n\t\tif ( getUserMaxLookahead()>0 ) {\n\t\t\t// all numbers are unique already; no states are thrown out.\n\t\t\treturn;\n\t\t}\n\n        // walk list of DFAState objects by state number,\n\t\t// setting state numbers to 0..n-1\n\t\tint snum=0;\n\t\tfor (int i = 0; i <= getMaxStateNumber(); i++) {\n\t\t\tDFAState s = getState(i);\n            // some states are unused after creation most commonly due to cycles\n            // or conflict resolution.\n            if ( s==null ) {\n                continue;\n            }\n\t\t\t// state i is mapped to DFAState with state number set to i originally\n\t\t\t// so if it's less than i, then we renumbered it already; that\n\t\t\t// happens when states have been merged or cycles occurred I think.\n\t\t\t// states[50] will point to DFAState with s50 in it but\n\t\t\t// states[103] might also point at this same DFAState.  Since\n\t\t\t// 50 < 103 then it's already been renumbered as it points downwards.\n\t\t\tboolean alreadyRenumbered = s.stateNumber<i;\n\t\t\tif ( !alreadyRenumbered ) {\n\t\t\t\t// state i is a valid state, reset it's state number\n\t\t\t\ts.stateNumber = snum; // rewrite state numbers to be 0..n-1\n\t\t\t\tsnum++;\n\t\t\t}\n\t\t}\n        if ( snum!=getNumberOfStates() ) {\n\t\t\tErrorManager.internalError(\"DFA \"+decisionNumber+\": \"+\n\t\t\t\tdecisionNFAStartState.getDescription()+\" num unique states \"+getNumberOfStates()+\n\t\t\t\t\"!= num renumbered states \"+snum);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#SimpleName#MethodInvocation#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Walk all states and reset their numbers to be a contiguous sequence of integers starting from 0.  Only cyclic DFA can have unused positions in states list.  State i might be identical to a previous state j and will result in states[i] == states[j].  We don't want to waste a state number on this.  Useful mostly for code generation in tables. At the start of this routine, states[i].stateNumber &lt;= i by definition. If states[50].stateNumber is 50 then a cycle during conversion may try to add state 103, but we find that an identical DFA state, named 50, already exists, hence, states[103]==states[50] and both have stateNumber 50 as they point at same object.  Afterwards, the set of state numbers from all states should represent a contiguous range from 0..n-1 where n is the number of unique states.", "call_func_name": ["org.antlr.analysis.DFA.getUserMaxLookahead", "org.antlr.analysis.DFA.getMaxStateNumber", "org.antlr.analysis.DFA.getState", "org.antlr.analysis.DFA.getNumberOfStates", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.analysis.NFAState.getDescription", "java.lang.StringBuilder.toString", "org.antlr.tool.ErrorManager.internalError"], "call_func_parameter": [[""], [""], ["int"], [""], [""], ["java.lang.String"], ["int"], [""], [""], ["java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.DFA.getUserMaxLookahead": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar."}, {"org.antlr.analysis.DFA.getMaxStateNumber": "What is the max state number ever created?  This may be beyond getNumberOfStates()."}]}, {"index": "365", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getRunLengthEncoding", "methodParameterType": "List<Integer>#", "methodParameterName": "data#", "methodBody": "public List<? extends String> getRunLengthEncoding(List<Integer> data) {\n\t\tif ( data==null || data.isEmpty() ) {\n\t\t\t// for states with no transitions we want an empty string \"\"\n\t\t\t// to hold its place in the transitions array.\n\t\t\tList<String> empty = new ArrayList<String>();\n\t\t\tempty.add(\"\");\n\t\t\treturn empty;\n\t\t}\n\t\tint size = Math.max(2,data.size()/2);\n\t\tList<String> encoded = new ArrayList<String>(size); // guess at size\n\t\t// scan values looking for runs\n\t\tint i = 0;\n\t\tInteger emptyValue = Utils.integer(-1);\n\t\twhile ( i < data.size() ) {\n\t\t\tInteger I = data.get(i);\n\t\t\tif ( I==null ) {\n\t\t\t\tI = emptyValue;\n\t\t\t}\n\t\t\t// count how many v there are?\n\t\t\tint n = 0;\n\t\t\tfor (int j = i; j < data.size(); j++) {\n\t\t\t\tInteger v = data.get(j);\n\t\t\t\tif ( v==null ) {\n\t\t\t\t\tv = emptyValue;\n\t\t\t\t}\n\t\t\t\tif ( I.equals(v) ) {\n\t\t\t\t\tn++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tencoded.add(generator.target.encodeIntAsCharEscape((char)n));\n\t\t\tencoded.add(generator.target.encodeIntAsCharEscape((char)I.intValue()));\n\t\t\ti+=n;\n\t\t}\n\t\treturn encoded;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#PrefixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#PostfixExpression#ExpressionStatement#Block#BreakStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(Block(BreakStatement)BreakStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compress the incoming data list so that runs of same number are encoded as number,value pair sequences.  3 -1 -1 -1 28 is encoded as 1 3 3 -1 1 28.  I am pretty sure this is the lossless compression that GIF files use.  Transition tables are heavily compressed by this technique.  I got the idea from JFlex http://jflex.de/ Return List&lt;String&gt; where each string is either \\xyz for 8bit char and \\uFFFF for 16bit.  Hideous and specific to Java, but it is the only target bad enough to need it.", "call_func_name": ["java.util.List.isEmpty", "java.util.ArrayList.<init>", "java.util.List.add", "java.util.List.size", "java.lang.Math.max", "java.util.ArrayList.<init>", "org.antlr.misc.Utils.integer", "java.util.List.get", "java.lang.Integer.equals", "org.antlr.codegen.Target.encodeIntAsCharEscape", "java.lang.Integer.intValue"], "call_func_parameter": [[""], [""], ["java.lang.Object"], [""], ["int", "int"], ["int"], ["int"], ["int"], ["java.lang.Object"], ["int"], [""]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "366", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.createEOTAndEOFTables", "methodParameterType": "DFAState#", "methodParameterName": "s#", "methodBody": "protected void createEOTAndEOFTables(DFAState s) {\n\t\tfor (int j = 0; j < s.getNumberOfTransitions(); j++) {\n\t\t\tTransition edge = s.transition(j);\n\t\t\tLabel label = edge.label;\n\t\t\tif ( label.isAtom() ) {\n\t\t\t\tif ( label.getAtom()==Label.EOT ) {\n\t\t\t\t\t// eot[s] points to accept state\n\t\t\t\t\teot.set(s.stateNumber, Utils.integer(edge.target.stateNumber));\n\t\t\t\t}\n\t\t\t\telse if ( label.getAtom()==Label.EOF ) {\n\t\t\t\t\t// eof[s] points to accept state\n\t\t\t\t\teof.set(s.stateNumber, Utils.integer(edge.target.stateNumber));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if ( label.isSet() ) {\n\t\t\t\tIntervalSet labels = (IntervalSet)label.getSet();\n\t\t\t\tint[] atoms = labels.toArray();\n\t\t\t\tfor (int a = 0; a < atoms.length; a++) {\n\t\t\t\t\tif ( atoms[a]==Label.EOT ) {\n\t\t\t\t\t\t// eot[s] points to accept state\n\t\t\t\t\t\teot.set(s.stateNumber, Utils.integer(edge.target.stateNumber));\n\t\t\t\t\t}\n\t\t\t\t\telse if ( atoms[a]==Label.EOF ) {\n\t\t\t\t\t\teof.set(s.stateNumber, Utils.integer(edge.target.stateNumber));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#ForStatement#Block#IfStatement#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)ForStatement)Block)IfStatement)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Set up the EOT and EOF tables; we cannot put -1 min/max values so we need another way to test that in the DFA transition function.", "call_func_name": ["org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.analysis.Label.isAtom", "org.antlr.analysis.Label.getAtom", "org.antlr.misc.Utils.integer", "java.util.Vector.set", "org.antlr.analysis.Label.isSet", "org.antlr.analysis.Label.getSet", "org.antlr.misc.IntervalSet.toArray"], "call_func_parameter": [[""], ["int"], [""], [""], ["int"], ["int", "java.lang.Object"], [""], [""], [""]], "passed_comments": [{"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "367", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.addState", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected DFAState addState(DFAState d) {\n\t\tif ( getUserMaxLookahead()>0 ) {\n\t\t\treturn d;\n\t\t}\n\t\t// does a DFA state exist already with everything the same\n\t\t// except its state number?\n\t\tDFAState existing = uniqueStates.get(d);\n\t\tif ( existing != null ) {\n            /*\n            System.out.println(\"state \"+d.stateNumber+\" exists as state \"+\n                existing.stateNumber);\n                */\n            // already there...get the existing DFA state\n\t\t\treturn existing;\n\t\t}\n\n\t\t// if not there, then add new state.\n\t\tuniqueStates.put(d,d);\n        numberOfStates++;\n\t\treturn d;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Add a new DFA state to this DFA if not already present. To force an acyclic, fixed maximum depth DFA, just always return the incoming state.  By not reusing old states, no cycles can be created.  If we're doing fixed k lookahead don't updated uniqueStates, just return incoming state, which indicates it's a new state.", "call_func_name": ["org.antlr.analysis.DFA.getUserMaxLookahead", "java.util.Map.get", "java.util.Map.put"], "call_func_parameter": [[""], ["java.lang.Object"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.DFA.getUserMaxLookahead": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar."}]}, {"index": "368", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getMaxStateNumber", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getMaxStateNumber() {\n\t\treturn states.size()-1;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the max state number ever created?  This may be beyond getNumberOfStates().", "call_func_name": ["java.util.Vector.size"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "369", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.isReduced", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isReduced() {\n        return reduced;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is the DFA reduced?  I.e., does every state have a path to an accept state?  If not, don't delete as we need to generate an error indicating which paths are \"dead ends\".  Also tracks list of alts with no accept state in the DFA.  Must call verify() first before this makes sense.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "370", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.isCyclic", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isCyclic() {\n        return cyclic && getUserMaxLookahead()==0;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is this DFA cyclic?  That is, are there any loops?  If not, then the DFA is essentially an LL(k) predictor for some fixed, max k value. We can build a series of nested IF statements to match this.  In the presence of cycles, we need to build a general DFA and interpret it to distinguish between alternatives.", "call_func_name": ["org.antlr.analysis.DFA.getUserMaxLookahead"], "call_func_parameter": [[""]], "passed_comments": [{"org.antlr.analysis.DFA.getUserMaxLookahead": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar."}]}, {"index": "371", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.isTokensRuleDecision", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isTokensRuleDecision() {\n\t\tif ( nfa.grammar.type!=Grammar.LEXER ) {\n\t\t\treturn false;\n\t\t}\n\t\tNFAState nfaStart = getNFADecisionStartState();\n\t\tRule r = nfa.grammar.getLocallyDefinedRule(Grammar.ARTIFICIAL_TOKENS_RULENAME);\n\t\tNFAState TokensRuleStart = r.startState;\n\t\tNFAState TokensDecisionStart =\n\t\t\t(NFAState)TokensRuleStart.transition[0].target;\n\t\treturn nfaStart == TokensDecisionStart;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is this DFA derived from the NFA for the Tokens rule?", "call_func_name": ["org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.tool.Grammar.getLocallyDefinedRule"], "call_func_parameter": [[""], ["java.lang.String"]], "passed_comments": "/"}, {"index": "372", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getUserMaxLookahead", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getUserMaxLookahead() {\n\t\tif ( user_k>=0 ) { // cache for speed\n\t\t\treturn user_k;\n\t\t}\n\t\tuser_k = nfa.grammar.getUserMaxLookahead(decisionNumber);\n\t\treturn user_k;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar.", "call_func_name": ["org.antlr.tool.Grammar.getUserMaxLookahead"], "call_func_parameter": [["int"]], "passed_comments": "/"}, {"index": "373", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getMaxLookaheadDepth", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getMaxLookaheadDepth() {\n\t\tif ( hasCycle() ) return Integer.MAX_VALUE;\n\t\t// compute to be sure\n\t\treturn _getMaxLookaheadDepth(startState, 0);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#ReturnStatement#IfStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return k if decision is LL(k) for some k else return max int", "call_func_name": ["org.antlr.analysis.DFA.hasCycle", "org.antlr.analysis.DFA._getMaxLookaheadDepth"], "call_func_parameter": [[""], ["org.antlr.analysis.DFAState", "int"]], "passed_comments": [{"org.antlr.analysis.DFA.hasCycle": "Compute cyclic w/o relying on state computed during analysis. just check."}]}, {"index": "374", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.hasSynPred", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean hasSynPred() {\n\t\tboolean has = _hasSynPred(startState, new HashSet<DFAState>());\n//\t\tif ( !has ) {\n//\t\t\tSystem.out.println(\"no synpred in dec \"+decisionNumber);\n//\t\t\tFASerializer serializer = new FASerializer(nfa.grammar);\n//\t\t\tString result = serializer.serialize(startState);\n//\t\t\tSystem.out.println(result);\n//\t\t}\n\t\treturn has;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Count all disambiguating syn preds (ignore synpred tests for gated edges, which occur for nonambig input sequences). E.g., x  : (X)=&gt; (X|Y)\\n\" + | X\\n\" + ; gives .s0-X-&gt;.s1 .s0-Y&amp;&amp;{synpred1_t}?-&gt;:s2=&gt;1 .s1-{synpred1_t}?-&gt;:s2=&gt;1 .s1-{true}?-&gt;:s3=&gt;2", "call_func_name": ["java.util.HashSet.<init>", "org.antlr.analysis.DFA._hasSynPred"], "call_func_parameter": [[""], ["org.antlr.analysis.DFAState", "java.util.Set"]], "passed_comments": "/"}, {"index": "375", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.hasCycle", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean hasCycle() {\n\t\tboolean cyclic = _hasCycle(startState, new HashMap<DFAState, Integer>());\n\t\treturn cyclic;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute cyclic w/o relying on state computed during analysis. just check.", "call_func_name": ["java.util.HashMap.<init>", "org.antlr.analysis.DFA._hasCycle"], "call_func_parameter": [[""], ["org.antlr.analysis.DFAState", "java.util.Map"]], "passed_comments": "/"}, {"index": "376", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getUnreachableAlts", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Integer> getUnreachableAlts() {\n        return unreachableAlts;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of Integer alt numbers for which no lookahead could be computed or for which no single DFA accept state predicts those alts.  Must call verify() first before this makes sense.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "377", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.verify", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void verify() {\n\t\tdoesStateReachAcceptState(startState);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Once this DFA has been built, need to verify that: 1. it's reduced 2. all alts have an accept state Elsewhere, in the NFA converter, we need to verify that: 3. alts i and j have disjoint lookahead if no sem preds 4. if sem preds, nondeterministic alts must be sufficiently covered This is avoided if analysis bails out for any reason.", "call_func_name": ["org.antlr.analysis.DFA.doesStateReachAcceptState"], "call_func_parameter": [["org.antlr.analysis.DFAState"]], "passed_comments": [{"org.antlr.analysis.DFA.doesStateReachAcceptState": "figure out if this state eventually reaches an accept state and modify the instance variable 'reduced' to indicate if we find at least one state that cannot reach an accept state.  This implies that the overall DFA is not reduced.  This algorithm should be linear in the number of DFA states. The algorithm also tracks which alternatives have no accept state, indicating a nondeterminism. Also computes whether the DFA is cyclic. TODO: I call getUniquelyPredicatedAlt too much; cache predicted alt"}]}, {"index": "378", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.doesStateReachAcceptState", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected boolean doesStateReachAcceptState(DFAState d) {\n\t\tif ( d.isAcceptState() ) {\n            // accept states have no edges emanating from them so we can return\n            d.setAcceptStateReachable(REACHABLE_YES);\n            // this alt is uniquely predicted, remove from nondeterministic list\n            int predicts = d.getUniquelyPredictedAlt();\n            unreachableAlts.remove(Utils.integer(predicts));\n            return true;\n        }\n\n        // avoid infinite loops\n        d.setAcceptStateReachable(REACHABLE_BUSY);\n\n        boolean anEdgeReachesAcceptState = false;\n        // Visit every transition, track if at least one edge reaches stop state\n\t\t// Cannot terminate when we know this state reaches stop state since\n\t\t// all transitions must be traversed to set status of each DFA state.\n\t\tfor (int i=0; i<d.getNumberOfTransitions(); i++) {\n            Transition t = d.transition(i);\n            DFAState edgeTarget = (DFAState)t.target;\n            int targetStatus = edgeTarget.getAcceptStateReachable();\n            if ( targetStatus==REACHABLE_BUSY ) { // avoid cycles; they say nothing\n                cyclic = true;\n                continue;\n            }\n            if ( targetStatus==REACHABLE_YES ) { // avoid unnecessary work\n                anEdgeReachesAcceptState = true;\n                continue;\n            }\n            if ( targetStatus==REACHABLE_NO ) {  // avoid unnecessary work\n                continue;\n            }\n\t\t\t// target must be REACHABLE_UNKNOWN (i.e., unvisited)\n            if ( doesStateReachAcceptState(edgeTarget) ) {\n                anEdgeReachesAcceptState = true;\n                // have to keep looking so don't break loop\n                // must cover all states even if we find a path for this state\n            }\n        }\n        if ( anEdgeReachesAcceptState ) {\n            d.setAcceptStateReachable(REACHABLE_YES);\n        }\n        else {\n            d.setAcceptStateReachable(REACHABLE_NO);\n\t\t\treduced = false;\n        }\n        return anEdgeReachesAcceptState;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "figure out if this state eventually reaches an accept state and modify the instance variable 'reduced' to indicate if we find at least one state that cannot reach an accept state.  This implies that the overall DFA is not reduced.  This algorithm should be linear in the number of DFA states. The algorithm also tracks which alternatives have no accept state, indicating a nondeterminism. Also computes whether the DFA is cyclic. TODO: I call getUniquelyPredicatedAlt too much; cache predicted alt", "call_func_name": ["org.antlr.analysis.DFAState.isAcceptState", "org.antlr.analysis.DFAState.setAcceptStateReachable", "org.antlr.analysis.DFAState.getUniquelyPredictedAlt", "org.antlr.misc.Utils.integer", "java.util.List.remove", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.analysis.DFAState.getAcceptStateReachable", "org.antlr.analysis.DFA.doesStateReachAcceptState"], "call_func_parameter": [[""], ["int"], [""], ["int"], ["java.lang.Object"], [""], ["int"], [""], ["org.antlr.analysis.DFAState"]], "passed_comments": [{"org.antlr.analysis.DFAState.getUniquelyPredictedAlt": "Walk each configuration and if they are all the same alt, return that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved configurations, but don't ignore resolveWithPredicate configs because this state should not be an accept state.  We need to add this to the work list and then have semantic predicate edges emanating from it."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.analysis.DFAState.getAcceptStateReachable": "Is an accept state reachable from this state?"}, {"org.antlr.analysis.DFA.doesStateReachAcceptState": "figure out if this state eventually reaches an accept state and modify the instance variable 'reduced' to indicate if we find at least one state that cannot reach an accept state.  This implies that the overall DFA is not reduced.  This algorithm should be linear in the number of DFA states. The algorithm also tracks which alternatives have no accept state, indicating a nondeterminism. Also computes whether the DFA is cyclic. TODO: I call getUniquelyPredicatedAlt too much; cache predicted alt"}]}, {"index": "379", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.findAllGatedSynPredsUsedInDFAAcceptStates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void findAllGatedSynPredsUsedInDFAAcceptStates() {\n\t\tint nAlts = getNumberOfAlts();\n\t\tfor (int i=1; i<=nAlts; i++) {\n\t\t\tDFAState a = getAcceptState(i);\n\t\t\t//System.out.println(\"alt \"+i+\": \"+a);\n\t\t\tif ( a!=null ) {\n\t\t\t\tSet<? extends SemanticContext> synpreds = a.getGatedSyntacticPredicatesInNFAConfigurations();\n\t\t\t\tif ( synpreds!=null ) {\n\t\t\t\t\t// add all the predicates we find (should be just one, right?)\n\t\t\t\t\tfor (SemanticContext semctx : synpreds) {\n\t\t\t\t\t\t// System.out.println(\"synpreds: \"+semctx);\n\t\t\t\t\t\tnfa.grammar.synPredUsedInDFA(this, semctx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ThisExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Walk all accept states and find the manually-specified synpreds. Gated preds are not always hoisted I used to do this in the code generator, but that is too late. This converter tries to avoid computing DFA for decisions in syntactic predicates that are not ever used such as those created by autobacktrack mode.", "call_func_name": ["org.antlr.analysis.DFA.getNumberOfAlts", "org.antlr.analysis.DFA.getAcceptState", "org.antlr.analysis.DFAState.getGatedSyntacticPredicatesInNFAConfigurations", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.synPredUsedInDFA"], "call_func_parameter": [[""], ["int"], [""], [""], [""], [""], ["org.antlr.analysis.DFA", "org.antlr.analysis.SemanticContext"]], "passed_comments": "/"}, {"index": "380", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.okToRetryDFAWithK1", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean okToRetryDFAWithK1() {\n\t\tboolean nonLLStarOrOverflowAndPredicateVisible =\n\t\t\t(probe.isNonLLStarDecision()||probe.analysisOverflowed()) &&\n\t\t    predicateVisible; // auto backtrack or manual sem/syn\n\t\treturn getUserMaxLookahead()!=1 &&\n\t\t\t nonLLStarOrOverflowAndPredicateVisible;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If this DFA failed to finish during construction, we might be able to retry with k=1 but we need to know whether it will potentially succeed.  Can only succeed if there is a predicate to resolve the issue.  Don't try if k=1 already as it would cycle forever.  Timeout can retry with k=1 even if no predicate if k!=1.", "call_func_name": ["org.antlr.analysis.DecisionProbe.isNonLLStarDecision", "org.antlr.analysis.DecisionProbe.analysisOverflowed", "org.antlr.analysis.DFA.getUserMaxLookahead"], "call_func_parameter": [[""], [""], [""]], "passed_comments": [{"org.antlr.analysis.DecisionProbe.isNonLLStarDecision": "Found recursion in &gt; 1 alt"}, {"org.antlr.analysis.DecisionProbe.analysisOverflowed": "Took too long to analyze a DFA"}, {"org.antlr.analysis.DFA.getUserMaxLookahead": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar."}]}, {"index": "381", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFA.java", "methodName": "org.antlr.analysis.DFA.getDecisionASTNode", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public GrammarAST getDecisionASTNode() {\n        return decisionNFAStartState.associatedASTNode;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What GrammarAST node (derived from the grammar) is this DFA associated with?  It will point to the start of a block or the loop back of a (...)+ block etc...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "382", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.addTransition", "methodParameterType": "DFAState#Label#", "methodParameterName": "target#label#", "methodBody": "public int addTransition(DFAState target, Label label) {\n\t\ttransitions.add( new Transition(label, target) );\n\t\treturn transitions.size()-1;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Add a transition from this state to target with label.  Return the transition number from 0..n-1.", "call_func_name": ["org.antlr.analysis.Transition.<init>", "java.util.List.add", "java.util.List.size"], "call_func_parameter": [["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["java.lang.Object"], [""]], "passed_comments": "/"}, {"index": "383", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.addNFAConfiguration", "methodParameterType": "NFAState#NFAConfiguration#", "methodParameterName": "state#c#", "methodBody": "public void addNFAConfiguration(NFAState state, NFAConfiguration c) {\n\t\tif ( nfaConfigurations.contains(c) ) {\n            return;\n        }\n\n        nfaConfigurations.add(c);\n\n\t\t// track min alt rather than compute later\n\t\tif ( c.alt < minAltInConfigurations ) {\n\t\t\tminAltInConfigurations = c.alt;\n\t\t}\n\n\t\tif ( c.semanticContext!=SemanticContext.EMPTY_SEMANTIC_CONTEXT ) {\n\t\t\tatLeastOneConfigurationHasAPredicate = true;\n\t\t}\n\n\t\t// update hashCode; for some reason using context.hashCode() also\n        // makes the GC take like 70% of the CPU and is slow!\n        cachedHashCode += c.state + c.alt;\n\n\t\t// update reachableLabels\n\t\t// We're adding an NFA state; check to see if it has a non-epsilon edge\n\t\tif ( state.transition[0] != null ) {\n\t\t\tLabel label = state.transition[0].label;\n\t\t\tif ( !(label.isEpsilon()||label.isSemanticPredicate()) ) {\n\t\t\t\t// this NFA state has a non-epsilon edge, track for fast\n\t\t\t\t// walking later when we do reach on this DFA state we're\n\t\t\t\t// building.\n\t\t\t\tconfigurationsWithLabeledEdges.add(c);\n\t\t\t\tif ( state.transition[1] ==null ) {\n\t\t\t\t\t// later we can check this to ignore o-A->o states in closure\n\t\t\t\t\tc.singleAtomTransitionEmanating = true;\n\t\t\t\t}\n\t\t\t\taddReachableLabel(label);\n\t\t\t}\n\t\t}\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#ParenthesizedExpression#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)Assignment)ExpressionStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ParenthesizedExpression)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Add an NFA configuration to this DFA node.  Add uniquely an NFA state/alt/syntactic&amp;semantic context (chain of invoking state(s) and semantic predicate contexts). I don't see how there could be two configurations with same state|alt|synCtx and different semantic contexts because the semantic contexts are computed along the path to a particular state so those two configurations would have to have the same predicate. Nonetheless, the addition of configurations is unique on all configuration info.  I guess I'm saying that syntactic context implies semantic context as the latter is computed according to the former. As we add configurations to this DFA state, track the set of all possible transition labels so we can simply walk it later rather than doing a loop over all possible labels in the NFA.", "call_func_name": ["org.antlr.misc.OrderedHashSet.contains", "org.antlr.misc.OrderedHashSet.add", "org.antlr.analysis.Label.isEpsilon", "org.antlr.analysis.Label.isSemanticPredicate", "java.util.List.add", "org.antlr.analysis.DFAState.addReachableLabel"], "call_func_parameter": [["java.lang.Object"], ["java.lang.Object"], [""], [""], ["java.lang.Object"], ["org.antlr.analysis.Label"]], "passed_comments": [{"org.antlr.analysis.DFAState.addReachableLabel": "Add label uniquely and disjointly; intersection with another set or int/char forces breaking up the set(s). Example, if reachable list of labels is [a..z, {k,9}, 0..9], the disjoint list will be [{a..j,l..z}, k, 9, 0..8]. As we add NFA configurations to a DFA state, we might as well track the set of all possible transition labels to make the DFA conversion more efficient.  W/o the reachable labels, we'd need to check the whole vocabulary space (could be 0..\\uFFFF)!  The problem is that labels can be sets, which may overlap with int labels or other sets. As we need a deterministic set of transitions from any state in the DFA, we must make the reachable labels set disjoint. This operation amounts to finding the character classes for this DFA state whereas with tools like flex, that need to generate a homogeneous DFA, must compute char classes across all states. We are going to generate DFAs with heterogeneous states so we only care that the set of transitions out of a single state are unique. :) The idea for adding a new set, t, is to look for overlap with the elements of existing list s.  Upon overlap, replace existing set s[i] with two new disjoint sets, s[i]-t and s[i]&amp;t. (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is what you want to add to the set minus what was already there.  The remainder must then be compared against the i+1..n elements in s looking for another collision.  Each collision results in a smaller and smaller remainder.  Stop when you run out of s elements or remainder goes to nil.  If remainder is non nil when you run out of s elements, then add remainder to the end. Single element labels are treated as sets to make the code uniform."}]}, {"index": "384", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.addReachableLabel", "methodParameterType": "Label#", "methodParameterName": "label#", "methodBody": "protected void addReachableLabel(Label label) {\n\t\tif ( reachableLabels==null ) {\n\t\t\treachableLabels = new OrderedHashSet<Label>();\n\t\t}\n\t\t/*\n\t\tSystem.out.println(\"addReachableLabel to state \"+dfa.decisionNumber+\".\"+stateNumber+\": \"+label.getSet().toString(dfa.nfa.grammar));\n\t\tSystem.out.println(\"start of add to state \"+dfa.decisionNumber+\".\"+stateNumber+\": \" +\n\t\t\t\t\"reachableLabels=\"+reachableLabels.toString());\n\t\t\t\t*/\n\t\tif ( reachableLabels.contains(label) ) { // exact label present\n            return;\n        }\n        IntSet t = label.getSet();\n        IntSet remainder = t; // remainder starts out as whole set to add\n        int n = reachableLabels.size(); // only look at initial elements\n        // walk the existing list looking for the collision\n        for (int i=0; i<n; i++) {\n\t\t\tLabel rl = reachableLabels.get(i);\n            /*\n\t\t\tSystem.out.println(\"comparing [\"+i+\"]: \"+label.toString(dfa.nfa.grammar)+\" & \"+\n                    rl.toString(dfa.nfa.grammar)+\"=\"+\n                    intersection.toString(dfa.nfa.grammar));\n            */\n\t\t\tif ( !Label.intersect(label, rl) ) {\n                continue;\n            }\n\t\t\t//System.out.println(label+\" collides with \"+rl);\n\n\t\t\t// For any (s_i, t) with s_i&t!=nil replace with (s_i-t, s_i&t)\n            // (ignoring s_i-t if nil; don't put in list)\n\n            // Replace existing s_i with intersection since we\n            // know that will always be a non nil character class\n\t\t\tIntSet s_i = rl.getSet();\n\t\t\tIntSet intersection = s_i.and(t);\n            reachableLabels.set(i, new Label(intersection));\n\n            // Compute s_i-t to see what is in current set and not in incoming\n            IntSet existingMinusNewElements = s_i.subtract(t);\n\t\t\t//System.out.println(s_i+\"-\"+t+\"=\"+existingMinusNewElements);\n            if ( !existingMinusNewElements.isNil() ) {\n                // found a new character class, add to the end (doesn't affect\n                // outer loop duration due to n computation a priori.\n                Label newLabel = new Label(existingMinusNewElements);\n                reachableLabels.add(newLabel);\n            }\n\n\t\t\t/*\n            System.out.println(\"after collision, \" +\n                    \"reachableLabels=\"+reachableLabels.toString());\n\t\t\t\t\t*/\n\n            // anything left to add to the reachableLabels?\n            remainder = t.subtract(s_i);\n            if ( remainder.isNil() ) {\n                break; // nothing left to add to set.  done!\n            }\n\n            t = remainder;\n        }\n        if ( !remainder.isNil() ) {\n\t\t\t/*\n\t\t\tSystem.out.println(\"before add remainder to state \"+dfa.decisionNumber+\".\"+stateNumber+\": \" +\n\t\t\t\t\t\"reachableLabels=\"+reachableLabels.toString());\n\t\t\tSystem.out.println(\"remainder state \"+dfa.decisionNumber+\".\"+stateNumber+\": \"+remainder.toString(dfa.nfa.grammar));\n            */\n\t\t\tLabel newLabel = new Label(remainder);\n            reachableLabels.add(newLabel);\n        }\n\t\t/*\n\t\tSystem.out.println(\"#END of add to state \"+dfa.decisionNumber+\".\"+stateNumber+\": \" +\n\t\t\t\t\"reachableLabels=\"+reachableLabels.toString());\n\t\t\t\t*/\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#BreakStatement#Block#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(BreakStatement)BreakStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)ForStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Add label uniquely and disjointly; intersection with another set or int/char forces breaking up the set(s). Example, if reachable list of labels is [a..z, {k,9}, 0..9], the disjoint list will be [{a..j,l..z}, k, 9, 0..8]. As we add NFA configurations to a DFA state, we might as well track the set of all possible transition labels to make the DFA conversion more efficient.  W/o the reachable labels, we'd need to check the whole vocabulary space (could be 0..\\uFFFF)!  The problem is that labels can be sets, which may overlap with int labels or other sets. As we need a deterministic set of transitions from any state in the DFA, we must make the reachable labels set disjoint. This operation amounts to finding the character classes for this DFA state whereas with tools like flex, that need to generate a homogeneous DFA, must compute char classes across all states. We are going to generate DFAs with heterogeneous states so we only care that the set of transitions out of a single state are unique. :) The idea for adding a new set, t, is to look for overlap with the elements of existing list s.  Upon overlap, replace existing set s[i] with two new disjoint sets, s[i]-t and s[i]&amp;t. (if s[i]-t is nil, don't add).  The remainder is t-s[i], which is what you want to add to the set minus what was already there.  The remainder must then be compared against the i+1..n elements in s looking for another collision.  Each collision results in a smaller and smaller remainder.  Stop when you run out of s elements or remainder goes to nil.  If remainder is non nil when you run out of s elements, then add remainder to the end. Single element labels are treated as sets to make the code uniform.", "call_func_name": ["org.antlr.misc.OrderedHashSet.<init>", "org.antlr.misc.OrderedHashSet.contains", "org.antlr.analysis.Label.getSet", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.Label.intersect", "org.antlr.misc.IntSet.and", "org.antlr.analysis.Label.<init>", "org.antlr.misc.OrderedHashSet.set", "org.antlr.misc.IntSet.subtract", "org.antlr.misc.IntSet.isNil", "org.antlr.misc.OrderedHashSet.add"], "call_func_parameter": [[""], ["java.lang.Object"], [""], [""], ["int"], ["org.antlr.analysis.Label", "org.antlr.analysis.Label"], ["org.antlr.misc.IntSet"], ["org.antlr.misc.IntSet"], ["int", "java.lang.Object"], ["org.antlr.misc.IntSet"], [""], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.IntSet.and": "Return the intersection of this set with the argument, creating a new set."}]}, {"index": "385", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.hashCode", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int hashCode() {\n\t\tif ( cachedHashCode==0 ) {\n\t\t\t// LL(1) algorithm doesn't use NFA configurations, which\n\t\t\t// dynamically compute hashcode; must have something; use super\n\t\t\treturn super.hashCode();\n\t\t}\n\t\treturn cachedHashCode;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#SuperMethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(SuperMethodInvocation(SimpleName)SimpleName)SuperMethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A decent hash for a DFA state is the sum of the NFA state/alt pairs. This is used when we add DFAState objects to the DFA.states Map and when we compare DFA states.  Computed in addNFAConfiguration()", "call_func_name": ["java.lang.Object.hashCode"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "386", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.equals", "methodParameterType": "Object#", "methodParameterName": "o#", "methodBody": "@Override\n    public boolean equals(Object o) {\n\t\t// compare set of NFA configurations in this set with other\n        DFAState other = (DFAState)o;\n\t\treturn this.nfaConfigurations.equals(other.nfaConfigurations);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Two DFAStates are equal if their NFA configuration sets are the same. This method is used to see if a DFA state already exists. Because the number of alternatives and number of NFA configurations are finite, there is a finite number of DFA states that can be processed. This is necessary to show that the algorithm terminates. Cannot test the DFA state numbers here because in DFA.addState we need to know if any other state exists that has this exact set of NFA configurations.  The DFAState state number is irrelevant.", "call_func_name": ["org.antlr.misc.OrderedHashSet.equals"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "387", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getUniquelyPredictedAlt", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getUniquelyPredictedAlt() {\n\t\tif ( cachedUniquelyPredicatedAlt!=PREDICTED_ALT_UNSET ) {\n\t\t\treturn cachedUniquelyPredicatedAlt;\n\t\t}\n        int alt = NFA.INVALID_ALT_NUMBER;\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\t// ignore anything we resolved; predicates will still result\n\t\t\t// in transitions out of this state, so must count those\n\t\t\t// configurations; i.e., don't ignore resolveWithPredicate configs\n\t\t\tif ( configuration.resolved ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( alt==NFA.INVALID_ALT_NUMBER ) {\n\t\t\t\talt = configuration.alt; // found first nonresolved alt\n\t\t\t}\n\t\t\telse if ( configuration.alt!=alt ) {\n\t\t\t\treturn NFA.INVALID_ALT_NUMBER;\n\t\t\t}\n\t\t}\n\t\tthis.cachedUniquelyPredicatedAlt = alt;\n        return alt;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#IfStatement#Block#ForStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement)IfStatement)Block)ForStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Walk each configuration and if they are all the same alt, return that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved configurations, but don't ignore resolveWithPredicate configs because this state should not be an accept state.  We need to add this to the work list and then have semantic predicate edges emanating from it.", "call_func_name": ["org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "388", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getUniqueAlt", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getUniqueAlt() {\n\t\tint alt = NFA.INVALID_ALT_NUMBER;\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\tif ( alt==NFA.INVALID_ALT_NUMBER ) {\n\t\t\t\talt = configuration.alt; // found first alt\n\t\t\t}\n\t\t\telse if ( configuration.alt!=alt ) {\n\t\t\t\treturn NFA.INVALID_ALT_NUMBER;\n\t\t\t}\n\t\t}\n\t\treturn alt;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the uniquely mentioned alt from the NFA configurations; Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER if there is more than one alt mentioned.", "call_func_name": ["org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "389", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getDisabledAlternatives", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<Integer> getDisabledAlternatives() {\n\t\tSet<Integer> disabled = new LinkedHashSet<Integer>();\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\tif ( configuration.resolved ) {\n\t\t\t\tdisabled.add(Utils.integer(configuration.alt));\n\t\t\t}\n\t\t}\n\t\treturn disabled;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "When more than one alternative can match the same input, the first alternative is chosen to resolve the conflict.  The other alts are \"turned off\" by setting the \"resolved\" flag in the NFA configurations.  Return the set of disabled alternatives.  For a : A | A | A ; this method returns {2,3} as disabled.  This does not mean that the alternative is totally unreachable, it just means that for this DFA state, that alt is disabled.  There may be other accept states for that alt.", "call_func_name": ["java.util.LinkedHashSet.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.misc.Utils.integer", "java.util.Set.add"], "call_func_parameter": [[""], [""], ["int"], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "390", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getConflictingAlts", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected Set<Integer> getConflictingAlts() {\n\t\t// TODO this is called multiple times: cache result?\n\t\t//System.out.println(\"getNondetAlts for DFA state \"+stateNumber);\n \t\tSet<Integer> nondeterministicAlts = new HashSet<Integer>();\n\n\t\t// If only 1 NFA conf then no way it can be nondeterministic;\n\t\t// save the overhead.  There are many o-a->o NFA transitions\n\t\t// and so we save a hash map and iterator creation for each\n\t\t// state.\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tif ( numConfigs <=1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// First get a list of configurations for each state.\n\t\t// Most of the time, each state will have one associated configuration.\n\t\tMultiMap<Integer, NFAConfiguration> stateToConfigListMap =\n\t\t\tnew MultiMap<Integer, NFAConfiguration>();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\tInteger stateI = Utils.integer(configuration.state);\n\t\t\tstateToConfigListMap.map(stateI, configuration);\n\t\t}\n\t\t// potential conflicts are states with > 1 configuration and diff alts\n\t\tSet<Integer> states = stateToConfigListMap.keySet();\n\t\tint numPotentialConflicts = 0;\n\t\tfor (Integer stateI : states) {\n\t\t\tboolean thisStateHasPotentialProblem = false;\n\t\t\tList<NFAConfiguration> configsForState = stateToConfigListMap.get(stateI);\n\t\t\tint alt=0;\n\t\t\tint numConfigsForState = configsForState.size();\n\t\t\tfor (int i = 0; i < numConfigsForState && numConfigsForState>1 ; i++) {\n\t\t\t\tNFAConfiguration c = configsForState.get(i);\n\t\t\t\tif ( alt==0 ) {\n\t\t\t\t\talt = c.alt;\n\t\t\t\t}\n\t\t\t\telse if ( c.alt!=alt ) {\n\t\t\t\t\t/*\n\t\t\t\t\tSystem.out.println(\"potential conflict in state \"+stateI+\n\t\t\t\t\t\t\t\t\t   \" configs: \"+configsForState);\n\t\t\t\t\t*/\n\t\t\t\t\t// 11/28/2005: don't report closures that pinch back\n\t\t\t\t\t// together in Tokens rule.  We want to silently resolve\n\t\t\t\t\t// to the first token definition ala lex/flex by ignoring\n\t\t\t\t\t// these conflicts.\n\t\t\t\t\t// Also this ensures that lexers look for more and more\n\t\t\t\t\t// characters (longest match) before resorting to predicates.\n\t\t\t\t\t// TestSemanticPredicates.testLexerMatchesLongestThenTestPred()\n\t\t\t\t\t// for example would terminate at state s1 and test predicate\n\t\t\t\t\t// meaning input \"ab\" would test preds to decide what to\n\t\t\t\t\t// do but it should match rule C w/o testing preds.\n\t\t\t\t\tif ( dfa.nfa.grammar.type!=Grammar.LEXER ||\n\t\t\t\t\t\t !dfa.decisionNFAStartState.enclosingRule.name.equals(Grammar.ARTIFICIAL_TOKENS_RULENAME) )\n\t\t\t\t\t{\n\t\t\t\t\t\tnumPotentialConflicts++;\n\t\t\t\t\t\tthisStateHasPotentialProblem = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !thisStateHasPotentialProblem ) {\n\t\t\t\t// remove NFA state's configurations from\n\t\t\t\t// further checking; no issues with it\n\t\t\t\t// (can't remove as it's concurrent modification; set to null)\n\t\t\t\tstateToConfigListMap.put(stateI, null);\n\t\t\t}\n\t\t}\n\n\t\t// a fast check for potential issues; most states have none\n\t\tif ( numPotentialConflicts==0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// we have a potential problem, so now go through config lists again\n\t\t// looking for different alts (only states with potential issues\n\t\t// are left in the states set).  Now we will check context.\n\t\t// For example, the list of configs for NFA state 3 in some DFA\n\t\t// state might be:\n\t\t//   [3|2|[28 18 $], 3|1|[28 $], 3|1, 3|2]\n\t\t// I want to create a map from context to alts looking for overlap:\n\t\t//   [28 18 $] -> 2\n\t\t//   [28 $] -> 1\n\t\t//   [$] -> 1,2\n\t\t// Indeed a conflict exists as same state 3, same context [$], predicts\n\t\t// alts 1 and 2.\n\t\t// walk each state with potential conflicting configurations\n\t\tfor (Integer stateI : states) {\n\t\t\tList<NFAConfiguration> configsForState = stateToConfigListMap.get(stateI);\n\t\t\t// compare each configuration pair s, t to ensure:\n\t\t\t// s.ctx different than t.ctx if s.alt != t.alt\n\t\t\tint numConfigsForState = 0;\n\t\t\tif ( configsForState!=null ) {\n\t\t\t\tnumConfigsForState = configsForState.size();\n\t\t\t}\n\t\t\tfor (int i = 0; i < numConfigsForState; i++) {\n\t\t\t\tNFAConfiguration s = configsForState.get(i);\n\t\t\t\tfor (int j = i+1; j < numConfigsForState; j++) {\n\t\t\t\t\tNFAConfiguration t = configsForState.get(j);\n\t\t\t\t\t// conflicts means s.ctx==t.ctx or s.ctx is a stack\n\t\t\t\t\t// suffix of t.ctx or vice versa (if alts differ).\n\t\t\t\t\t// Also a conflict if s.ctx or t.ctx is empty\n\t\t\t\t\tif ( s.alt != t.alt && s.context.conflictsWith(t.context) ) {\n\t\t\t\t\t\tnondeterministicAlts.add(Utils.integer(s.alt));\n\t\t\t\t\t\tnondeterministicAlts.add(Utils.integer(t.alt));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( nondeterministicAlts.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n        return nondeterministicAlts;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#IfStatement#Block#ForStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#ForStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PrefixExpression(MethodInvocation(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)IfStatement)Block)ForStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)ForStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Walk each NFA configuration in this DFA state looking for a conflict where (s|i|ctx) and (s|j|ctx) exist, indicating that state s with context conflicting ctx predicts alts i and j.  Return an Integer set of the alternative numbers that conflict.  Two contexts conflict if they are equal or one is a stack suffix of the other or one is the empty context. Use a hash table to record the lists of configs for each state as they are encountered.  We need only consider states for which there is more than one configuration.  The configurations' predicted alt must be different or must have different contexts to avoid a conflict. Don't report conflicts for DFA states that have conflicting Tokens rule NFA states; they will be resolved in favor of the first rule.", "call_func_name": ["java.util.HashSet.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.MultiMap.<init>", "org.antlr.misc.OrderedHashSet.get", "org.antlr.misc.Utils.integer", "org.antlr.misc.MultiMap.map", "org.antlr.misc.MultiMap.keySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.misc.MultiMap.get", "java.util.List.size", "java.util.List.get", "java.lang.String.equals", "org.antlr.misc.MultiMap.put", "org.antlr.analysis.NFAContext.conflictsWith", "java.util.Set.add", "java.util.Set.isEmpty"], "call_func_parameter": [[""], [""], [""], ["int"], ["int"], ["java.lang.Object", "java.lang.Object"], [""], [""], [""], [""], ["java.lang.Object"], [""], ["int"], ["java.lang.Object"], ["java.lang.Object", "java.lang.Object"], ["org.antlr.analysis.NFAContext"], ["java.lang.Object"], [""]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.analysis.NFAContext.conflictsWith": "Two contexts conflict() if they are equals() or one is a stack suffix of the other.  For example, contexts [21 12 $] and [21 9 $] do not conflict, but [21 $] and [21 12 $] do conflict.  Note that I should probably not show the $ in this case.  There is a dummy node for each stack that just means empty; $ is a marker that's all. This is used in relation to checking conflicts associated with a single NFA state's configurations within a single DFA state. If there are configurations s and t within a DFA state such that s.state=t.state &amp;&amp; s.alt != t.alt &amp;&amp; s.ctx conflicts t.ctx then the DFA state predicts more than a single alt--it's nondeterministic. Two contexts conflict if they are the same or if one is a suffix of the other. When comparing contexts, if one context has a stack and the other does not then they should be considered the same context.  The only way for an NFA state p to have an empty context and a nonempty context is the case when closure falls off end of rule without a call stack and re-enters the rule with a context.  This resolves the issue I discussed with Sriram Srinivasan Feb 28, 2005 about not terminating fast enough upon nondeterminism."}]}, {"index": "391", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getAltSet", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<Integer> getAltSet() {\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tSet<Integer> alts = new HashSet<Integer>();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\talts.add(Utils.integer(configuration.alt));\n\t\t}\n\t\tif ( alts.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn alts;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the set of all alts mentioned by all NFA configurations in this DFA state.", "call_func_name": ["org.antlr.misc.OrderedHashSet.size", "java.util.HashSet.<init>", "org.antlr.misc.OrderedHashSet.get", "org.antlr.misc.Utils.integer", "java.util.Set.add", "java.util.Set.isEmpty"], "call_func_parameter": [[""], [""], ["int"], ["int"], ["java.lang.Object"], [""]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "392", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public SemanticContext getGatedPredicatesInNFAConfigurations() {\n\t\tSemanticContext unionOfPredicatesFromAllAlts = null;\n\t\tint numConfigs = nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\tSemanticContext gatedPredExpr =\n\t\t\t\tconfiguration.semanticContext.getGatedPredicateContext();\n\t\t\tif ( gatedPredExpr==null ) {\n\t\t\t\t// if we ever find a configuration w/o a gated predicate\n\t\t\t\t// (even if it's a nongated predicate), we cannot gate\n\t\t\t\t// the indident edges.\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\telse if ( acceptState || !configuration.semanticContext.isSyntacticPredicate() ) {\n\t\t\t\t// at this point we have a gated predicate and, due to elseif,\n\t\t\t\t// we know it's an accept or not a syn pred.  In this case,\n\t\t\t\t// it's safe to add the gated predicate to the union.  We\n\t\t\t\t// only want to add syn preds if it's an accept state.  Other\n\t\t\t\t// gated preds can be used with edges leading to accept states.\n\t\t\t\tif ( unionOfPredicatesFromAllAlts==null ) {\n\t\t\t\t\tunionOfPredicatesFromAllAlts = gatedPredExpr;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tunionOfPredicatesFromAllAlts =\n\t\t\t\t\t\tSemanticContext.or(unionOfPredicatesFromAllAlts,gatedPredExpr);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( unionOfPredicatesFromAllAlts instanceof SemanticContext.TruePredicate ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn unionOfPredicatesFromAllAlts;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#InstanceofExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)PrefixExpression)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)IfStatement)Block)ForStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType)InstanceofExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For gated productions, we need an OR'd list of all predicates for the target of an edge so we can gate the edge based upon the predicates associated with taking that path (if any). For syntactic predicates, we only want to generate predicate evaluations as it transitions to an accept state; waste to do it earlier.  So, only add gated preds derived from manually- specified syntactic predicates if this is an accept state. Also, since configurations w/o gated predicates are like true gated predicates, finding a configuration whose alt has no gated predicate implies we should evaluate the predicate to true. This means the whole edge has to be ungated. Consider: X : ('a' | {p}?=&gt; 'a') | 'a' 'b' ; Here, you 'a' gets you from s0 to s1 but you can't test p because plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't test p.  Even on the edge going to accept state for alt 1 of X, you can't test p.  You can get to the same place with and w/o the context. Therefore, it is never ok to test p in this situation.  TODO: cache this as it's called a lot; or at least set bit if &gt;1 present in state", "call_func_name": ["org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.SemanticContext.getGatedPredicateContext", "org.antlr.analysis.SemanticContext.isSyntacticPredicate", "org.antlr.analysis.SemanticContext.or"], "call_func_parameter": [[""], ["int"], [""], [""], ["org.antlr.analysis.SemanticContext", "org.antlr.analysis.SemanticContext"]], "passed_comments": [{"org.antlr.analysis.SemanticContext.getGatedPredicateContext": "Given a semantic context expression tree, return a tree with all nongated predicates set to true and then reduced.  So p&amp;&amp;(q||r) would return p&amp;&amp;r if q is nongated but p and r are gated."}]}, {"index": "393", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.getAcceptStateReachable", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getAcceptStateReachable() {\n        return acceptStateReachable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is an accept state reachable from this state?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "394", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DFAState.java", "methodName": "org.antlr.analysis.DFAState.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public String toString() {\n        StringBuilder buf = new StringBuilder();\n        buf.append(stateNumber).append(\":{\");\n\t\tfor (int i = 0; i < nfaConfigurations.size(); i++) {\n\t\t\tNFAConfiguration configuration = nfaConfigurations.get(i);\n\t\t\tif ( i>0 ) {\n\t\t\t\tbuf.append(\", \");\n\t\t\t}\n\t\t\tbuf.append(configuration);\n\t\t}\n        buf.append(\"}\");\n        return buf.toString();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Print all NFA states plus what alts they predict", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["int"], ["java.lang.String"], [""], ["int"], ["java.lang.Object"], [""]], "passed_comments": "/"}, {"index": "395", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAConfiguration.java", "methodName": "org.antlr.analysis.NFAConfiguration.equals", "methodParameterType": "Object#", "methodParameterName": "o#", "methodBody": "@Override\n    public boolean equals(Object o) {\n\t\tif ( o==null ) {\n\t\t\treturn false;\n\t\t}\n        NFAConfiguration other = (NFAConfiguration)o;\n        return this.state==other.state &&\n               this.alt==other.alt &&\n               this.context.equals(other.context)&&\n               this.semanticContext.equals(other.semanticContext);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(InfixExpression(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "An NFA configuration is equal to another if both have the same state, the predict the same alternative, and syntactic/semantic contexts are the same.  I don't think the state|alt|ctx could be the same and have two different semantic contexts, but might as well define equals to be everything.", "call_func_name": ["org.antlr.analysis.NFAContext.equals", "java.lang.Object.equals"], "call_func_parameter": [["java.lang.Object"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.NFAContext.equals": "Two contexts are equals() if both have same call stack; walk upwards to the root. Recall that the root sentinel node has no invokingStates and no parent. Note that you may be comparing contexts in different alt trees. The hashCode is now cheap as it's computed once upon each context push on the stack.  Use it to make equals() more efficient."}]}, {"index": "396", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.computeStartState", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected DFAState computeStartState() {\n\t\tNFAState alt = dfa.decisionNFAStartState;\n\t\tDFAState startState = dfa.newState();\n\t\tcomputingStartState = true;\n\t\tint i = 0;\n\t\tint altNum = 1;\n\t\twhile ( alt!=null ) {\n\t\t\t// find the set of NFA states reachable without consuming\n\t\t\t// any input symbols for each alt.  Keep adding to same\n\t\t\t// overall closure that will represent the DFA start state,\n\t\t\t// but track the alt number\n\t\t\tNFAContext initialContext = contextTrees[i];\n\t\t\t// if first alt is derived from loopback/exit branch of loop,\n\t\t\t// make alt=n+1 for n alts instead of 1\n\t\t\tif ( i==0 &&\n\t\t\t\t dfa.getNFADecisionStartState().decisionStateType==NFAState.LOOPBACK )\n\t\t\t{\n\t\t\t\tint numAltsIncludingExitBranch = dfa.nfa.grammar\n\t\t\t\t\t.getNumberOfAltsForDecisionNFA(dfa.decisionNFAStartState);\n\t\t\t\taltNum = numAltsIncludingExitBranch;\n\t\t\t\tclosure((NFAState)alt.transition[0].target,\n\t\t\t\t\t\taltNum,\n\t\t\t\t\t\tinitialContext,\n\t\t\t\t\t\tSemanticContext.EMPTY_SEMANTIC_CONTEXT,\n\t\t\t\t\t\tstartState,\n\t\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t\taltNum = 1; // make next alt the first\n\t\t\t}\n\t\t\telse {\n\t\t\t\tclosure((NFAState)alt.transition[0].target,\n\t\t\t\t\t\taltNum,\n\t\t\t\t\t\tinitialContext,\n\t\t\t\t\t\tSemanticContext.EMPTY_SEMANTIC_CONTEXT,\n\t\t\t\t\t\tstartState,\n\t\t\t\t\t\ttrue\n\t\t\t\t);\n\t\t\t\taltNum++;\n\t\t\t}\n\t\t\ti++;\n\n\t\t\t// move to next alternative\n\t\t\tif ( alt.transition[1] ==null ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\talt = (NFAState)alt.transition[1].target;\n\t\t}\n\n\t\t// now DFA start state has the complete closure for the decision\n\t\t// but we have tracked which alt is associated with which\n\t\t// NFA states.\n\t\tdfa.addState(startState); // make sure dfa knows about this state\n\t\twork.add(startState);\n\t\tcomputingStartState = false;\n\t\treturn startState;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#BreakStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(BreakStatement)BreakStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)Assignment)ExpressionStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From this first NFA state of a decision, create a DFA. Walk each alt in decision and compute closure from the start of that rule, making sure that the closure does not include other alts within that same decision.  The idea is to associate a specific alt number with the starting closure so we can trace the alt number for all states derived from this.  At a stop state in the DFA, we can return this alt number, indicating which alt is predicted. If this DFA is derived from an loop back NFA state, then the first transition is actually the exit branch of the loop.  Rather than make this alternative one, let's make this alt n+1 where n is the number of alts in this block.  This is nice to keep the alts of the block 1..n; helps with error messages. I handle nongreedy in findNewDFAStatesAndAddDFATransitions when nongreedy and EOT transition.  Make state with EOT emanating from it the accept state.", "call_func_name": ["org.antlr.analysis.DFA.newState", "org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA", "org.antlr.analysis.NFAToDFAConverter.closure", "org.antlr.analysis.DFA.addState", "java.util.List.add"], "call_func_parameter": [[""], [""], ["org.antlr.analysis.NFAState"], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext", "org.antlr.analysis.DFAState", "boolean"], ["org.antlr.analysis.DFAState"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision."}, {"org.antlr.analysis.NFAToDFAConverter.closure": "Where can we get from NFA state p traversing only epsilon transitions? Add new NFA states + context to DFA state d.  Also add semantic predicates to semantic context if collectPredicates is set.  We only collect predicates at hoisting depth 0, meaning before any token/char have been recognized.  This corresponds, during analysis, to the initial DFA start state construction closure() invocation. There are four cases of interest (the last being the usual transition): 1. Traverse an edge that takes us to the start state of another rule, r.  We must push this state so that if the DFA conversion hits the end of rule r, then it knows to continue the conversion at state following state that \"invoked\" r. By construction, there is a single transition emanating from a rule ref node. 2. Reach an NFA state associated with the end of a rule, r, in the grammar from which it was built.  We must add an implicit (i.e., don't actually add an epsilon transition) epsilon transition from r's end state to the NFA state following the NFA state that transitioned to rule r's start state.  Because there are many states that could reach r, the context for a rule invocation is part of a call tree not a simple stack.  When we fall off end of rule, \"pop\" a state off the call tree and add that state's \"following\" node to d's NFA configuration list.  The context for this new addition will be the new \"stack top\" in the call tree. 3. Like case 2, we reach an NFA state associated with the end of a rule, r, in the grammar from which NFA was built.  In this case, however, we realize that during this NFA&rarr;DFA conversion, no state invoked the current rule's NFA.  There is no choice but to add all NFA states that follow references to r's start state.  This is analogous to computing the FOLLOW(r) in the LL(k) world.  By construction, even rule stop state has a chain of nodes emanating from it that points to every possible following node.  This case is conveniently handled then by the 4th case. 4. Normal case.  If p can reach another NFA state q, then add q to d's configuration list, copying p's context for q's context. If there is a semantic predicate on the transition, then AND it with any existing semantic context. Current state p is always added to d's configuration list as it's part of the closure as well. When is a closure operation in a cycle condition?  While it is very possible to have the same NFA state mentioned twice within the same DFA state, there are two situations that would lead to nontermination of closure operation: o   Whenever closure reaches a configuration where the same state with same or a suffix context already exists.  This catches the IF-THEN-ELSE tail recursion cycle and things like a : A a | B ; the context will be $ (empty stack). We have to check larger context stacks because of (...)+ loops.  For example, the context of a (...)+ can be nonempty if the surrounding rule is invoked by another rule: a : b A | X ; b : (B|)+ ;  // nondeterministic by the way The context of the (B|)+ loop is \"invoked from item a : . b A ;\" and then the empty alt of the loop can reach back to itself.  The context stack will have one \"return address\" element and so we must check for same state, same context for arbitrary context stacks. Idea: If we've seen this configuration before during closure, stop. We also need to avoid reaching same state with conflicting context. Ultimately analysis would stop and we'd find the conflict, but we should stop the computation.  Previously I only checked for exact config.  Need to check for same state, suffix context not just exact context. o   Whenever closure reaches a configuration where state p is present in its own context stack.  This means that p is a rule invocation state and the target rule has been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS (See the comment there also) determines how many times it's possible to recurse; clearly we cannot recurse forever. Some grammars such as the following actually require at least one recursive call to correctly compute the lookahead: a : L ID R | b ; b : ID | L a R ; Input L ID R is ambiguous but to figure this out, ANTLR needs to go a-&gt;b-&gt;a-&gt;b to find the L ID sequence. Do not allow closure to add a configuration that would allow too much recursion. This case also catches infinite left recursion."}, {"org.antlr.analysis.DFA.addState": "Add a new DFA state to this DFA if not already present. To force an acyclic, fixed maximum depth DFA, just always return the incoming state.  By not reusing old states, no cycles can be created.  If we're doing fixed k lookahead don't updated uniqueStates, just return incoming state, which indicates it's a new state."}]}, {"index": "397", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.findNewDFAStatesAndAddDFATransitions", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected void findNewDFAStatesAndAddDFATransitions(DFAState d) {\n\t\t//System.out.println(\"work on DFA state \"+d);\n\t\tOrderedHashSet<Label> labels = d.getReachableLabels();\n\t\t//System.out.println(\"reachable labels=\"+labels);\n\n\t\t/*\n\t\tSystem.out.println(\"|reachable|/|nfaconfigs|=\"+\n\t\t\t\tlabels.size()+\"/\"+d.getNFAConfigurations().size()+\"=\"+\n\t\t\t\tlabels.size()/(float)d.getNFAConfigurations().size());\n\t\t*/\n\n\t\t// normally EOT is the \"default\" clause and decisions just\n\t\t// choose that last clause when nothing else matches.  DFA conversion\n\t\t// continues searching for a unique sequence that predicts the\n\t\t// various alts or until it finds EOT.  So this rule\n\t\t//\n\t\t// DUH : ('x'|'y')* \"xy!\";\n\t\t//\n\t\t// does not need a greedy indicator.  The following rule works fine too\n\t\t//\n\t\t// A : ('x')+ ;\n\t\t//\n\t\t// When the follow branch could match what is in the loop, by default,\n\t\t// the nondeterminism is resolved in favor of the loop.  You don't\n\t\t// get a warning because the only way to get this condition is if\n\t\t// the DFA conversion hits the end of the token.  In that case,\n\t\t// we're not *sure* what will happen next, but it could be anything.\n\t\t// Anyway, EOT is the default case which means it will never be matched\n\t\t// as resolution goes to the lowest alt number.  Exit branches are\n\t\t// always alt n+1 for n alts in a block.\n\t\t//\n\t\t// When a loop is nongreedy and we find an EOT transition, the DFA\n\t\t// state should become an accept state, predicting exit of loop.  It's\n\t\t// just reversing the resolution of ambiguity.\n\t\t// TODO: should this be done in the resolveAmbig method?\n\t\tLabel EOTLabel = new Label(Label.EOT);\n\t\tboolean containsEOT = labels!=null && labels.contains(EOTLabel);\n\t\tif ( !dfa.isGreedy() && containsEOT ) {\n\t\t\tconvertToEOTAcceptState(d);\n\t\t\treturn; // no more work to do on this accept state\n\t\t}\n\n\t\t// if in filter mode for lexer, want to match shortest not longest\n\t\t// string so if we see an EOT edge emanating from this state, then\n\t\t// convert this state to an accept state.  This only counts for\n\t\t// The Tokens rule as all other decisions must continue to look for\n\t\t// longest match.\n\t\t// [Taking back out a few days later on Jan 17, 2006.  This could\n\t\t//  be an option for the future, but this was wrong soluion for\n\t\t//  filtering.]\n\t\t/*\n\t\tif ( dfa.nfa.grammar.type==Grammar.LEXER && containsEOT ) {\n\t\t\tString filterOption = (String)dfa.nfa.grammar.getOption(\"filter\");\n\t\t\tboolean filterMode = filterOption!=null && filterOption.equals(\"true\");\n\t\t\tif ( filterMode && d.dfa.isTokensRuleDecision() ) {\n\t\t\t\tDFAState t = reach(d, EOTLabel);\n\t\t\t\tif ( t.getNFAConfigurations().size()>0 ) {\n\t\t\t\t\tconvertToEOTAcceptState(d);\n\t\t\t\t\t//System.out.println(\"state \"+d+\" has EOT target \"+t.stateNumber);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n\n\t\tint numberOfEdgesEmanating = 0;\n\t\tMap<Integer, Transition> targetToLabelMap = new HashMap<Integer, Transition>();\n\t\t// for each label that could possibly emanate from NFAStates of d\n\t\tint numLabels = 0;\n\t\tif ( labels!=null ) {\n\t\t\tnumLabels = labels.size();\n\t\t}\n\t\tfor (int i=0; i<numLabels; i++) {\n\t\t\tLabel label = labels.get(i);\n\t\t\tDFAState t = reach(d, label);\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"DFA state after reach \"+label+\" \"+d+\"-\" +\n\t\t\t\t\t\t\t\t   label.toString(dfa.nfa.grammar)+\"->\"+t);\n\t\t\t}\n\t\t\tif ( t==null ) {\n\t\t\t\t// nothing was reached by label due to conflict resolution\n\t\t\t\t// EOT also seems to be in here occasionally probably due\n\t\t\t\t// to an end-of-rule state seeing it even though we'll pop\n\t\t\t\t// an invoking state off the state; don't bother to conflict\n\t\t\t\t// as this labels set is a covering approximation only.\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t//System.out.println(\"dfa.k=\"+dfa.getUserMaxLookahead());\n\t\t\tif ( t.getUniqueAlt()==NFA.INVALID_ALT_NUMBER ) {\n\t\t\t\t// Only compute closure if a unique alt number is not known.\n\t\t\t\t// If a unique alternative is mentioned among all NFA\n\t\t\t\t// configurations then there is no possibility of needing to look\n\t\t\t\t// beyond this state; also no possibility of a nondeterminism.\n\t\t\t\t// This optimization May 22, 2006 just dropped -Xint time\n\t\t\t\t// for analysis of Java grammar from 11.5s to 2s!  Wow.\n\t\t\t\tclosure(t);  // add any NFA states reachable via epsilon\n\t\t\t}\n\n\t\t\t/*\n\t\t\tSystem.out.println(\"DFA state after closure \"+d+\"-\"+\n\t\t\t\t\t\t\t   label.toString(dfa.nfa.grammar)+\n\t\t\t\t\t\t\t   \"->\"+t);\n\t\t\t\t\t\t\t   */\n\n\t\t\t// add if not in DFA yet and then make d-label->t\n\t\t\tDFAState targetState = addDFAStateToWorkList(t);\n\n\t\t\tnumberOfEdgesEmanating +=\n\t\t\t\taddTransition(d, label, targetState, targetToLabelMap);\n\n\t\t\t// lookahead of target must be one larger than d's k\n\t\t\t// We are possibly setting the depth of a pre-existing state\n\t\t\t// that is equal to one we just computed...not sure if that's\n\t\t\t// ok.\n\t\t\ttargetState.setLookaheadDepth(d.getLookaheadDepth() + 1);\n\t\t}\n\n\t\t//System.out.println(\"DFA after reach / closures:\\n\"+dfa);\n\t\tif ( !d.isResolvedWithPredicates() && numberOfEdgesEmanating==0 ) {\n\t\t\t//System.out.println(\"dangling DFA state \"+d+\"\\nAfter reach / closures:\\n\"+dfa);\n\t\t\t// TODO: can fixed lookahead hit a dangling state case?\n\t\t\t// TODO: yes, with left recursion\n\t\t\t//System.err.println(\"dangling state alts: \"+d.getAltSet());\n\t\t\tdfa.probe.reportDanglingState(d);\n\t\t\t// turn off all configurations except for those associated with\n\t\t\t// min alt number; somebody has to win else some input will not\n\t\t\t// predict any alt.\n\t\t\tint minAlt = resolveByPickingMinAlt(d, null);\n\t\t\t// force it to be an accept state\n\t\t\t// don't call convertToAcceptState() which merges stop states.\n\t\t\t// other states point at us; don't want them pointing to dead states\n\t\t\td.setAcceptState(true); // might be adding new accept state for alt\n\t\t\tdfa.setAcceptState(minAlt, d);\n\t\t\t//convertToAcceptState(d, minAlt); // force it to be an accept state\n\t\t}\n\n\t\t// Check to see if we need to add any semantic predicate transitions\n\t\t// might have both token and predicated edges from d\n\t\tif ( d.isResolvedWithPredicates() ) {\n\t\t\taddPredicateTransitions(d);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)ForStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "From this node, add a d--a--&gt;t transition for all labels 'a' where t is a DFA node created from the set of NFA states reachable from any NFA state in DFA state d.", "call_func_name": ["org.antlr.analysis.DFAState.getReachableLabels", "org.antlr.analysis.Label.<init>", "org.antlr.misc.OrderedHashSet.contains", "org.antlr.analysis.DFA.isGreedy", "org.antlr.analysis.NFAToDFAConverter.convertToEOTAcceptState", "java.util.HashMap.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.NFAToDFAConverter.reach", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.analysis.Label.toString", "java.lang.StringBuilder.toString", "java.io.PrintStream.println", "org.antlr.analysis.DFAState.getUniqueAlt", "org.antlr.analysis.NFAToDFAConverter.closure", "org.antlr.analysis.NFAToDFAConverter.addDFAStateToWorkList", "org.antlr.analysis.NFAToDFAConverter.addTransition", "org.antlr.analysis.DFAState.getLookaheadDepth", "org.antlr.analysis.DFAState.setLookaheadDepth", "org.antlr.analysis.DFAState.isResolvedWithPredicates", "org.antlr.analysis.DecisionProbe.reportDanglingState", "org.antlr.analysis.NFAToDFAConverter.resolveByPickingMinAlt", "org.antlr.analysis.DFAState.setAcceptState", "org.antlr.analysis.DFA.setAcceptState", "org.antlr.analysis.NFAToDFAConverter.addPredicateTransitions"], "call_func_parameter": [[""], ["int"], ["java.lang.Object"], [""], ["org.antlr.analysis.DFAState"], [""], [""], ["int"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.Label"], [""], ["java.lang.String"], ["java.lang.Object"], ["org.antlr.tool.Grammar"], [""], ["java.lang.String"], [""], ["org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.Label", "org.antlr.analysis.DFAState", "java.util.Map"], [""], ["int"], [""], ["org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState", "java.util.Set"], ["boolean"], ["int", "org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.convertToEOTAcceptState": "Walk the configurations of this DFA state d looking for the configuration, c, that has a transition on EOT.  State d should be converted to an accept state predicting the c.alt.  Blast d's current configuration set and make it just have config c. TODO: can there be more than one config with EOT transition? That would mean that two NFA configurations could reach the end of the token with possibly different predicted alts. Seems like that would be rare or impossible.  Perhaps convert this routine to find all such configs and give error if &gt;1."}, {"org.antlr.analysis.NFAToDFAConverter.reach": "Given the set of NFA states in DFA state d, find all NFA states reachable traversing label arcs.  By definition, there can be only one DFA state reachable by an atom from DFA state d so we must find and merge all NFA states reachable via label.  Return a new DFAState that has all of those NFA states with their context (i.e., which alt do they predict and where to return to if they fall off end of a rule). Because we cannot jump to another rule nor fall off the end of a rule via a non-epsilon transition, NFA states reachable from d have the same configuration as the NFA state in d.  So if NFA state 7 in d's configurations can reach NFA state 13 then 13 will be added to the new DFAState (labelDFATarget) with the same configuration as state 7 had. This method does not see EOT transitions off the end of token rule accept states if the rule was invoked by somebody."}, {"org.antlr.analysis.DFAState.getUniqueAlt": "Return the uniquely mentioned alt from the NFA configurations; Ignore the resolved bit etc...  Return INVALID_ALT_NUMBER if there is more than one alt mentioned."}, {"org.antlr.analysis.NFAToDFAConverter.closure": "For all NFA states (configurations) merged in d, compute the epsilon closure; that is, find all NFA states reachable from the NFA states in d via purely epsilon transitions."}, {"org.antlr.analysis.NFAToDFAConverter.addDFAStateToWorkList": "Add a new DFA state to the DFA if not already present. If the DFA state uniquely predicts a single alternative, it becomes a stop state; don't add to work list.  Further, if there exists an NFA state predicted by &gt; 1 different alternatives and with the same syn and sem context, the DFA is nondeterministic for at least one input sequence reaching that NFA state."}, {"org.antlr.analysis.NFAToDFAConverter.addTransition": "Add a transition from state d to targetState with label in normal case. if COLLAPSE_ALL_INCIDENT_EDGES, however, try to merge all edges from d to targetState; this means merging their labels.  Another optimization is to reduce to a single EOT edge any set of edges from d to targetState where there exists an EOT state.  EOT is like the wildcard so don't bother to test any other edges.  Example: NUM_INT : '1'..'9' ('0'..'9')"}, {"org.antlr.analysis.DecisionProbe.reportDanglingState": "Report the fact that DFA state d is not a state resolved with predicates and yet it has no emanating edges.  Usually this is a result of the closure/reach operations being unable to proceed"}, {"org.antlr.analysis.NFAToDFAConverter.resolveByPickingMinAlt": "Turn off all configurations associated with the set of incoming nondeterministic alts except the min alt number. There may be many alts among the configurations but only turn off the ones with problems (other than the min alt of course). If nondeterministicAlts is null then turn off all configs 'cept those associated with the minimum alt. Return the min alt found."}, {"org.antlr.analysis.NFAToDFAConverter.addPredicateTransitions": "for each NFA config in d, look for \"predicate required\" sign set during nondeterminism resolution. Add the predicate edges sorted by the alternative number; I'm fairly sure that I could walk the configs backwards so they are added to the predDFATarget in the right order, but it's best to make sure. Predicates succeed in the order they are specifed.  Alt i wins over alt i+1 if both predicates are true."}]}, {"index": "398", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.addTransition", "methodParameterType": "DFAState#Label#DFAState#Map<Integer,Transition>#", "methodParameterName": "d#label#targetState#targetToLabelMap#", "methodBody": "protected static int addTransition(DFAState d,\n\t\t\t\t\t\t\t\t\t   Label label,\n\t\t\t\t\t\t\t\t\t   DFAState targetState,\n\t\t\t\t\t\t\t\t\t   Map<Integer, Transition> targetToLabelMap)\n\t{\n\t\t//System.out.println(d.stateNumber+\"-\"+label.toString(dfa.nfa.grammar)+\"->\"+targetState.stateNumber);\n\t\tint n = 0;\n\t\tif ( DFAOptimizer.COLLAPSE_ALL_PARALLEL_EDGES ) {\n\t\t\t// track which targets we've hit\n\t\t\tInteger tI = Utils.integer(targetState.stateNumber);\n\t\t\tTransition oldTransition = targetToLabelMap.get(tI);\n\t\t\tif ( oldTransition!=null ) {\n\t\t\t\t//System.out.println(\"extra transition to \"+tI+\" upon \"+label.toString(dfa.nfa.grammar));\n\t\t\t\t// already seen state d to target transition, just add label\n\t\t\t\t// to old label unless EOT\n\t\t\t\tif ( label.getAtom()==Label.EOT ) {\n\t\t\t\t\t// merge with EOT means old edge can go away\n\t\t\t\t\toldTransition.label = new Label(Label.EOT);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// don't add anything to EOT, it's essentially the wildcard\n\t\t\t\t\tif ( oldTransition.label.getAtom()!=Label.EOT ) {\n\t\t\t\t\t\t// ok, not EOT, add in this label to old label\n\t\t\t\t\t\toldTransition.label.add(label);\n\t\t\t\t\t}\n\t\t\t\t\t//System.out.println(\"label updated to be \"+oldTransition.label.toString(dfa.nfa.grammar));\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// make a transition from d to t upon 'a'\n\t\t\t\tn = 1;\n\t\t\t\tlabel = (Label)label.clone(); // clone in case we alter later\n\t\t\t\tint transitionIndex = d.addTransition(targetState, label);\n\t\t\t\tTransition trans = d.getTransition(transitionIndex);\n\t\t\t\t// track target/transition pairs\n\t\t\t\ttargetToLabelMap.put(tI, trans);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tn = 1;\n\t\t\td.addTransition(targetState, label);\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#Assignment#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Add a transition from state d to targetState with label in normal case. if COLLAPSE_ALL_INCIDENT_EDGES, however, try to merge all edges from d to targetState; this means merging their labels.  Another optimization is to reduce to a single EOT edge any set of edges from d to targetState where there exists an EOT state.  EOT is like the wildcard so don't bother to test any other edges.  Example: NUM_INT : '1'..'9' ('0'..'9')", "call_func_name": ["org.antlr.misc.Utils.integer", "java.util.Map.get", "org.antlr.analysis.Label.getAtom", "org.antlr.analysis.Label.<init>", "org.antlr.analysis.Label.add", "org.antlr.analysis.Label.clone", "org.antlr.analysis.DFAState.addTransition", "org.antlr.analysis.DFAState.getTransition", "java.util.Map.put"], "call_func_parameter": [["int"], ["java.lang.Object"], [""], ["int"], ["org.antlr.analysis.Label"], [""], ["org.antlr.analysis.DFAState", "org.antlr.analysis.Label"], ["int"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.analysis.DFAState.addTransition": "Add a transition from this state to target with label.  Return the transition number from 0..n-1."}]}, {"index": "399", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.closure", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public void closure(DFAState d) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"closure(\"+d+\")\");\n\t\t}\n\n\t\tList<NFAConfiguration> configs = new ArrayList<NFAConfiguration>();\n\t\t// Because we are adding to the configurations in closure\n\t\t// must clone initial list so we know when to stop doing closure\n\t\tconfigs.addAll(d.nfaConfigurations);\n\t\t// for each NFA configuration in d (abort if we detect non-LL(*) state)\n\t\tint numConfigs = configs.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration c = configs.get(i);\n\t\t\tif ( c.singleAtomTransitionEmanating ) {\n\t\t\t\tcontinue; // ignore NFA states w/o epsilon transitions\n\t\t\t}\n\t\t\t//System.out.println(\"go do reach for NFA state \"+c.state);\n\t\t\t// figure out reachable NFA states from each of d's nfa states\n\t\t\t// via epsilon transitions.\n\t\t\t// Fill configsInClosure rather than altering d configs inline\n\t\t\tclosure(dfa.nfa.getState(c.state),\n\t\t\t\t\tc.alt,\n\t\t\t\t\tc.context,\n\t\t\t\t\tc.semanticContext,\n\t\t\t\t\td,\n\t\t\t\t\tfalse);\n\t\t}\n\t\t//System.out.println(\"after closure d=\"+d);\n\t\td.closureBusy = null; // wack all that memory used during closure\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ContinueStatement)ContinueStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "For all NFA states (configurations) merged in d, compute the epsilon closure; that is, find all NFA states reachable from the NFA states in d via purely epsilon transitions.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println", "java.util.ArrayList.<init>", "java.util.List.addAll", "java.util.List.size", "java.util.List.get", "org.antlr.analysis.NFA.getState", "org.antlr.analysis.NFAToDFAConverter.closure"], "call_func_parameter": [[""], ["java.lang.String"], ["java.lang.Object"], [""], ["java.lang.String"], [""], ["java.util.Collection"], [""], ["int"], ["int"], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext", "org.antlr.analysis.DFAState", "boolean"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.closure": "Where can we get from NFA state p traversing only epsilon transitions? Add new NFA states + context to DFA state d.  Also add semantic predicates to semantic context if collectPredicates is set.  We only collect predicates at hoisting depth 0, meaning before any token/char have been recognized.  This corresponds, during analysis, to the initial DFA start state construction closure() invocation. There are four cases of interest (the last being the usual transition): 1. Traverse an edge that takes us to the start state of another rule, r.  We must push this state so that if the DFA conversion hits the end of rule r, then it knows to continue the conversion at state following state that \"invoked\" r. By construction, there is a single transition emanating from a rule ref node. 2. Reach an NFA state associated with the end of a rule, r, in the grammar from which it was built.  We must add an implicit (i.e., don't actually add an epsilon transition) epsilon transition from r's end state to the NFA state following the NFA state that transitioned to rule r's start state.  Because there are many states that could reach r, the context for a rule invocation is part of a call tree not a simple stack.  When we fall off end of rule, \"pop\" a state off the call tree and add that state's \"following\" node to d's NFA configuration list.  The context for this new addition will be the new \"stack top\" in the call tree. 3. Like case 2, we reach an NFA state associated with the end of a rule, r, in the grammar from which NFA was built.  In this case, however, we realize that during this NFA&rarr;DFA conversion, no state invoked the current rule's NFA.  There is no choice but to add all NFA states that follow references to r's start state.  This is analogous to computing the FOLLOW(r) in the LL(k) world.  By construction, even rule stop state has a chain of nodes emanating from it that points to every possible following node.  This case is conveniently handled then by the 4th case. 4. Normal case.  If p can reach another NFA state q, then add q to d's configuration list, copying p's context for q's context. If there is a semantic predicate on the transition, then AND it with any existing semantic context. Current state p is always added to d's configuration list as it's part of the closure as well. When is a closure operation in a cycle condition?  While it is very possible to have the same NFA state mentioned twice within the same DFA state, there are two situations that would lead to nontermination of closure operation: o   Whenever closure reaches a configuration where the same state with same or a suffix context already exists.  This catches the IF-THEN-ELSE tail recursion cycle and things like a : A a | B ; the context will be $ (empty stack). We have to check larger context stacks because of (...)+ loops.  For example, the context of a (...)+ can be nonempty if the surrounding rule is invoked by another rule: a : b A | X ; b : (B|)+ ;  // nondeterministic by the way The context of the (B|)+ loop is \"invoked from item a : . b A ;\" and then the empty alt of the loop can reach back to itself.  The context stack will have one \"return address\" element and so we must check for same state, same context for arbitrary context stacks. Idea: If we've seen this configuration before during closure, stop. We also need to avoid reaching same state with conflicting context. Ultimately analysis would stop and we'd find the conflict, but we should stop the computation.  Previously I only checked for exact config.  Need to check for same state, suffix context not just exact context. o   Whenever closure reaches a configuration where state p is present in its own context stack.  This means that p is a rule invocation state and the target rule has been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS (See the comment there also) determines how many times it's possible to recurse; clearly we cannot recurse forever. Some grammars such as the following actually require at least one recursive call to correctly compute the lookahead: a : L ID R | b ; b : ID | L a R ; Input L ID R is ambiguous but to figure this out, ANTLR needs to go a-&gt;b-&gt;a-&gt;b to find the L ID sequence. Do not allow closure to add a configuration that would allow too much recursion. This case also catches infinite left recursion."}]}, {"index": "400", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.closure", "methodParameterType": "NFAState#int#NFAContext#SemanticContext#DFAState#boolean#", "methodParameterName": "p#alt#context#semanticContext#d#collectPredicates#", "methodBody": "public void closure(NFAState p,\n\t\t\t\t\t\tint alt,\n\t\t\t\t\t\tNFAContext context,\n\t\t\t\t\t\tSemanticContext semanticContext,\n\t\t\t\t\t\tDFAState d,\n\t\t\t\t\t\tboolean collectPredicates)\n\t{\n\t\tif ( debug ){\n\t\t\tSystem.out.println(\"closure at \"+p.enclosingRule.name+\" state \"+p.stateNumber+\"|\"+\n\t\t\t\t\t\t\t   alt+\" filling DFA state \"+d.stateNumber+\" with context \"+context\n\t\t\t\t\t\t\t   );\n\t\t}\n\n//\t\tif ( DFA.MAX_TIME_PER_DFA_CREATION>0 &&\n//\t\t\t System.currentTimeMillis() - d.dfa.conversionStartTime >=\n//\t\t\t DFA.MAX_TIME_PER_DFA_CREATION )\n//\t\t{\n//\t\t\t// bail way out; we've blown up somehow\n//\t\t\tthrow new AnalysisTimeoutException(d.dfa);\n//\t\t}\n\n\t\tNFAConfiguration proposedNFAConfiguration =\n\t\t\t\tnew NFAConfiguration(p.stateNumber,\n\t\t\t\t\t\talt,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tsemanticContext);\n\n\t\t// Avoid infinite recursion\n\t\tif ( closureIsBusy(d, proposedNFAConfiguration) ) {\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"avoid visiting exact closure computation NFA config: \"+\n\t\t\t\t\t\t\t\t   proposedNFAConfiguration+\" in \"+p.enclosingRule.name);\n\t\t\t\tSystem.out.println(\"state is \"+d.dfa.decisionNumber+\".\"+d.stateNumber);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\n\t\t// set closure to be busy for this NFA configuration\n\t\td.closureBusy.add(proposedNFAConfiguration);\n\n\t\t// p itself is always in closure\n\t\td.addNFAConfiguration(p, proposedNFAConfiguration);\n\n\t\t// Case 1: are we a reference to another rule?\n\t\tTransition transition0 = p.transition[0];\n\t\tif ( transition0 instanceof RuleClosureTransition ) {\n\t\t\tint depth = context.recursionDepthEmanatingFromState(p.stateNumber);\n\t\t\t// Detect recursion by more than a single alt, which indicates\n\t\t\t// that the decision's lookahead language is potentially non-regular; terminate\n\t\t\tif ( depth == 1 && d.dfa.getUserMaxLookahead()==0 ) { // k=* only\n\t\t\t\td.dfa.recursiveAltSet.add(alt); // indicate that this alt is recursive\n\t\t\t\tif ( d.dfa.recursiveAltSet.size()>1 ) {\n\t\t\t\t\t//System.out.println(\"recursive alts: \"+d.dfa.recursiveAltSet.toString());\n\t\t\t\t\td.abortedDueToMultipleRecursiveAlts = true;\n\t\t\t\t\tthrow new NonLLStarDecisionException(d.dfa);\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"alt \"+alt+\" in rule \"+p.enclosingRule+\" dec \"+d.dfa.decisionNumber+\n\t\t\t\t\t\" ctx: \"+context);\n\t\t\t\tSystem.out.println(\"d=\"+d);\n\t\t\t\t*/\n\t\t\t}\n\t\t\t// Detect an attempt to recurse too high\n\t\t\t// if this context has hit the max recursions for p.stateNumber,\n\t\t\t// don't allow it to enter p.stateNumber again\n\t\t\tif ( depth >= NFAContext.MAX_SAME_RULE_INVOCATIONS_PER_NFA_CONFIG_STACK ) {\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"OVF state \"+d);\n\t\t\t\tSystem.out.println(\"proposed \"+proposedNFAConfiguration);\n\t\t\t\t*/\n\t\t\t\td.abortedDueToRecursionOverflow = true;\n\t\t\t\td.dfa.probe.reportRecursionOverflow(d, proposedNFAConfiguration);\n\t\t\t\tif ( debug ) {\n\t\t\t\t\tSystem.out.println(\"analysis overflow in closure(\"+d.stateNumber+\")\");\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// otherwise, it's cool to (re)enter target of this rule ref\n\t\t\tRuleClosureTransition ref = (RuleClosureTransition)transition0;\n\t\t\t// first create a new context and push onto call tree,\n\t\t\t// recording the fact that we are invoking a rule and\n\t\t\t// from which state (case 2 below will get the following state\n\t\t\t// via the RuleClosureTransition emanating from the invoking state\n\t\t\t// pushed on the stack).\n\t\t\t// Reset the context to reflect the fact we invoked rule\n\t\t\tNFAContext newContext = new NFAContext(context, p);\n\t\t\t//System.out.println(\"invoking rule \"+ref.rule.name);\n\t\t\t// System.out.println(\" context=\"+context);\n\t\t\t// traverse epsilon edge to new rule\n\t\t\tNFAState ruleTarget = (NFAState)ref.target;\n\t\t\tclosure(ruleTarget, alt, newContext, semanticContext, d, collectPredicates);\n\t\t}\n\t\t// Case 2: end of rule state, context (i.e., an invoker) exists\n\t\telse if ( p.isAcceptState() && context.parent!=null ) {\n\t\t\tNFAState whichStateInvokedRule = context.invokingState;\n\t\t\tRuleClosureTransition edgeToRule =\n\t\t\t\t(RuleClosureTransition)whichStateInvokedRule.transition[0];\n\t\t\tNFAState continueState = edgeToRule.followState;\n\t\t\tNFAContext newContext = context.parent; // \"pop\" invoking state\n\t\t\tclosure(continueState, alt, newContext, semanticContext, d, collectPredicates);\n\t\t}\n\t\t// Case 3: end of rule state, nobody invoked this rule (no context)\n\t\t//    Fall thru to be handled by case 4 automagically.\n\t\t// Case 4: ordinary NFA->DFA conversion case: simple epsilon transition\n\t\telse {\n\t\t\t// recurse down any epsilon transitions\n\t\t\tif ( transition0!=null && transition0.isEpsilon() ) {\n\t\t\t\tboolean collectPredicatesAfterAction = collectPredicates;\n\t\t\t\tif ( transition0.isAction() && collectPredicates ) {\n\t\t\t\t\tcollectPredicatesAfterAction = false;\n\t\t\t\t\t/*\n\t\t\t\t\tif ( computingStartState ) {\n\t\t\t\t\t\tSystem.out.println(\"found action during prediction closure \"+((ActionLabel)transition0.label).actionAST.token);\n\t\t\t\t\t}\n\t\t\t\t\t */\n\t\t\t\t}\n\t\t\t\tclosure((NFAState)transition0.target,\n\t\t\t\t\t\talt,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tsemanticContext,\n\t\t\t\t\t\td,\n\t\t\t\t\t\tcollectPredicatesAfterAction\n\t\t\t\t);\n\t\t\t}\n\t\t\telse if ( transition0!=null && transition0.isSemanticPredicate() ) {\n                SemanticContext labelContext = transition0.label.getSemanticContext();\n                if ( computingStartState ) {\n                    if ( collectPredicates ) {\n                        // only indicate we can see a predicate if we're collecting preds\n                        // Could be computing start state & seen an action before this.\n                        dfa.predicateVisible = true;\n                    }\n                    else {\n                        // this state has a pred, but we can't see it.\n                        dfa.hasPredicateBlockedByAction = true;\n                        // System.out.println(\"found pred during prediction but blocked by action found previously\");\n                    }\n                }\n                // continue closure here too, but add the sem pred to ctx\n                SemanticContext newSemanticContext = semanticContext;\n                if ( collectPredicates ) {\n                    // AND the previous semantic context with new pred\n                    // do not hoist syn preds from other rules; only get if in\n                    // starting state's rule (i.e., context is empty)\n                    int walkAlt =\n\t\t\t\t\t\tdfa.decisionNFAStartState.translateDisplayAltToWalkAlt(alt);\n\t\t\t\t\tNFAState altLeftEdge =\n\t\t\t\t\t\tdfa.nfa.grammar.getNFAStateForAltOfDecision(dfa.decisionNFAStartState,walkAlt);\n\t\t\t\t\t/*\n\t\t\t\t\tSystem.out.println(\"state \"+p.stateNumber+\" alt \"+alt+\" walkAlt \"+walkAlt+\" trans to \"+transition0.target);\n\t\t\t\t\tSystem.out.println(\"DFA start state \"+dfa.decisionNFAStartState.stateNumber);\n\t\t\t\t\tSystem.out.println(\"alt left edge \"+altLeftEdge.stateNumber+\n\t\t\t\t\t\t\", epsilon target \"+\n\t\t\t\t\t\taltLeftEdge.transition(0).target.stateNumber);\n\t\t\t\t\t*/\n\t\t\t\t\tif ( !labelContext.isSyntacticPredicate() ||\n\t\t\t\t\t\t p==altLeftEdge.transition[0].target )\n\t\t\t\t\t{\n\t\t\t\t\t\t//System.out.println(\"&\"+labelContext+\" enclosingRule=\"+p.enclosingRule);\n\t\t\t\t\t\tnewSemanticContext =\n\t\t\t\t\t\t\tSemanticContext.and(semanticContext, labelContext);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tclosure((NFAState)transition0.target,\n\t\t\t\t\t\talt,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tnewSemanticContext,\n\t\t\t\t\t\td,\n\t\t\t\t\t\tcollectPredicates);\n\t\t\t}\n\t\t\tTransition transition1 = p.transition[1];\n\t\t\tif ( transition1!=null && transition1.isEpsilon() ) {\n\t\t\t\tclosure((NFAState)transition1.target,\n\t\t\t\t\t\talt,\n\t\t\t\t\t\tcontext,\n\t\t\t\t\t\tsemanticContext,\n\t\t\t\t\t\td,\n\t\t\t\t\t\tcollectPredicates);\n\t\t\t}\n\t\t}\n\n\t\t// don't remove \"busy\" flag as we want to prevent all\n\t\t// references to same config of state|alt|ctx|semCtx even\n\t\t// if resulting from another NFA state\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)ThrowStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InfixExpression(SimpleName)SimpleName(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Where can we get from NFA state p traversing only epsilon transitions? Add new NFA states + context to DFA state d.  Also add semantic predicates to semantic context if collectPredicates is set.  We only collect predicates at hoisting depth 0, meaning before any token/char have been recognized.  This corresponds, during analysis, to the initial DFA start state construction closure() invocation. There are four cases of interest (the last being the usual transition): 1. Traverse an edge that takes us to the start state of another rule, r.  We must push this state so that if the DFA conversion hits the end of rule r, then it knows to continue the conversion at state following state that \"invoked\" r. By construction, there is a single transition emanating from a rule ref node. 2. Reach an NFA state associated with the end of a rule, r, in the grammar from which it was built.  We must add an implicit (i.e., don't actually add an epsilon transition) epsilon transition from r's end state to the NFA state following the NFA state that transitioned to rule r's start state.  Because there are many states that could reach r, the context for a rule invocation is part of a call tree not a simple stack.  When we fall off end of rule, \"pop\" a state off the call tree and add that state's \"following\" node to d's NFA configuration list.  The context for this new addition will be the new \"stack top\" in the call tree. 3. Like case 2, we reach an NFA state associated with the end of a rule, r, in the grammar from which NFA was built.  In this case, however, we realize that during this NFA&rarr;DFA conversion, no state invoked the current rule's NFA.  There is no choice but to add all NFA states that follow references to r's start state.  This is analogous to computing the FOLLOW(r) in the LL(k) world.  By construction, even rule stop state has a chain of nodes emanating from it that points to every possible following node.  This case is conveniently handled then by the 4th case. 4. Normal case.  If p can reach another NFA state q, then add q to d's configuration list, copying p's context for q's context. If there is a semantic predicate on the transition, then AND it with any existing semantic context. Current state p is always added to d's configuration list as it's part of the closure as well. When is a closure operation in a cycle condition?  While it is very possible to have the same NFA state mentioned twice within the same DFA state, there are two situations that would lead to nontermination of closure operation: o   Whenever closure reaches a configuration where the same state with same or a suffix context already exists.  This catches the IF-THEN-ELSE tail recursion cycle and things like a : A a | B ; the context will be $ (empty stack). We have to check larger context stacks because of (...)+ loops.  For example, the context of a (...)+ can be nonempty if the surrounding rule is invoked by another rule: a : b A | X ; b : (B|)+ ;  // nondeterministic by the way The context of the (B|)+ loop is \"invoked from item a : . b A ;\" and then the empty alt of the loop can reach back to itself.  The context stack will have one \"return address\" element and so we must check for same state, same context for arbitrary context stacks. Idea: If we've seen this configuration before during closure, stop. We also need to avoid reaching same state with conflicting context. Ultimately analysis would stop and we'd find the conflict, but we should stop the computation.  Previously I only checked for exact config.  Need to check for same state, suffix context not just exact context. o   Whenever closure reaches a configuration where state p is present in its own context stack.  This means that p is a rule invocation state and the target rule has been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS (See the comment there also) determines how many times it's possible to recurse; clearly we cannot recurse forever. Some grammars such as the following actually require at least one recursive call to correctly compute the lookahead: a : L ID R | b ; b : ID | L a R ; Input L ID R is ambiguous but to figure this out, ANTLR needs to go a-&gt;b-&gt;a-&gt;b to find the L ID sequence. Do not allow closure to add a configuration that would allow too much recursion. This case also catches infinite left recursion.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println", "org.antlr.analysis.NFAConfiguration.<init>", "org.antlr.analysis.NFAToDFAConverter.closureIsBusy", "java.util.Set.add", "org.antlr.analysis.DFAState.addNFAConfiguration", "org.antlr.analysis.NFAContext.recursionDepthEmanatingFromState", "org.antlr.analysis.DFA.getUserMaxLookahead", "org.antlr.misc.IntSet.add", "org.antlr.misc.IntSet.size", "org.antlr.analysis.NonLLStarDecisionException.<init>", "org.antlr.analysis.DecisionProbe.reportRecursionOverflow", "org.antlr.analysis.NFAContext.<init>", "org.antlr.analysis.NFAToDFAConverter.closure", "org.antlr.analysis.NFAState.isAcceptState", "org.antlr.analysis.Transition.isEpsilon", "org.antlr.analysis.Transition.isAction", "org.antlr.analysis.Transition.isSemanticPredicate", "org.antlr.analysis.Label.getSemanticContext", "org.antlr.analysis.NFAState.translateDisplayAltToWalkAlt", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision", "org.antlr.analysis.SemanticContext.isSyntacticPredicate", "org.antlr.analysis.SemanticContext.and"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], ["java.lang.Object"], [""], ["java.lang.String"], ["int", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.NFAConfiguration"], ["java.lang.Object"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAConfiguration"], ["int"], [""], ["int"], [""], ["org.antlr.analysis.DFA"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.NFAConfiguration"], ["org.antlr.analysis.NFAContext", "org.antlr.analysis.NFAState"], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext", "org.antlr.analysis.DFAState", "boolean"], [""], [""], [""], [""], [""], ["int"], ["org.antlr.analysis.NFAState", "int"], [""], ["org.antlr.analysis.SemanticContext", "org.antlr.analysis.SemanticContext"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.closureIsBusy": "A closure operation should abort if that computation has already been done or a computation with a conflicting context has already been done.  If proposed NFA config's state and alt are the same there is potentially a problem.  If the stack context is identical then clearly the exact same computation is proposed.  If a context is a suffix of the other, then again the computation is in an identical context.  ?$ and ??$ are considered the same stack. We could walk configurations linearly doing the comparison instead of a set for exact matches but it's much slower because you can't do a Set lookup.  I use exact match as ANTLR always detect the conflict later when checking for context suffixes... I check for left-recursive stuff and terminate before analysis to avoid need to do this more expensive computation. 12-31-2007: I had to use the loop again rather than simple closureBusy.contains(proposedNFAConfiguration) lookup.  The semantic context should not be considered when determining if a closure operation is busy.  I saw a FOLLOW closure operation spin until time out because the predicate context kept increasing in size even though it's same boolean value.  This seems faster also because I'm not doing String.equals on the preds all the time. 05-05-2008: Hmm...well, i think it was a mistake to remove the sem ctx check below...adding back in.  Coincides with report of ANTLR getting super slow: http://www.antlr.org:8888/browse/ANTLR-235 This could be because it doesn't properly compute then resolve a predicate expression.  Seems to fix unit test: TestSemanticPredicates.testSemanticContextPreventsEarlyTerminationOfClosure() Changing back to Set from List.  Changed a large grammar from 8 minutes to 11 seconds.  Cool.  Closing ANTLR-235."}, {"org.antlr.analysis.DFAState.addNFAConfiguration": "Add an NFA configuration to this DFA node.  Add uniquely an NFA state/alt/syntactic&amp;semantic context (chain of invoking state(s) and semantic predicate contexts). I don't see how there could be two configurations with same state|alt|synCtx and different semantic contexts because the semantic contexts are computed along the path to a particular state so those two configurations would have to have the same predicate. Nonetheless, the addition of configurations is unique on all configuration info.  I guess I'm saying that syntactic context implies semantic context as the latter is computed according to the former. As we add configurations to this DFA state, track the set of all possible transition labels so we can simply walk it later rather than doing a loop over all possible labels in the NFA."}, {"org.antlr.analysis.NFAContext.recursionDepthEmanatingFromState": "Given an NFA state number, how many times has the NFA-to-DFA conversion pushed that state on the stack?  In other words, the NFA state must be a rule invocation state and this method tells you how many times you've been to this state.  If none, then you have not called the target rule from this state before (though another NFA state could have called that target rule). If n=1, then you've been to this state before during this DFA construction and are going to invoke that rule again. Note that many NFA states can invoke rule r, but we ignore recursion unless you hit the same rule invocation state again."}, {"org.antlr.analysis.DFA.getUserMaxLookahead": "The user may specify a max, acyclic lookahead for any decision.  No DFA cycles are created when this value, k, is greater than 0. If this decision has no k lookahead specified, then try the grammar."}, {"org.antlr.misc.IntSet.add": "Add an element to the set"}, {"org.antlr.misc.IntSet.size": "Return the size of this set (not the underlying implementation's allocated memory size, for example)."}, {"org.antlr.analysis.NFAToDFAConverter.closure": "Where can we get from NFA state p traversing only epsilon transitions? Add new NFA states + context to DFA state d.  Also add semantic predicates to semantic context if collectPredicates is set.  We only collect predicates at hoisting depth 0, meaning before any token/char have been recognized.  This corresponds, during analysis, to the initial DFA start state construction closure() invocation. There are four cases of interest (the last being the usual transition): 1. Traverse an edge that takes us to the start state of another rule, r.  We must push this state so that if the DFA conversion hits the end of rule r, then it knows to continue the conversion at state following state that \"invoked\" r. By construction, there is a single transition emanating from a rule ref node. 2. Reach an NFA state associated with the end of a rule, r, in the grammar from which it was built.  We must add an implicit (i.e., don't actually add an epsilon transition) epsilon transition from r's end state to the NFA state following the NFA state that transitioned to rule r's start state.  Because there are many states that could reach r, the context for a rule invocation is part of a call tree not a simple stack.  When we fall off end of rule, \"pop\" a state off the call tree and add that state's \"following\" node to d's NFA configuration list.  The context for this new addition will be the new \"stack top\" in the call tree. 3. Like case 2, we reach an NFA state associated with the end of a rule, r, in the grammar from which NFA was built.  In this case, however, we realize that during this NFA&rarr;DFA conversion, no state invoked the current rule's NFA.  There is no choice but to add all NFA states that follow references to r's start state.  This is analogous to computing the FOLLOW(r) in the LL(k) world.  By construction, even rule stop state has a chain of nodes emanating from it that points to every possible following node.  This case is conveniently handled then by the 4th case. 4. Normal case.  If p can reach another NFA state q, then add q to d's configuration list, copying p's context for q's context. If there is a semantic predicate on the transition, then AND it with any existing semantic context. Current state p is always added to d's configuration list as it's part of the closure as well. When is a closure operation in a cycle condition?  While it is very possible to have the same NFA state mentioned twice within the same DFA state, there are two situations that would lead to nontermination of closure operation: o   Whenever closure reaches a configuration where the same state with same or a suffix context already exists.  This catches the IF-THEN-ELSE tail recursion cycle and things like a : A a | B ; the context will be $ (empty stack). We have to check larger context stacks because of (...)+ loops.  For example, the context of a (...)+ can be nonempty if the surrounding rule is invoked by another rule: a : b A | X ; b : (B|)+ ;  // nondeterministic by the way The context of the (B|)+ loop is \"invoked from item a : . b A ;\" and then the empty alt of the loop can reach back to itself.  The context stack will have one \"return address\" element and so we must check for same state, same context for arbitrary context stacks. Idea: If we've seen this configuration before during closure, stop. We also need to avoid reaching same state with conflicting context. Ultimately analysis would stop and we'd find the conflict, but we should stop the computation.  Previously I only checked for exact config.  Need to check for same state, suffix context not just exact context. o   Whenever closure reaches a configuration where state p is present in its own context stack.  This means that p is a rule invocation state and the target rule has been called before.  NFAContext.MAX_RECURSIVE_INVOCATIONS (See the comment there also) determines how many times it's possible to recurse; clearly we cannot recurse forever. Some grammars such as the following actually require at least one recursive call to correctly compute the lookahead: a : L ID R | b ; b : ID | L a R ; Input L ID R is ambiguous but to figure this out, ANTLR needs to go a-&gt;b-&gt;a-&gt;b to find the L ID sequence. Do not allow closure to add a configuration that would allow too much recursion. This case also catches infinite left recursion."}, {"org.antlr.analysis.NFAState.translateDisplayAltToWalkAlt": "The DFA decision for this NFA decision state always has an exit path for loops as n+1 for n alts in the loop. That is really useful for displaying nondeterministic alts and so on, but for walking the NFA to get a sequence of edge labels or for actually parsing, we need to get the real alt number.  The real alt number for exiting a loop is always 1 as transition 0 points at the exit branch (we compute DFAs always for loops at the loopback state). For walking/parsing the loopback state: 1 2 3 display alt (for human consumption) 2 3 1 walk alt For walking the block start: 1 2 3 display alt 1 2 3 For walking the bypass state of a (...)"}, {"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}]}, {"index": "401", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.closureIsBusy", "methodParameterType": "DFAState#NFAConfiguration#", "methodParameterName": "d#proposedNFAConfiguration#", "methodBody": "public static boolean closureIsBusy(DFAState d,\n\t\t\t\t\t\t\t\t\t\tNFAConfiguration proposedNFAConfiguration)\n\t{\n\t\treturn d.closureBusy.contains(proposedNFAConfiguration);\n/*\n\t\tint numConfigs = d.closureBusy.size();\n\t\t// Check epsilon cycle (same state, same alt, same context)\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration c = (NFAConfiguration) d.closureBusy.get(i);\n\t\t\tif ( proposedNFAConfiguration.state==c.state &&\n\t\t\t\t proposedNFAConfiguration.alt==c.alt &&\n\t\t\t\t proposedNFAConfiguration.semanticContext.equals(c.semanticContext) &&\n\t\t\t\t proposedNFAConfiguration.context.suffix(c.context) )\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t\t*/\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A closure operation should abort if that computation has already been done or a computation with a conflicting context has already been done.  If proposed NFA config's state and alt are the same there is potentially a problem.  If the stack context is identical then clearly the exact same computation is proposed.  If a context is a suffix of the other, then again the computation is in an identical context.  ?$ and ??$ are considered the same stack. We could walk configurations linearly doing the comparison instead of a set for exact matches but it's much slower because you can't do a Set lookup.  I use exact match as ANTLR always detect the conflict later when checking for context suffixes... I check for left-recursive stuff and terminate before analysis to avoid need to do this more expensive computation. 12-31-2007: I had to use the loop again rather than simple closureBusy.contains(proposedNFAConfiguration) lookup.  The semantic context should not be considered when determining if a closure operation is busy.  I saw a FOLLOW closure operation spin until time out because the predicate context kept increasing in size even though it's same boolean value.  This seems faster also because I'm not doing String.equals on the preds all the time. 05-05-2008: Hmm...well, i think it was a mistake to remove the sem ctx check below...adding back in.  Coincides with report of ANTLR getting super slow: http://www.antlr.org:8888/browse/ANTLR-235 This could be because it doesn't properly compute then resolve a predicate expression.  Seems to fix unit test: TestSemanticPredicates.testSemanticContextPreventsEarlyTerminationOfClosure() Changing back to Set from List.  Changed a large grammar from 8 minutes to 11 seconds.  Cool.  Closing ANTLR-235.", "call_func_name": ["java.util.Set.contains"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "402", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.reach", "methodParameterType": "DFAState#Label#", "methodParameterName": "d#label#", "methodBody": "public DFAState reach(DFAState d, Label label) {\n\t\t//System.out.println(\"reach \"+label.toString(dfa.nfa.grammar)+\" from \"+d.stateNumber);\n\t\tDFAState labelDFATarget = dfa.newState();\n\n\t\t// for each NFA state in d with a labeled edge,\n\t\t// add in target states for label\n\t\t//System.out.println(\"size(d.state=\"+d.stateNumber+\")=\"+d.nfaConfigurations.size());\n\t\t//System.out.println(\"size(labeled edge states)=\"+d.configurationsWithLabeledEdges.size());\n\t\tList<NFAConfiguration> configs = d.configurationsWithLabeledEdges;\n\t\tint numConfigs = configs.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration c = configs.get(i);\n\t\t\tif ( c.resolved || c.resolveWithPredicate ) {\n\t\t\t\tcontinue; // the conflict resolver indicates we must leave alone\n\t\t\t}\n\t\t\tNFAState p = dfa.nfa.getState(c.state);\n\t\t\t// by design of the grammar->NFA conversion, only transition 0\n\t\t\t// may have a non-epsilon edge.\n\t\t\tTransition edge = p.transition[0];\n\t\t\tif ( edge==null || !c.singleAtomTransitionEmanating ) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tLabel edgeLabel = edge.label;\n\n\t\t\t// SPECIAL CASE\n\t\t\t// if it's an EOT transition on end of lexer rule, but context\n\t\t\t// stack is not empty, then don't see the EOT; the closure\n\t\t\t// will have added in the proper states following the reference\n\t\t\t// to this rule in the invoking rule.  In other words, if\n\t\t\t// somebody called this rule, don't see the EOT emanating from\n\t\t\t// this accept state.\n\t\t\tif ( c.context.parent!=null && edgeLabel.label==Label.EOT )\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// Labels not unique at this point (not until addReachableLabels)\n\t\t\t// so try simple int label match before general set intersection\n\t\t\t//System.out.println(\"comparing \"+edgeLabel+\" with \"+label);\n\t\t\tif ( Label.intersect(label, edgeLabel) ) {\n\t\t\t\t// found a transition with label;\n\t\t\t\t// add NFA target to (potentially) new DFA state\n\t\t\t\tNFAConfiguration newC = labelDFATarget.addNFAConfiguration(\n\t\t\t\t\t(NFAState)edge.target,\n\t\t\t\t\tc.alt,\n\t\t\t\t\tc.context,\n\t\t\t\t\tc.semanticContext);\n\t\t\t}\n\t\t}\n\t\tif ( labelDFATarget.nfaConfigurations.size()==0 ) {\n\t\t\t// kill; it's empty\n\t\t\tdfa.setState(labelDFATarget.stateNumber, null);\n\t\t\tlabelDFATarget = null;\n\t\t}\n        return labelDFATarget;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#PrefixExpression#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NullLiteral#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement)Block)IfStatement)Block)ForStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given the set of NFA states in DFA state d, find all NFA states reachable traversing label arcs.  By definition, there can be only one DFA state reachable by an atom from DFA state d so we must find and merge all NFA states reachable via label.  Return a new DFAState that has all of those NFA states with their context (i.e., which alt do they predict and where to return to if they fall off end of a rule). Because we cannot jump to another rule nor fall off the end of a rule via a non-epsilon transition, NFA states reachable from d have the same configuration as the NFA state in d.  So if NFA state 7 in d's configurations can reach NFA state 13 then 13 will be added to the new DFAState (labelDFATarget) with the same configuration as state 7 had. This method does not see EOT transitions off the end of token rule accept states if the rule was invoked by somebody.", "call_func_name": ["org.antlr.analysis.DFA.newState", "java.util.List.size", "java.util.List.get", "org.antlr.analysis.NFA.getState", "org.antlr.analysis.Label.intersect", "org.antlr.analysis.DFAState.addNFAConfiguration", "org.antlr.misc.OrderedHashSet.size", "org.antlr.analysis.DFA.setState"], "call_func_parameter": [[""], [""], ["int"], ["int"], ["org.antlr.analysis.Label", "org.antlr.analysis.Label"], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext"], [""], ["int", "org.antlr.analysis.DFAState"]], "passed_comments": "/"}, {"index": "403", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.convertToEOTAcceptState", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected void convertToEOTAcceptState(DFAState d) {\n\t\tLabel eot = new Label(Label.EOT);\n\t\tint numConfigs = d.nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration c = d.nfaConfigurations.get(i);\n\t\t\tif ( c.resolved || c.resolveWithPredicate ) {\n\t\t\t\tcontinue; // the conflict resolver indicates we must leave alone\n\t\t\t}\n\t\t\tNFAState p = dfa.nfa.getState(c.state);\n\t\t\tTransition edge = p.transition[0];\n\t\t\tLabel edgeLabel = edge.label;\n\t\t\tif ( edgeLabel.equals(eot) ) {\n\t\t\t\t//System.out.println(\"config with EOT: \"+c);\n\t\t\t\td.setAcceptState(true);\n\t\t\t\t//System.out.println(\"d goes from \"+d);\n\t\t\t\td.nfaConfigurations.clear();\n\t\t\t\td.addNFAConfiguration(p,c.alt,c.context,c.semanticContext);\n\t\t\t\t//System.out.println(\"to \"+d);\n\t\t\t\treturn; // assume only one EOT transition\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Walk the configurations of this DFA state d looking for the configuration, c, that has a transition on EOT.  State d should be converted to an accept state predicting the c.alt.  Blast d's current configuration set and make it just have config c. TODO: can there be more than one config with EOT transition? That would mean that two NFA configurations could reach the end of the token with possibly different predicted alts. Seems like that would be rare or impossible.  Perhaps convert this routine to find all such configs and give error if &gt;1.", "call_func_name": ["org.antlr.analysis.Label.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.NFA.getState", "org.antlr.analysis.Label.equals", "org.antlr.analysis.DFAState.setAcceptState", "org.antlr.misc.OrderedHashSet.clear", "org.antlr.analysis.DFAState.addNFAConfiguration"], "call_func_parameter": [["int"], [""], ["int"], ["int"], ["java.lang.Object"], ["boolean"], [""], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext"]], "passed_comments": "/"}, {"index": "404", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.addDFAStateToWorkList", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected DFAState addDFAStateToWorkList(DFAState d) {\n        DFAState existingState = dfa.addState(d);\n\t\tif ( d != existingState ) {\n\t\t\t// already there...use/return the existing DFA state.\n\t\t\t// But also set the states[d.stateNumber] to the existing\n\t\t\t// DFA state because the closureIsBusy must report\n\t\t\t// infinite recursion on a state before it knows\n\t\t\t// whether or not the state will already be\n\t\t\t// found after closure on it finishes.  It could be\n\t\t\t// referring to a state that will ultimately not make it\n\t\t\t// into the reachable state space and the error\n\t\t\t// reporting must be able to compute the path from\n\t\t\t// start to the error state with infinite recursion\n\t\t\tdfa.setState(d.stateNumber, existingState);\n\t\t\treturn existingState;\n\t\t}\n\n\t\t// if not there, then examine new state.\n\n\t\t// resolve syntactic conflicts by choosing a single alt or\n        // by using semantic predicates if present.\n        resolveNonDeterminisms(d);\n\n        // If deterministic, don't add this state; it's an accept state\n        // Just return as a valid DFA state\n\t\tint alt = d.getUniquelyPredictedAlt();\n\t\tif ( alt!=NFA.INVALID_ALT_NUMBER ) { // uniquely predicts an alt?\n\t\t\td = convertToAcceptState(d, alt);\n\t\t\t/*\n\t\t\tSystem.out.println(\"convert to accept; DFA \"+d.dfa.decisionNumber+\" state \"+d.stateNumber+\" uniquely predicts alt \"+\n\t\t\t\td.getUniquelyPredictedAlt());\n\t\t\t\t*/\n\t\t}\n\t\telse {\n            // unresolved, add to work list to continue NFA conversion\n            work.add(d);\n        }\n        return d;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Add a new DFA state to the DFA if not already present. If the DFA state uniquely predicts a single alternative, it becomes a stop state; don't add to work list.  Further, if there exists an NFA state predicted by &gt; 1 different alternatives and with the same syn and sem context, the DFA is nondeterministic for at least one input sequence reaching that NFA state.", "call_func_name": ["org.antlr.analysis.DFA.addState", "org.antlr.analysis.DFA.setState", "org.antlr.analysis.NFAToDFAConverter.resolveNonDeterminisms", "org.antlr.analysis.DFAState.getUniquelyPredictedAlt", "org.antlr.analysis.NFAToDFAConverter.convertToAcceptState", "java.util.List.add"], "call_func_parameter": [["org.antlr.analysis.DFAState"], ["int", "org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState"], [""], ["org.antlr.analysis.DFAState", "int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.DFA.addState": "Add a new DFA state to this DFA if not already present. To force an acyclic, fixed maximum depth DFA, just always return the incoming state.  By not reusing old states, no cycles can be created.  If we're doing fixed k lookahead don't updated uniqueStates, just return incoming state, which indicates it's a new state."}, {"org.antlr.analysis.NFAToDFAConverter.resolveNonDeterminisms": "If &gt; 1 NFA configurations within this DFA state have identical NFA state and context, but differ in their predicted TODO update for new context suffix stuff 3-9-2005 alternative then a single input sequence predicts multiple alts. The NFA decision is therefore syntactically indistinguishable from the left edge upon at least one input sequence.  We may terminate the NFA to DFA conversion for these paths since no paths emanating from those NFA states can possibly separate these conjoined twins once interwined to make things deterministic (unless there are semantic predicates; see below). Upon a nondeterministic set of NFA configurations, we should report a problem to the grammar designer and resolve the issue by aribitrarily picking the first alternative (this usually ends up producing the most natural behavior).  Pick the lowest alt number and just turn off all NFA configurations associated with the other alts. Rather than remove conflicting NFA configurations, I set the \"resolved\" bit so that future computations will ignore them.  In this way, we maintain the complete DFA state with all its configurations, but prevent future DFA conversion operations from pursuing undesirable paths.  Remember that we want to terminate DFA conversion as soon as we know the decision is deterministic"}, {"org.antlr.analysis.DFAState.getUniquelyPredictedAlt": "Walk each configuration and if they are all the same alt, return that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved configurations, but don't ignore resolveWithPredicate configs because this state should not be an accept state.  We need to add this to the work list and then have semantic predicate edges emanating from it."}]}, {"index": "405", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.resolveNonDeterminisms", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public void resolveNonDeterminisms(DFAState d) {\n\t\tif ( debug ) {\n\t\t\tSystem.out.println(\"resolveNonDeterminisms \"+d.toString());\n\t\t}\n\t\tboolean conflictingLexerRules = false;\n\t\tSet<Integer> nondeterministicAlts = d.getNonDeterministicAlts();\n\t\tif ( debug && nondeterministicAlts!=null ) {\n\t\t\tSystem.out.println(\"nondet alts=\"+nondeterministicAlts);\n\t\t}\n\n\t\t// CHECK FOR AMBIGUOUS EOT (if |allAlts|>1 and EOT state, resolve)\n\t\t// grab any config to see if EOT state; any other configs must\n\t\t// transition on EOT to get to this DFA state as well so all\n\t\t// states in d must be targets of EOT.  These are the end states\n\t\t// created in NFAFactory.build_EOFState\n\t\tNFAConfiguration anyConfig = d.nfaConfigurations.get(0);\n\t\tNFAState anyState = dfa.nfa.getState(anyConfig.state);\n\n\t\t// if d is target of EOT and more than one predicted alt\n\t\t// indicate that d is nondeterministic on all alts otherwise\n\t\t// it looks like state has no problem\n\t\tif ( anyState.isEOTTargetState() ) {\n\t\t\tSet<Integer> allAlts = d.getAltSet();\n\t\t\t// is more than 1 alt predicted?\n\t\t\tif ( allAlts!=null && allAlts.size()>1 ) {\n\t\t\t\tnondeterministicAlts = allAlts;\n\t\t\t\t// track Tokens rule issues differently than other decisions\n\t\t\t\tif ( d.dfa.isTokensRuleDecision() ) {\n\t\t\t\t\tdfa.probe.reportLexerRuleNondeterminism(d,allAlts);\n\t\t\t\t\t//System.out.println(\"Tokens rule DFA state \"+d+\" nondeterministic\");\n\t\t\t\t\tconflictingLexerRules = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if no problems return unless we aborted work on d to avoid inf recursion\n\t\tif ( !d.abortedDueToRecursionOverflow && nondeterministicAlts==null ) {\n\t\t\treturn; // no problems, return\n\t\t}\n\n\t\t// if we're not a conflicting lexer rule and we didn't abort, report ambig\n\t\t// We should get a report for abort so don't give another\n\t\tif ( !d.abortedDueToRecursionOverflow && !conflictingLexerRules ) {\n\t\t\t// TODO: with k=x option set, this is called twice for same state\n\t\t\tdfa.probe.reportNondeterminism(d, nondeterministicAlts);\n\t\t\t// TODO: how to turn off when it's only the FOLLOW that is\n\t\t\t// conflicting.  This used to shut off even alts i,j < n\n\t\t\t// conflict warnings. :(\n\t\t}\n\n\t\t// ATTEMPT TO RESOLVE WITH SEMANTIC PREDICATES\n\t\tboolean resolved =\n\t\t\ttryToResolveWithSemanticPredicates(d, nondeterministicAlts);\n\t\tif ( resolved ) {\n\t\t\tif ( debug ) {\n\t\t\t\tSystem.out.println(\"resolved DFA state \"+d.stateNumber+\" with pred\");\n\t\t\t}\n\t\t\td.resolvedWithPredicates = true;\n\t\t\tdfa.probe.reportNondeterminismResolvedWithSemanticPredicate(d);\n\t\t\treturn;\n\t\t}\n\n\t\t// RESOLVE SYNTACTIC CONFLICT BY REMOVING ALL BUT ONE ALT\n\t\tresolveByChoosingFirstAlt(d, nondeterministicAlts);\n\n\t\t//System.out.println(\"state \"+d.stateNumber+\" resolved to alt \"+winningAlt);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#PrefixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#PrefixExpression#SimpleName#PrefixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(IfStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If &gt; 1 NFA configurations within this DFA state have identical NFA state and context, but differ in their predicted TODO update for new context suffix stuff 3-9-2005 alternative then a single input sequence predicts multiple alts. The NFA decision is therefore syntactically indistinguishable from the left edge upon at least one input sequence.  We may terminate the NFA to DFA conversion for these paths since no paths emanating from those NFA states can possibly separate these conjoined twins once interwined to make things deterministic (unless there are semantic predicates; see below). Upon a nondeterministic set of NFA configurations, we should report a problem to the grammar designer and resolve the issue by aribitrarily picking the first alternative (this usually ends up producing the most natural behavior).  Pick the lowest alt number and just turn off all NFA configurations associated with the other alts. Rather than remove conflicting NFA configurations, I set the \"resolved\" bit so that future computations will ignore them.  In this way, we maintain the complete DFA state with all its configurations, but prevent future DFA conversion operations from pursuing undesirable paths.  Remember that we want to terminate DFA conversion as soon as we know the decision is deterministic", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.antlr.analysis.DFAState.toString", "java.lang.StringBuilder.toString", "java.io.PrintStream.println", "org.antlr.analysis.DFAState.getNonDeterministicAlts", "java.lang.StringBuilder.append", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.NFA.getState", "org.antlr.analysis.NFAState.isEOTTargetState", "org.antlr.analysis.DFAState.getAltSet", "java.util.Set.size", "org.antlr.analysis.DFA.isTokensRuleDecision", "org.antlr.analysis.DecisionProbe.reportLexerRuleNondeterminism", "org.antlr.analysis.DecisionProbe.reportNondeterminism", "org.antlr.analysis.NFAToDFAConverter.tryToResolveWithSemanticPredicates", "java.lang.StringBuilder.append", "org.antlr.analysis.DecisionProbe.reportNondeterminismResolvedWithSemanticPredicate", "org.antlr.analysis.NFAToDFAConverter.resolveByChoosingFirstAlt"], "call_func_parameter": [[""], ["java.lang.String"], [""], [""], ["java.lang.String"], [""], ["java.lang.Object"], ["int"], ["int"], [""], [""], [""], [""], ["org.antlr.analysis.DFAState", "java.util.Set"], ["org.antlr.analysis.DFAState", "java.util.Set"], ["org.antlr.analysis.DFAState", "java.util.Set"], ["int"], ["org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState", "java.util.Set"]], "passed_comments": [{"org.antlr.analysis.DFAState.toString": "Print all NFA states plus what alts they predict"}, {"org.antlr.analysis.DFAState.getAltSet": "Get the set of all alts mentioned by all NFA configurations in this DFA state."}, {"org.antlr.analysis.DFA.isTokensRuleDecision": "Is this DFA derived from the NFA for the Tokens rule?"}, {"org.antlr.analysis.DecisionProbe.reportLexerRuleNondeterminism": "Currently the analysis reports issues between token definitions, but we don't print out warnings in favor of just picking the first token definition found in the grammar ala lex/flex."}, {"org.antlr.analysis.NFAToDFAConverter.tryToResolveWithSemanticPredicates": "See if a set of nondeterministic alternatives can be disambiguated with the semantic predicate contexts of the alternatives. Without semantic predicates, syntactic conflicts are resolved by simply choosing the first viable alternative.  In the presence of semantic predicates, you can resolve the issue by evaluating boolean expressions at run time.  During analysis, this amounts to suppressing grammar error messages to the developer.  NFA configurations are always marked as \"to be resolved with predicates\" so that DFA.findNewDFAStatesAndAddDFATransitions() will know to ignore these configurations and add predicate transitions to the DFA after adding token/char labels. During analysis, we can simply make sure that for n ambiguously predicted alternatives there are at least n-1 unique predicate sets.  The nth alternative can be predicted with \"not\" the \"or\" of all other predicates.  NFA configurations without predicates are assumed to have the default predicate of \"true\" from a user point of view.  When true is combined via || with another predicate, the predicate is a tautology and must be removed from consideration for disambiguation: a : b | B ; // hoisting p1||true out of rule b, yields no predicate b : {p1}? B | B ; This is done down in getPredicatesPerNonDeterministicAlt()."}]}, {"index": "406", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.resolveByPickingMinAlt", "methodParameterType": "DFAState#Set<Integer>#", "methodParameterName": "d#nondeterministicAlts#", "methodBody": "protected int resolveByPickingMinAlt(DFAState d, Set<Integer> nondeterministicAlts) {\n\t\tint min;\n\t\tif ( nondeterministicAlts!=null ) {\n\t\t\tmin = getMinAlt(nondeterministicAlts);\n\t\t}\n\t\telse {\n\t\t\tmin = d.minAltInConfigurations;\n\t\t}\n\n\t\tturnOffOtherAlts(d, min, nondeterministicAlts);\n\n\t\treturn min;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Turn off all configurations associated with the set of incoming nondeterministic alts except the min alt number. There may be many alts among the configurations but only turn off the ones with problems (other than the min alt of course). If nondeterministicAlts is null then turn off all configs 'cept those associated with the minimum alt. Return the min alt found.", "call_func_name": ["org.antlr.analysis.NFAToDFAConverter.getMinAlt", "org.antlr.analysis.NFAToDFAConverter.turnOffOtherAlts"], "call_func_parameter": [["java.util.Set"], ["org.antlr.analysis.DFAState", "int", "java.util.Set"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.turnOffOtherAlts": "turn off all states associated with alts other than the good one (as long as they are one of the nondeterministic ones)"}]}, {"index": "407", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.resolveByPickingExitAlt", "methodParameterType": "DFAState#Set<Integer>#", "methodParameterName": "d#nondeterministicAlts#", "methodBody": "protected int resolveByPickingExitAlt(DFAState d, Set<Integer> nondeterministicAlts) {\n\t\tint exitAlt = dfa.getNumberOfAlts();\n\t\tturnOffOtherAlts(d, exitAlt, nondeterministicAlts);\n\t\treturn exitAlt;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Resolve state d by choosing exit alt, which is same value as the number of alternatives.  Return that exit alt.", "call_func_name": ["org.antlr.analysis.DFA.getNumberOfAlts", "org.antlr.analysis.NFAToDFAConverter.turnOffOtherAlts"], "call_func_parameter": [[""], ["org.antlr.analysis.DFAState", "int", "java.util.Set"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.turnOffOtherAlts": "turn off all states associated with alts other than the good one (as long as they are one of the nondeterministic ones)"}]}, {"index": "408", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.turnOffOtherAlts", "methodParameterType": "DFAState#int#Set<Integer>#", "methodParameterName": "d#min#nondeterministicAlts#", "methodBody": "protected static void turnOffOtherAlts(DFAState d, int min, Set<Integer> nondeterministicAlts) {\n\t\tint numConfigs = d.nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = d.nfaConfigurations.get(i);\n\t\t\tif ( configuration.alt!=min ) {\n\t\t\t\tif ( nondeterministicAlts==null ||\n\t\t\t\t\t nondeterministicAlts.contains(Utils.integer(configuration.alt)) )\n\t\t\t\t{\n\t\t\t\t\tconfiguration.resolved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "turn off all states associated with alts other than the good one (as long as they are one of the nondeterministic ones)", "call_func_name": ["org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.misc.Utils.integer", "java.util.Set.contains"], "call_func_parameter": [[""], ["int"], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "409", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.tryToResolveWithSemanticPredicates", "methodParameterType": "DFAState#Set<Integer>#", "methodParameterName": "d#nondeterministicAlts#", "methodBody": "protected boolean tryToResolveWithSemanticPredicates(DFAState d,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Set<Integer> nondeterministicAlts)\n\t{\n\t\tMap<Integer, SemanticContext> altToPredMap =\n\t\t\t\tgetPredicatesPerNonDeterministicAlt(d, nondeterministicAlts);\n\n\t\tif ( altToPredMap.isEmpty() ) {\n\t\t\treturn false;\n\t\t}\n\n\t\t//System.out.println(\"nondeterministic alts with predicates: \"+altToPredMap);\n\t\tdfa.probe.reportAltPredicateContext(d, altToPredMap);\n\n\t\tif ( nondeterministicAlts.size()-altToPredMap.size()>1 ) {\n\t\t\t// too few predicates to resolve; just return\n\t\t\treturn false;\n\t\t}\n\n\t\t// Handle case where 1 predicate is missing\n\t\t// Case 1. Semantic predicates\n\t\t// If the missing pred is on nth alt, !(union of other preds)==true\n\t\t// so we can avoid that computation.  If naked alt is ith, then must\n\t\t// test it with !(union) since semantic predicated alts are order\n\t\t// independent\n\t\t// Case 2: Syntactic predicates\n\t\t// The naked alt is always assumed to be true as the order of\n\t\t// alts is the order of precedence.  The naked alt will be a tautology\n\t\t// anyway as it's !(union of other preds).  This implies\n\t\t// that there is no such thing as noviable alt for synpred edges\n\t\t// emanating from a DFA state.\n\t\tif ( altToPredMap.size()==nondeterministicAlts.size()-1 ) {\n\t\t\t// if there are n-1 predicates for n nondeterministic alts, can fix\n\t\t\torg.antlr.misc.BitSet ndSet = org.antlr.misc.BitSet.of(nondeterministicAlts);\n\t\t\torg.antlr.misc.BitSet predSet = org.antlr.misc.BitSet.of(altToPredMap);\n\t\t\tint nakedAlt = ndSet.subtract(predSet).getSingleElement();\n\t\t\tSemanticContext nakedAltPred;\n\t\t\tif ( nakedAlt == max(nondeterministicAlts) ) {\n\t\t\t\t// the naked alt is the last nondet alt and will be the default clause\n\t\t\t\tnakedAltPred = new SemanticContext.TruePredicate();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// pretend naked alternative is covered with !(union other preds)\n\t\t\t\t// unless one of preds from other alts is a manually specified synpred\n\t\t\t\t// since those have precedence same as alt order.  Missing synpred\n\t\t\t\t// is true so that alt wins (or is at least attempted).\n\t\t\t\t// Note: can't miss any preds on alts (can't be here) if auto backtrack\n\t\t\t\t// since it prefixes all.\n\t\t\t\t// In LL(*) paper, i'll just have algorithm emit warning about uncovered\n\t\t\t\t// pred\n\t\t\t\tSemanticContext unionOfPredicatesFromAllAlts =\n\t\t\t\t\tgetUnionOfPredicates(altToPredMap);\n\t\t\t\t//System.out.println(\"all predicates \"+unionOfPredicatesFromAllAlts);\n\t\t\t\tif ( unionOfPredicatesFromAllAlts.isSyntacticPredicate() ) {\n\t\t\t\t\tnakedAltPred = new SemanticContext.TruePredicate();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tnakedAltPred =\n\t\t\t\t\t\tSemanticContext.not(unionOfPredicatesFromAllAlts);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//System.out.println(\"covering naked alt=\"+nakedAlt+\" with \"+nakedAltPred);\n\n\t\t\taltToPredMap.put(Utils.integer(nakedAlt), nakedAltPred);\n\t\t\t// set all config with alt=nakedAlt to have the computed predicate\n\t\t\tint numConfigs = d.nfaConfigurations.size();\n\t\t\tfor (int i = 0; i < numConfigs; i++) { // TODO: I don't think we need to do this; altToPredMap has it\n\t\t\t //7/27/10  theok, I removed it and it still seems to work with everything; leave in anyway just in case\n\t\t\t\tNFAConfiguration configuration = d.nfaConfigurations.get(i);\n\t\t\t\tif ( configuration.alt == nakedAlt ) {\n\t\t\t\t\tconfiguration.semanticContext = nakedAltPred;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ( altToPredMap.size()==nondeterministicAlts.size() ) {\n\t\t\t// RESOLVE CONFLICT by picking one NFA configuration for each alt\n\t\t\t// and setting its resolvedWithPredicate flag\n\t\t\t// First, prevent a recursion warning on this state due to\n\t\t\t// pred resolution\n\t\t\tif ( d.abortedDueToRecursionOverflow ) {\n\t\t\t\td.dfa.probe.removeRecursiveOverflowState(d);\n\t\t\t}\n\t\t\tint numConfigs = d.nfaConfigurations.size();\n\t\t\t//System.out.println(\"pred map=\"+altToPredMap);\n\t\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\t\tNFAConfiguration configuration = d.nfaConfigurations.get(i);\n\t\t\t\tSemanticContext semCtx = altToPredMap.get(Utils.integer(configuration.alt));\n\t\t\t\tif ( semCtx!=null ) {\n\t\t\t\t\t// resolve (first found) with pred\n\t\t\t\t\t// and remove alt from problem list\n\t\t\t\t\t//System.out.println(\"c=\"+configuration);\n\t\t\t\t\tconfiguration.resolveWithPredicate = true;\n\t\t\t\t\t// altToPredMap has preds from all alts; store into \"annointed\" config\n\t\t\t\t\tconfiguration.semanticContext = semCtx; // reset to combined\n\t\t\t\t\taltToPredMap.remove(Utils.integer(configuration.alt));\n\n\t\t\t\t\t// notify grammar that we've used the preds contained in semCtx\n\t\t\t\t\tif ( semCtx.isSyntacticPredicate() ) {\n\t\t\t\t\t\tdfa.nfa.grammar.synPredUsedInDFA(dfa, semCtx);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( nondeterministicAlts.contains(Utils.integer(configuration.alt)) ) {\n\t\t\t\t\t// resolve all configurations for nondeterministic alts\n\t\t\t\t\t// for which there is no predicate context by turning it off\n\t\t\t\t\tconfiguration.resolved = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;  // couldn't fix the problem with predicates\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#NumberLiteral#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#Block#ForStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ExpressionStatement(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)Block)ForStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "See if a set of nondeterministic alternatives can be disambiguated with the semantic predicate contexts of the alternatives. Without semantic predicates, syntactic conflicts are resolved by simply choosing the first viable alternative.  In the presence of semantic predicates, you can resolve the issue by evaluating boolean expressions at run time.  During analysis, this amounts to suppressing grammar error messages to the developer.  NFA configurations are always marked as \"to be resolved with predicates\" so that DFA.findNewDFAStatesAndAddDFATransitions() will know to ignore these configurations and add predicate transitions to the DFA after adding token/char labels. During analysis, we can simply make sure that for n ambiguously predicted alternatives there are at least n-1 unique predicate sets.  The nth alternative can be predicted with \"not\" the \"or\" of all other predicates.  NFA configurations without predicates are assumed to have the default predicate of \"true\" from a user point of view.  When true is combined via || with another predicate, the predicate is a tautology and must be removed from consideration for disambiguation: a : b | B ; // hoisting p1||true out of rule b, yields no predicate b : {p1}? B | B ; This is done down in getPredicatesPerNonDeterministicAlt().", "call_func_name": ["org.antlr.analysis.NFAToDFAConverter.getPredicatesPerNonDeterministicAlt", "java.util.Map.isEmpty", "org.antlr.analysis.DecisionProbe.reportAltPredicateContext", "java.util.Set.size", "java.util.Map.size", "org.antlr.misc.BitSet.of", "org.antlr.misc.BitSet.of", "org.antlr.misc.BitSet.subtract", "org.antlr.misc.IntSet.getSingleElement", "org.antlr.analysis.NFAToDFAConverter.max", "org.antlr.analysis.NFAToDFAConverter.getUnionOfPredicates", "org.antlr.analysis.SemanticContext.isSyntacticPredicate", "org.antlr.analysis.SemanticContext.not", "org.antlr.misc.Utils.integer", "java.util.Map.put", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.analysis.DecisionProbe.removeRecursiveOverflowState", "java.util.Map.get", "java.util.Map.remove", "org.antlr.tool.Grammar.synPredUsedInDFA", "java.util.Set.contains"], "call_func_parameter": [["org.antlr.analysis.DFAState", "java.util.Set"], [""], ["org.antlr.analysis.DFAState", "java.util.Map"], [""], [""], ["java.util.Collection"], ["java.util.Map"], ["org.antlr.misc.IntSet"], [""], ["java.util.Set"], ["java.util.Map"], [""], ["org.antlr.analysis.SemanticContext"], ["int"], ["java.lang.Object", "java.lang.Object"], [""], ["int"], ["org.antlr.analysis.DFAState"], ["java.lang.Object"], ["java.lang.Object"], ["org.antlr.analysis.DFA", "org.antlr.analysis.SemanticContext"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.NFAToDFAConverter.getPredicatesPerNonDeterministicAlt": "Return a mapping from nondeterministc alt to combined list of predicates. If both (s|i|semCtx1) and (t|i|semCtx2) exist, then the proper predicate for alt i is semCtx1||semCtx2 because you have arrived at this single DFA state via two NFA paths, both of which have semantic predicates. We ignore deterministic alts because syntax alone is sufficient to predict those.  Do not include their predicates. Alts with no predicate are assumed to have {true}? pred. When combining via || with \"true\", all predicates are removed from consideration since the expression will always be true and hence not tell us how to resolve anything.  So, if any NFA configuration in this DFA state does not have a semantic context, the alt cannot be resolved with a predicate. If nonnull, incidentEdgeLabel tells us what NFA transition label we did a reach on to compute state d.  d may have insufficient preds, so we really want this for the error message."}, {"org.antlr.analysis.DecisionProbe.reportAltPredicateContext": "Report the list of predicates found for each alternative; copy the list because this set gets altered later by the method tryToResolveWithSemanticPredicates() while flagging NFA configurations in d as resolved."}, {"org.antlr.analysis.NFAToDFAConverter.getUnionOfPredicates": "OR together all predicates from the alts.  Note that the predicate for an alt could itself be a combination of predicates."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.analysis.DecisionProbe.removeRecursiveOverflowState": "If a recursion overflow is resolve with predicates, then we need to shut off the warning that would be generated."}]}, {"index": "410", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.getPredicatesPerNonDeterministicAlt", "methodParameterType": "DFAState#Set<Integer>#", "methodParameterName": "d#nondeterministicAlts#", "methodBody": "protected Map<Integer, SemanticContext> getPredicatesPerNonDeterministicAlt(DFAState d,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSet<Integer> nondeterministicAlts)\n\t{\n\t\t// map alt to combined SemanticContext\n\t\tMap<Integer, SemanticContext> altToPredicateContextMap =\n\t\t\tnew HashMap<Integer, SemanticContext>();\n\t\t// init the alt to predicate set map\n\t\tMap<Integer, OrderedHashSet<SemanticContext>> altToSetOfContextsMap =\n\t\t\tnew HashMap<Integer, OrderedHashSet<SemanticContext>>();\n\t\tfor (Integer altI : nondeterministicAlts) {\n\t\t\taltToSetOfContextsMap.put(altI, new OrderedHashSet<SemanticContext>());\n\t\t}\n\n\t\t/*\n\t\tList<Label> sampleInputLabels = d.dfa.probe.getSampleNonDeterministicInputSequence(d);\n\t\tString input = d.dfa.probe.getInputSequenceDisplay(sampleInputLabels);\n\t\tSystem.out.println(\"sample input: \"+input);\n\t\t*/\n\n\t\t// for each configuration, create a unique set of predicates\n\t\t// Also, track the alts with at least one uncovered configuration\n\t\t// (one w/o a predicate); tracks tautologies like p1||true\n\t\tMap<Integer, Set<Token>> altToLocationsReachableWithoutPredicate = new HashMap<Integer, Set<Token>>();\n\t\tSet<Integer> nondetAltsWithUncoveredConfiguration = new HashSet<Integer>();\n\t\t//System.out.println(\"configs=\"+d.nfaConfigurations);\n\t\t//System.out.println(\"configs with preds?\"+d.atLeastOneConfigurationHasAPredicate);\n\t\t//System.out.println(\"configs with preds=\"+d.configurationsWithPredicateEdges);\n\t\tint numConfigs = d.nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration configuration = d.nfaConfigurations.get(i);\n\t\t\tInteger altI = Utils.integer(configuration.alt);\n\t\t\t// if alt is nondeterministic, combine its predicates\n\t\t\tif ( nondeterministicAlts.contains(altI) ) {\n\t\t\t\t// if there is a predicate for this NFA configuration, OR in\n\t\t\t\tif ( configuration.semanticContext !=\n\t\t\t\t\t SemanticContext.EMPTY_SEMANTIC_CONTEXT )\n\t\t\t\t{\n\t\t\t\t\tSet<SemanticContext> predSet = altToSetOfContextsMap.get(altI);\n\t\t\t\t\tpredSet.add(configuration.semanticContext);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// if no predicate, but it's part of nondeterministic alt\n\t\t\t\t\t// then at least one path exists not covered by a predicate.\n\t\t\t\t\t// must remove predicate for this alt; track incomplete alts\n\t\t\t\t\tnondetAltsWithUncoveredConfiguration.add(altI);\n\t\t\t\t\t/*\n\t\t\t\t\tNFAState s = dfa.nfa.getState(configuration.state);\n\t\t\t\t\tSystem.out.println(\"###\\ndec \"+dfa.decisionNumber+\" alt \"+configuration.alt+\n\t\t\t\t\t\t\t\t\t   \" enclosing rule for nfa state not covered \"+\n\t\t\t\t\t\t\t\t\t   s.enclosingRule);\n\t\t\t\t\tif ( s.associatedASTNode!=null ) {\n\t\t\t\t\t\tSystem.out.println(\"token=\"+s.associatedASTNode.token);\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(\"nfa state=\"+s);\n\n\t\t\t\t\tif ( s.incidentEdgeLabel!=null && Label.intersect(incidentEdgeLabel, s.incidentEdgeLabel) ) {\n\t\t\t\t\t\tSet<Token> locations = altToLocationsReachableWithoutPredicate.get(altI);\n\t\t\t\t\t\tif ( locations==null ) {\n\t\t\t\t\t\t\tlocations = new HashSet<Token>();\n\t\t\t\t\t\t\taltToLocationsReachableWithoutPredicate.put(altI, locations);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlocations.add(s.associatedASTNode.token);\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// For each alt, OR together all unique predicates associated with\n\t\t// all configurations\n\t\t// Also, track the list of incompletely covered alts: those alts\n\t\t// with at least 1 predicate and at least one configuration w/o a\n\t\t// predicate. We want this in order to report to the decision probe.\n\t\tList<Integer> incompletelyCoveredAlts = new ArrayList<Integer>();\n\t\tfor (Integer altI : nondeterministicAlts) {\n\t\t\tSet<SemanticContext> contextsForThisAlt = altToSetOfContextsMap.get(altI);\n\t\t\tif ( nondetAltsWithUncoveredConfiguration.contains(altI) ) { // >= 1 config has no ctx\n\t\t\t\tif ( contextsForThisAlt.size()>0 ) {    // && at least one pred\n\t\t\t\t\tincompletelyCoveredAlts.add(altI);  // this alt incompleted covered\n\t\t\t\t}\n\t\t\t\tcontinue; // don't include at least 1 config has no ctx\n\t\t\t}\n\t\t\tSemanticContext combinedContext = null;\n\t\t\tfor (SemanticContext ctx : contextsForThisAlt) {\n\t\t\t\tcombinedContext =\n\t\t\t\t\t\tSemanticContext.or(combinedContext,ctx);\n\t\t\t}\n\t\t\taltToPredicateContextMap.put(altI, combinedContext);\n\t\t}\n\n\t\tif ( incompletelyCoveredAlts.size()>0 ) {\n\t\t\t/*\n\t\t\tSystem.out.println(\"prob in dec \"+dfa.decisionNumber+\" state=\"+d);\n\t\t\tFASerializer serializer = new FASerializer(dfa.nfa.grammar);\n\t\t\tString result = serializer.serialize(dfa.startState);\n\t\t\tSystem.out.println(\"dfa: \"+result);\n\t\t\tSystem.out.println(\"incomplete alts: \"+incompletelyCoveredAlts);\n\t\t\tSystem.out.println(\"nondet=\"+nondeterministicAlts);\n\t\t\tSystem.out.println(\"nondetAltsWithUncoveredConfiguration=\"+ nondetAltsWithUncoveredConfiguration);\n\t\t\tSystem.out.println(\"altToCtxMap=\"+altToSetOfContextsMap);\n\t\t\tSystem.out.println(\"altToPredicateContextMap=\"+altToPredicateContextMap);\n\t\t\t*/\n\t\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\t\tNFAConfiguration configuration = d.nfaConfigurations.get(i);\n\t\t\t\tInteger altI = Utils.integer(configuration.alt);\n\t\t\t\tif ( incompletelyCoveredAlts.contains(altI) &&\n\t\t\t\t\t configuration.semanticContext == SemanticContext.EMPTY_SEMANTIC_CONTEXT )\n\t\t\t\t{\n\t\t\t\t\tNFAState s = dfa.nfa.getState(configuration.state);\n\t\t\t\t\t/*\n\t\t\t\t\tSystem.out.print(\"nondet config w/o context \"+configuration+\n\t\t\t\t\t\t\t\t\t \" incident \"+(s.incidentEdgeLabel!=null?s.incidentEdgeLabel.toString(dfa.nfa.grammar):null));\n\t\t\t\t\tif ( s.associatedASTNode!=null ) {\n\t\t\t\t\t\tSystem.out.print(\" token=\"+s.associatedASTNode.token);\n\t\t\t\t\t}\n\t\t\t\t\telse System.out.println();\n\t\t\t\t\t*/\n                    // We want to report getting to an NFA state with an\n                    // incoming label, unless it's EOF, w/o a predicate.\n                    if ( s.incidentEdgeLabel!=null && s.incidentEdgeLabel.label != Label.EOF ) {\n                        if ( s.associatedASTNode==null || s.associatedASTNode.token==null ) {\n\t\t\t\t\t\t\tErrorManager.internalError(\"no AST/token for nonepsilon target w/o predicate\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tSet<Token> locations = altToLocationsReachableWithoutPredicate.get(altI);\n\t\t\t\t\t\t\tif ( locations==null ) {\n\t\t\t\t\t\t\t\tlocations = new HashSet<Token>();\n\t\t\t\t\t\t\t\taltToLocationsReachableWithoutPredicate.put(altI, locations);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tlocations.add(s.associatedASTNode.token);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdfa.probe.reportIncompletelyCoveredAlts(d,\n\t\t\t\t\t\t\t\t\t\t\t\t\taltToLocationsReachableWithoutPredicate);\n\t\t}\n\n\t\treturn altToPredicateContextMap;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)EnhancedForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a mapping from nondeterministc alt to combined list of predicates. If both (s|i|semCtx1) and (t|i|semCtx2) exist, then the proper predicate for alt i is semCtx1||semCtx2 because you have arrived at this single DFA state via two NFA paths, both of which have semantic predicates. We ignore deterministic alts because syntax alone is sufficient to predict those.  Do not include their predicates. Alts with no predicate are assumed to have {true}? pred. When combining via || with \"true\", all predicates are removed from consideration since the expression will always be true and hence not tell us how to resolve anything.  So, if any NFA configuration in this DFA state does not have a semantic context, the alt cannot be resolved with a predicate. If nonnull, incidentEdgeLabel tells us what NFA transition label we did a reach on to compute state d.  d may have insufficient preds, so we really want this for the error message.", "call_func_name": ["java.util.HashMap.<init>", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.misc.OrderedHashSet.<init>", "java.util.Map.put", "java.util.HashSet.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "org.antlr.misc.Utils.integer", "java.util.Set.contains", "java.util.Map.get", "java.util.Set.add", "java.util.ArrayList.<init>", "java.util.Set.size", "java.util.List.add", "org.antlr.analysis.SemanticContext.or", "java.util.List.size", "java.util.List.contains", "org.antlr.analysis.NFA.getState", "org.antlr.tool.ErrorManager.internalError", "org.antlr.analysis.DecisionProbe.reportIncompletelyCoveredAlts"], "call_func_parameter": [[""], [""], [""], [""], [""], ["java.lang.Object", "java.lang.Object"], [""], [""], ["int"], ["int"], ["java.lang.Object"], ["java.lang.Object"], ["java.lang.Object"], [""], [""], ["java.lang.Object"], ["org.antlr.analysis.SemanticContext", "org.antlr.analysis.SemanticContext"], [""], ["java.lang.Object"], ["int"], ["java.lang.Object"], ["org.antlr.analysis.DFAState", "java.util.Map"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "411", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.getUnionOfPredicates", "methodParameterType": "Map<?,SemanticContext>#", "methodParameterName": "altToPredMap#", "methodBody": "protected static SemanticContext getUnionOfPredicates(Map<?, SemanticContext> altToPredMap) {\n\t\tIterator<SemanticContext> iter;\n\t\tSemanticContext unionOfPredicatesFromAllAlts = null;\n\t\titer = altToPredMap.values().iterator();\n\t\twhile ( iter.hasNext() ) {\n\t\t\tSemanticContext semCtx = iter.next();\n\t\t\tif ( unionOfPredicatesFromAllAlts==null ) {\n\t\t\t\tunionOfPredicatesFromAllAlts = semCtx;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tunionOfPredicatesFromAllAlts =\n\t\t\t\t\t\tSemanticContext.or(unionOfPredicatesFromAllAlts,semCtx);\n\t\t\t}\n\t\t}\n\t\treturn unionOfPredicatesFromAllAlts;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#WildcardType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(WhileStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "OR together all predicates from the alts.  Note that the predicate for an alt could itself be a combination of predicates.", "call_func_name": ["java.util.Map.values", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.analysis.SemanticContext.or"], "call_func_parameter": [[""], [""], [""], [""], ["org.antlr.analysis.SemanticContext", "org.antlr.analysis.SemanticContext"]], "passed_comments": "/"}, {"index": "412", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/NFAToDFAConverter.java", "methodName": "org.antlr.analysis.NFAToDFAConverter.addPredicateTransitions", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "protected void addPredicateTransitions(DFAState d) {\n\t\tList<NFAConfiguration> configsWithPreds = new ArrayList<NFAConfiguration>();\n\t\t// get a list of all configs with predicates\n\t\tint numConfigs = d.nfaConfigurations.size();\n\t\tfor (int i = 0; i < numConfigs; i++) {\n\t\t\tNFAConfiguration c = d.nfaConfigurations.get(i);\n\t\t\tif ( c.resolveWithPredicate ) {\n\t\t\t\tconfigsWithPreds.add(c);\n\t\t\t}\n\t\t}\n\t\t// Sort ascending according to alt; alt i has higher precedence than i+1\n\t\tCollections.sort(configsWithPreds,\n\t\t\t new Comparator<NFAConfiguration>() {\n\t\t\t@Override\n\t\t\t\t public int compare(NFAConfiguration a, NFAConfiguration b) {\n\t\t\t\t\t if ( a.alt < b.alt ) return -1;\n\t\t\t\t\t else if ( a.alt > b.alt ) return 1;\n\t\t\t\t\t return 0;\n\t\t\t\t }\n\t\t\t });\n\t\tList<NFAConfiguration> predConfigsSortedByAlt = configsWithPreds;\n\t\t// Now, we can add edges emanating from d for these preds in right order\n\t\tfor (int i = 0; i < predConfigsSortedByAlt.size(); i++) {\n\t\t\tNFAConfiguration c = predConfigsSortedByAlt.get(i);\n\t\t\tDFAState predDFATarget = d.dfa.getAcceptState(c.alt);\n\t\t\tif ( predDFATarget==null ) {\n\t\t\t\tpredDFATarget = dfa.newState(); // create if not there.\n\t\t\t\t// create a new DFA state that is a target of the predicate from d\n\t\t\t\tpredDFATarget.addNFAConfiguration(dfa.nfa.getState(c.state),\n\t\t\t\t\t\t\t\t\t\t\t\t  c.alt,\n\t\t\t\t\t\t\t\t\t\t\t\t  c.context,\n\t\t\t\t\t\t\t\t\t\t\t\t  c.semanticContext);\n\t\t\t\tpredDFATarget.setAcceptState(true);\n\t\t\t\tdfa.setAcceptState(c.alt, predDFATarget);\n\t\t\t\tDFAState existingState = dfa.addState(predDFATarget);\n\t\t\t\tif ( predDFATarget != existingState ) {\n\t\t\t\t\t// already there...use/return the existing DFA state that\n\t\t\t\t\t// is a target of this predicate.  Make this state number\n\t\t\t\t\t// point at the existing state\n\t\t\t\t\tdfa.setState(predDFATarget.stateNumber, existingState);\n\t\t\t\t\tpredDFATarget = existingState;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// add a transition to pred target from d\n\t\t\td.addTransition(predDFATarget, new PredicateLabel(c.semanticContext));\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#NumberLiteral#PrefixExpression#ReturnStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#NumberLiteral#ReturnStatement#IfStatement#IfStatement#NumberLiteral#ReturnStatement#Block#MethodDeclaration#AnonymousClassDeclaration#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(AnonymousClassDeclaration(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)IfStatement)IfStatement(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)MethodDeclaration)AnonymousClassDeclaration)ClassInstanceCreation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "for each NFA config in d, look for \"predicate required\" sign set during nondeterminism resolution. Add the predicate edges sorted by the alternative number; I'm fairly sure that I could walk the configs backwards so they are added to the predDFATarget in the right order, but it's best to make sure. Predicates succeed in the order they are specifed.  Alt i wins over alt i+1 if both predicates are true.", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.misc.OrderedHashSet.size", "org.antlr.misc.OrderedHashSet.get", "java.util.List.add", "java.util.Collections.sort", "java.util.List.size", "java.util.List.get", "org.antlr.analysis.DFA.getAcceptState", "org.antlr.analysis.DFA.newState", "org.antlr.analysis.NFA.getState", "org.antlr.analysis.DFAState.addNFAConfiguration", "org.antlr.analysis.DFAState.setAcceptState", "org.antlr.analysis.DFA.setAcceptState", "org.antlr.analysis.DFA.addState", "org.antlr.analysis.DFA.setState", "org.antlr.analysis.PredicateLabel.<init>", "org.antlr.analysis.DFAState.addTransition"], "call_func_parameter": [[""], [""], ["int"], ["java.lang.Object"], ["java.util.List", "java.util.Comparator"], [""], ["int"], ["int"], [""], ["int"], ["org.antlr.analysis.NFAState", "int", "org.antlr.analysis.NFAContext", "org.antlr.analysis.SemanticContext"], ["boolean"], ["int", "org.antlr.analysis.DFAState"], ["org.antlr.analysis.DFAState"], ["int", "org.antlr.analysis.DFAState"], ["org.antlr.analysis.SemanticContext"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.Label"]], "passed_comments": [{"org.antlr.analysis.DFA.addState": "Add a new DFA state to this DFA if not already present. To force an acyclic, fixed maximum depth DFA, just always return the incoming state.  By not reusing old states, no cycles can be created.  If we're doing fixed k lookahead don't updated uniqueStates, just return incoming state, which indicates it's a new state."}, {"org.antlr.analysis.DFAState.addTransition": "Add a transition from this state to target with label.  Return the transition number from 0..n-1."}]}, {"index": "413", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getDescription", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getDescription() {\n\t\treturn dfa.getNFADecisionStartState().getDescription();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a string like \"3:22: ( A {;} | B )\" that describes this decision.", "call_func_name": ["org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.analysis.NFAState.getDescription"], "call_func_parameter": [[""], [""]], "passed_comments": "/"}, {"index": "414", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.isDeterministic", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isDeterministic() {\n\t\tif ( danglingStates.isEmpty() &&\n\t\t\t statesWithSyntacticallyAmbiguousAltsSet.isEmpty() &&\n\t\t\t dfa.getUnreachableAlts().isEmpty() )\n\t\t{\n\t\t\treturn true;\n\t\t}\n\n\t\tif ( statesWithSyntacticallyAmbiguousAltsSet.size()>0 ) {\n\t\t\tfor (DFAState d : statesWithSyntacticallyAmbiguousAltsSet) {\n\t\t\t\tif ( !statesResolvedWithSemanticPredicatesSet.contains(d) ) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// no syntactically ambig alts were left unresolved by predicates\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#EnhancedForStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If no states are dead-ends, no alts are unreachable, there are no nondeterminisms unresolved by syn preds, all is ok with decision.", "call_func_name": ["java.util.Set.isEmpty", "org.antlr.analysis.DFA.getUnreachableAlts", "java.util.List.isEmpty", "java.util.Set.size", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.util.Set.contains"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], [""], ["java.lang.Object"]], "passed_comments": [{"org.antlr.analysis.DFA.getUnreachableAlts": "Return a list of Integer alt numbers for which no lookahead could be computed or for which no single DFA accept state predicts those alts.  Must call verify() first before this makes sense."}]}, {"index": "415", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.analysisOverflowed", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean analysisOverflowed() {\n\t\treturn stateToRecursionOverflowConfigurationsMap.size()>0;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Took too long to analyze a DFA", "call_func_name": ["org.antlr.misc.MultiMap.size"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "416", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.isNonLLStarDecision", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isNonLLStarDecision() {\n\t\treturn nonLLStarDecision;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Found recursion in &gt; 1 alt", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "417", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getNumberOfStates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getNumberOfStates() {\n\t\treturn dfa.getNumberOfStates();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "How many states does the DFA predictor have?", "call_func_name": ["org.antlr.analysis.DFA.getNumberOfStates"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "418", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getUnreachableAlts", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Integer> getUnreachableAlts() {\n\t\treturn dfa.getUnreachableAlts();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get a list of all unreachable alternatives for this decision.  There may be multiple alternatives with ambiguous input sequences, but this is the overall list of unreachable alternatives (either due to conflict resolution or alts w/o accept states).", "call_func_name": ["org.antlr.analysis.DFA.getUnreachableAlts"], "call_func_parameter": [[""]], "passed_comments": [{"org.antlr.analysis.DFA.getUnreachableAlts": "Return a list of Integer alt numbers for which no lookahead could be computed or for which no single DFA accept state predicts those alts.  Must call verify() first before this makes sense."}]}, {"index": "419", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getDanglingStates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<DFAState> getDanglingStates() {\n\t\treturn danglingStates;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return set of states w/o emanating edges and w/o resolving sem preds. These states come about because the analysis algorithm had to terminate early to avoid infinite recursion for example (due to left recursion perhaps).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "420", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getNonDeterministicAltsForState", "methodParameterType": "DFAState#", "methodParameterName": "targetState#", "methodBody": "public List<Integer> getNonDeterministicAltsForState(DFAState targetState) {\n\t\tSet<Integer> nondetAlts = targetState.getNonDeterministicAlts();\n\t\tif ( nondetAlts==null ) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Integer> sorted = new LinkedList<Integer>();\n\t\tsorted.addAll(nondetAlts);\n\t\tCollections.sort(sorted); // make sure it's 1, 2, ...\n\t\treturn sorted;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the sorted list of alts that conflict within a single state. Note that predicates may resolve the conflict.", "call_func_name": ["org.antlr.analysis.DFAState.getNonDeterministicAlts", "java.util.LinkedList.<init>", "java.util.List.addAll", "java.util.Collections.sort"], "call_func_parameter": [[""], [""], ["java.util.Collection"], ["java.util.List"]], "passed_comments": "/"}, {"index": "421", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getDFAStatesWithSyntacticallyAmbiguousAlts", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<DFAState> getDFAStatesWithSyntacticallyAmbiguousAlts() {\n\t\treturn statesWithSyntacticallyAmbiguousAltsSet;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return all DFA states in this DFA that have NFA configurations that conflict.  You must report a problem for each state in this set because each state represents a different input sequence.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "422", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getDisabledAlternatives", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public Set<Integer> getDisabledAlternatives(DFAState d) {\n\t\treturn d.getDisabledAlternatives();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Which alts were specifically turned off to resolve nondeterminisms? This is different than the unreachable alts.  Disabled doesn't mean that the alternative is totally unreachable necessarily, it just means that for this DFA state, that alt is disabled.  There may be other accept states for that alt that make an alt reachable.", "call_func_name": ["org.antlr.analysis.DFAState.getDisabledAlternatives"], "call_func_parameter": [[""]], "passed_comments": [{"org.antlr.analysis.DFAState.getDisabledAlternatives": "When more than one alternative can match the same input, the first alternative is chosen to resolve the conflict.  The other alts are \"turned off\" by setting the \"resolved\" flag in the NFA configurations.  Return the set of disabled alternatives.  For a : A | A | A ; this method returns {2,3} as disabled.  This does not mean that the alternative is totally unreachable, it just means that for this DFA state, that alt is disabled.  There may be other accept states for that alt."}]}, {"index": "423", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.removeRecursiveOverflowState", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public void removeRecursiveOverflowState(DFAState d) {\n\t\tInteger stateI = Utils.integer(d.stateNumber);\n\t\tstateToRecursionOverflowConfigurationsMap.remove(stateI);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If a recursion overflow is resolve with predicates, then we need to shut off the warning that would be generated.", "call_func_name": ["org.antlr.misc.Utils.integer", "org.antlr.misc.MultiMap.remove"], "call_func_parameter": [["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "424", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getSampleNonDeterministicInputSequence", "methodParameterType": "DFAState#", "methodParameterName": "targetState#", "methodBody": "public List<Label> getSampleNonDeterministicInputSequence(DFAState targetState) {\n\t\tSet<DFAState> dfaStates = getDFAPathStatesToTarget(targetState);\n\t\tstatesVisitedDuringSampleSequence = new HashSet<Integer>();\n\t\tList<Label> labels = new ArrayList<Label>(); // may access ith element; use array\n\t\tif ( dfa==null || dfa.startState==null ) {\n\t\t\treturn labels;\n\t\t}\n\t\tgetSampleInputSequenceUsingStateSet(dfa.startState,\n\t\t\t\t\t\t\t\t\t\t\ttargetState,\n\t\t\t\t\t\t\t\t\t\t\tdfaStates,\n\t\t\t\t\t\t\t\t\t\t\tlabels);\n\t\treturn labels;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a List&lt;Label&gt; indicating an input sequence that can be matched from the start state of the DFA to the targetState (which is known to have a problem).", "call_func_name": ["org.antlr.analysis.DecisionProbe.getDFAPathStatesToTarget", "java.util.HashSet.<init>", "java.util.ArrayList.<init>", "org.antlr.analysis.DecisionProbe.getSampleInputSequenceUsingStateSet"], "call_func_parameter": [["org.antlr.analysis.DFAState"], [""], [""], ["org.antlr.analysis.State", "org.antlr.analysis.State", "java.util.Set", "java.util.List"]], "passed_comments": [{"org.antlr.analysis.DecisionProbe.getSampleInputSequenceUsingStateSet": "Given a start state and a final state, find a list of edge labels between the two ignoring epsilon.  Limit your scan to a set of states passed in.  This is used to show a sample input sequence that is nondeterministic with respect to this decision.  Return List&lt;Label&gt; as a parameter.  The incoming states set must be all states that lead from startState to targetState and no others so this algorithm doesn't take a path that eventually leads to a state other than targetState. Don't follow loops, leading to short (possibly shortest) path."}]}, {"index": "425", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getInputSequenceDisplay", "methodParameterType": "List<? extends Label>#", "methodParameterName": "labels#", "methodBody": "public String getInputSequenceDisplay(List<? extends Label> labels) {\n        Grammar g = dfa.nfa.grammar;\n\t\tStringBuilder buf = new StringBuilder();\n\t\tfor (Iterator<? extends Label> it = labels.iterator(); it.hasNext();) {\n\t\t\tLabel label = it.next();\n\t\t\tbuf.append(label.toString(g));\n\t\t\tif ( it.hasNext() && g.type!=Grammar.LEXER ) {\n\t\t\t\tbuf.append(' ');\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given List&lt;Label&gt;, return a String with a useful representation of the associated input string.  One could show something different for lexers and parsers, for example.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.analysis.Label.toString", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], [""], [""], [""], ["org.antlr.tool.Grammar"], ["java.lang.String"], ["char"], [""]], "passed_comments": "/"}, {"index": "426", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getNFAPathStatesForAlt", "methodParameterType": "int#int#List<? extends Label>#", "methodParameterName": "firstAlt#alt#labels#", "methodBody": "public List<? extends NFAState> getNFAPathStatesForAlt(int firstAlt,\n\t\t\t\t\t\t\t\t\t   int alt,\n\t\t\t\t\t\t\t\t\t   List<? extends Label> labels)\n\t{\n\t\tNFAState nfaStart = dfa.getNFADecisionStartState();\n\t\tList<NFAState> path = new LinkedList<NFAState>();\n\t\t// first add all NFA states leading up to altStart state\n\t\tfor (int a=firstAlt; a<=alt; a++) {\n\t\t\tNFAState s =\n\t\t\t\tdfa.nfa.grammar.getNFAStateForAltOfDecision(nfaStart,a);\n\t\t\tpath.add(s);\n\t\t}\n\n\t\t// add first state of actual alt\n\t\tNFAState altStart = dfa.nfa.grammar.getNFAStateForAltOfDecision(nfaStart,alt);\n\t\tNFAState isolatedAltStart = (NFAState)altStart.transition[0].target;\n\t\tpath.add(isolatedAltStart);\n\n\t\t// add the actual path now\n\t\tstatesVisitedAtInputDepth = new HashSet<String>();\n\t\tgetNFAPath(isolatedAltStart,\n\t\t\t\t   0,\n\t\t\t\t   labels,\n\t\t\t\t   path);\n        return path;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given an alternative associated with a nondeterministic DFA state, find the path of NFA states associated with the labels sequence. Useful tracing where in the NFA, a single input sequence can be matched.  For different alts, you should get different NFA paths. The first NFA state for all NFA paths will be the same: the starting NFA state of the first nondeterministic alt.  Imagine (A|B|A|A): 5-&gt;9-A-&gt;o | 6-&gt;10-B-&gt;o | 7-&gt;11-A-&gt;o | 8-&gt;12-A-&gt;o There are 3 nondeterministic alts.  The paths should be: 5 9 ... 5 6 7 11 ... 5 6 7 8 12 ... The NFA path matching the sample input sequence (labels) is computed using states 9, 11, and 12 rather than 5, 7, 8 because state 5, for example can get to all ambig paths.  Must isolate for each alt (hence, the extra state beginning each alt in my NFA structures).  Here, firstAlt=1.", "call_func_name": ["org.antlr.analysis.DFA.getNFADecisionStartState", "java.util.LinkedList.<init>", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision", "java.util.List.add", "java.util.HashSet.<init>", "org.antlr.analysis.DecisionProbe.getNFAPath"], "call_func_parameter": [[""], [""], ["org.antlr.analysis.NFAState", "int"], ["java.lang.Object"], [""], ["org.antlr.analysis.NFAState", "int", "java.util.List", "java.util.List"]], "passed_comments": [{"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}, {"org.antlr.analysis.DecisionProbe.getNFAPath": "Given a sample input sequence, you usually would like to know the path taken through the NFA.  Return the list of NFA states visited while matching a list of labels.  This cannot use the usual interpreter, which does a deterministic walk.  We need to be able to take paths that are turned off during nondeterminism resolution. So, just do a depth-first walk traversing edges labeled with the current label.  Return true if a path was found emanating from state s."}]}, {"index": "427", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getSemanticContextForAlt", "methodParameterType": "DFAState#int#", "methodParameterName": "d#alt#", "methodBody": "public SemanticContext getSemanticContextForAlt(DFAState d, int alt) {\n\t\tMap<Integer, SemanticContext> altToPredMap = stateToAltSetWithSemanticPredicatesMap.get(d);\n\t\tif ( altToPredMap==null ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn altToPredMap.get(Utils.integer(alt));\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Each state in the DFA represents a different input sequence for an alt of the decision.  Given a DFA state, what is the semantic predicate context for a particular alt.", "call_func_name": ["java.util.Map.get", "org.antlr.misc.Utils.integer"], "call_func_parameter": [["java.lang.Object"], ["int"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "428", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.hasPredicate", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean hasPredicate() {\n\t\treturn stateToAltSetWithSemanticPredicatesMap.size()>0;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "At least one alt refs a sem or syn pred", "call_func_name": ["java.util.Map.size"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "429", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getIncompletelyCoveredAlts", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public Map<Integer, Set<Token>> getIncompletelyCoveredAlts(DFAState d) {\n\t\treturn stateToIncompletelyCoveredAltsMap.get(d);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of alts whose predicate context was insufficient to resolve a nondeterminism for state d.", "call_func_name": ["java.util.Map.get"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "430", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.stripWildCardAlts", "methodParameterType": "Set<Integer>#", "methodParameterName": "disabledAlts#", "methodBody": "protected void stripWildCardAlts(Set<Integer> disabledAlts) {\n\t\tList<Integer> sortedDisableAlts = new ArrayList<Integer>(disabledAlts);\n\t\tCollections.sort(sortedDisableAlts);\n\t\tInteger lastAlt =\n\t\t\tsortedDisableAlts.get(sortedDisableAlts.size()-1);\n\t\tGrammarAST blockAST =\n\t\t\tdfa.nfa.grammar.getDecisionBlockAST(dfa.decisionNumber);\n\t\t//System.out.println(\"block with error = \"+blockAST.toStringTree());\n\t\tGrammarAST lastAltAST;\n\t\tif ( blockAST.getChild(0).getType()==ANTLRParser.OPTIONS ) {\n\t\t\t// if options, skip first child: ( options { ( = greedy false ) )\n\t\t\tlastAltAST = (GrammarAST)blockAST.getChild(lastAlt.intValue());\n\t\t}\n\t\telse {\n\t\t\tlastAltAST = (GrammarAST)blockAST.getChild(lastAlt -1);\n\t\t}\n\t\t//System.out.println(\"last alt is \"+lastAltAST.toStringTree());\n\t\t// if last alt looks like ( ALT . <end-of-alt> ) then wildcard\n\t\t// Avoid looking at optional blocks etc... that have last alt\n\t\t// as the EOB:\n\t\t// ( BLOCK ( ALT 'else' statement <end-of-alt> ) <end-of-block> )\n\t\tif ( lastAltAST.getType()!=ANTLRParser.EOB &&\n\t\t\t lastAltAST.getChild(0).getType()== ANTLRParser.WILDCARD &&\n\t\t\t lastAltAST.getChild(1).getType()== ANTLRParser.EOA )\n\t\t{\n\t\t\t//System.out.println(\"wildcard\");\n\t\t\tdisabledAlts.remove(lastAlt);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#CastExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#CastExpression#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)CastExpression)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)CastExpression)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Get the last disabled alt number and check in the grammar to see if that alt is a simple wildcard.  If so, treat like an else clause and don't emit the error.  Strip out the last alt if it's wildcard.", "call_func_name": ["java.util.ArrayList.<init>", "java.util.Collections.sort", "java.util.List.size", "java.util.List.get", "org.antlr.tool.Grammar.getDecisionBlockAST", "org.antlr.tool.GrammarAST.getChild", "org.antlr.runtime.tree.Tree.getType", "java.lang.Integer.intValue", "org.antlr.tool.GrammarAST.getType", "java.util.Set.remove"], "call_func_parameter": [["java.util.Collection"], ["java.util.List"], [""], ["int"], ["int"], ["int"], [""], [""], [""], ["java.lang.Object"]], "passed_comments": [{"org.antlr.runtime.tree.Tree.getType": "Return a token type; needed for tree parsing"}]}, {"index": "431", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.reportDanglingState", "methodParameterType": "DFAState#", "methodParameterName": "d#", "methodBody": "public void reportDanglingState(DFAState d) {\n\t\tdanglingStates.add(d);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Report the fact that DFA state d is not a state resolved with predicates and yet it has no emanating edges.  Usually this is a result of the closure/reach operations being unable to proceed", "call_func_name": ["java.util.Set.add"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "432", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.reportNonLLStarDecision", "methodParameterType": "DFA#", "methodParameterName": "dfa#", "methodBody": "public void reportNonLLStarDecision(DFA dfa) {\n\t\t/*\n\t\tSystem.out.println(\"non-LL(*) DFA \"+dfa.decisionNumber+\", alts: \"+\n\t\t\t\t\t\t   dfa.recursiveAltSet.toList());\n\t\t\t\t\t\t   */\n\t\tnonLLStarDecision = true;\n\t\tdfa.nfa.grammar.numNonLLStar++;\n\t\taltsWithProblem.addAll(dfa.recursiveAltSet.toList());\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Report that at least 2 alts have recursive constructs.  There is no way to build a DFA so we terminated.", "call_func_name": ["org.antlr.misc.IntSet.toList", "java.util.Set.addAll"], "call_func_parameter": [[""], ["java.util.Collection"]], "passed_comments": "/"}, {"index": "433", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.reportLexerRuleNondeterminism", "methodParameterType": "DFAState#Set<Integer>#", "methodParameterName": "d#nondeterministicAlts#", "methodBody": "public void reportLexerRuleNondeterminism(DFAState d, Set<Integer> nondeterministicAlts) {\n\t\tstateToSyntacticallyAmbiguousTokensRuleAltsMap.put(d,nondeterministicAlts);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Currently the analysis reports issues between token definitions, but we don't print out warnings in favor of just picking the first token definition found in the grammar ala lex/flex.", "call_func_name": ["java.util.Map.put"], "call_func_parameter": [["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "434", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.reportAltPredicateContext", "methodParameterType": "DFAState#Map<Integer,? extends SemanticContext>#", "methodParameterName": "d#altPredicateContext#", "methodBody": "public void reportAltPredicateContext(DFAState d, Map<Integer, ? extends SemanticContext> altPredicateContext) {\n\t\tMap<Integer, SemanticContext> copy = new HashMap<Integer, SemanticContext>();\n\t\tcopy.putAll(altPredicateContext);\n\t\tstateToAltSetWithSemanticPredicatesMap.put(d,copy);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Report the list of predicates found for each alternative; copy the list because this set gets altered later by the method tryToResolveWithSemanticPredicates() while flagging NFA configurations in d as resolved.", "call_func_name": ["java.util.HashMap.<init>", "java.util.Map.putAll", "java.util.Map.put"], "call_func_parameter": [[""], ["java.util.Map"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "435", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.reachesState", "methodParameterType": "DFAState#DFAState#Set<DFAState>#", "methodParameterName": "startState#targetState#states#", "methodBody": "protected boolean reachesState(DFAState startState,\n\t\t\t\t\t\t\t\t   DFAState targetState,\n\t\t\t\t\t\t\t\t   Set<DFAState> states) {\n\t\tif ( startState==targetState ) {\n\t\t\tstates.add(targetState);\n\t\t\t//System.out.println(\"found target DFA state \"+targetState.getStateNumber());\n\t\t\tstateReachable.put(startState.stateNumber, REACHABLE_YES);\n\t\t\treturn true;\n\t\t}\n\n\t\tDFAState s = startState;\n\t\t// avoid infinite loops\n\t\tstateReachable.put(s.stateNumber, REACHABLE_BUSY);\n\n\t\t// look for a path to targetState among transitions for this state\n\t\t// stop when you find the first one; I'm pretty sure there is\n\t\t// at most one path to any DFA state with conflicting predictions\n\t\tfor (int i=0; i<s.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = s.transition(i);\n\t\t\tDFAState edgeTarget = (DFAState)t.target;\n\t\t\tInteger targetStatus = stateReachable.get(edgeTarget.stateNumber);\n\t\t\tif ( targetStatus==REACHABLE_BUSY ) { // avoid cycles; they say nothing\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( targetStatus==REACHABLE_YES ) { // return success!\n\t\t\t\tstateReachable.put(s.stateNumber, REACHABLE_YES);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tif ( targetStatus==REACHABLE_NO ) { // try another transition\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// if null, target must be REACHABLE_UNKNOWN (i.e., unvisited)\n\t\t\tif ( reachesState(edgeTarget, targetState, states) ) {\n\t\t\t\tstates.add(s);\n\t\t\t\tstateReachable.put(s.stateNumber, REACHABLE_YES);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tstateReachable.put(s.stateNumber, REACHABLE_NO);\n\t\treturn false; // no path to targetState found.\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a start state and a target state, return true if start can reach target state.  Also, compute the set of DFA states that are on a path from start to target; return in states parameter.", "call_func_name": ["java.util.Set.add", "java.lang.Integer.valueOf", "java.util.Map.put", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "java.util.Map.get", "org.antlr.analysis.DecisionProbe.reachesState"], "call_func_parameter": [["java.lang.Object"], ["int"], ["java.lang.Object", "java.lang.Object"], [""], ["int"], ["java.lang.Object"], ["org.antlr.analysis.DFAState", "org.antlr.analysis.DFAState", "java.util.Set"]], "passed_comments": [{"org.antlr.analysis.DecisionProbe.reachesState": "Given a start state and a target state, return true if start can reach target state.  Also, compute the set of DFA states that are on a path from start to target; return in states parameter."}]}, {"index": "436", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getSampleInputSequenceUsingStateSet", "methodParameterType": "State#State#Set<DFAState>#List<Label>#", "methodParameterName": "startState#targetState#states#labels#", "methodBody": "protected void getSampleInputSequenceUsingStateSet(State startState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   State targetState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   Set<DFAState> states,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   List<Label> labels)\n\t{\n\t\tstatesVisitedDuringSampleSequence.add(startState.stateNumber);\n\n\t\t// pick the first edge in states as the one to traverse\n\t\tfor (int i=0; i<startState.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = startState.transition(i);\n\t\t\tDFAState edgeTarget = (DFAState)t.target;\n\t\t\tif ( states.contains(edgeTarget) &&\n\t\t\t\t !statesVisitedDuringSampleSequence.contains(edgeTarget.stateNumber) )\n\t\t\t{\n\t\t\t\tlabels.add(t.label); // traverse edge and track label\n\t\t\t\tif ( edgeTarget!=targetState ) {\n\t\t\t\t\t// get more labels if not at target\n\t\t\t\t\tgetSampleInputSequenceUsingStateSet(edgeTarget,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ttargetState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstates,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlabels);\n\t\t\t\t}\n\t\t\t\t// done with this DFA state as we've found a good path to target\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tlabels.add(new Label(Label.EPSILON)); // indicate no input found\n\t\t// this happens on a : {p1}? a | A ;\n\t\t//ErrorManager.error(ErrorManager.MSG_CANNOT_COMPUTE_SAMPLE_INPUT_SEQ);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Given a start state and a final state, find a list of edge labels between the two ignoring epsilon.  Limit your scan to a set of states passed in.  This is used to show a sample input sequence that is nondeterministic with respect to this decision.  Return List&lt;Label&gt; as a parameter.  The incoming states set must be all states that lead from startState to targetState and no others so this algorithm doesn't take a path that eventually leads to a state other than targetState. Don't follow loops, leading to short (possibly shortest) path.", "call_func_name": ["java.lang.Integer.valueOf", "java.util.Set.add", "org.antlr.analysis.State.getNumberOfTransitions", "org.antlr.analysis.State.transition", "java.util.Set.contains", "java.util.List.add", "org.antlr.analysis.DecisionProbe.getSampleInputSequenceUsingStateSet", "org.antlr.analysis.Label.<init>"], "call_func_parameter": [["int"], ["java.lang.Object"], [""], ["int"], ["java.lang.Object"], ["java.lang.Object"], ["org.antlr.analysis.State", "org.antlr.analysis.State", "java.util.Set", "java.util.List"], ["int"]], "passed_comments": [{"org.antlr.analysis.DecisionProbe.getSampleInputSequenceUsingStateSet": "Given a start state and a final state, find a list of edge labels between the two ignoring epsilon.  Limit your scan to a set of states passed in.  This is used to show a sample input sequence that is nondeterministic with respect to this decision.  Return List&lt;Label&gt; as a parameter.  The incoming states set must be all states that lead from startState to targetState and no others so this algorithm doesn't take a path that eventually leads to a state other than targetState. Don't follow loops, leading to short (possibly shortest) path."}]}, {"index": "437", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getNFAPath", "methodParameterType": "NFAState#int#List<? extends Label>#List<? super NFAState>#", "methodParameterName": "s#labelIndex#labels#path#", "methodBody": "protected boolean getNFAPath(NFAState s,     // starting where?\n\t\t\t\t\t\t\t\t int labelIndex, // 0..labels.size()-1\n\t\t\t\t\t\t\t\t List<? extends Label> labels,    // input sequence\n\t\t\t\t\t\t\t\t List<? super NFAState> path)      // output list of NFA states\n\t{\n\t\t// track a visit to state s at input index labelIndex if not seen\n\t\tString thisStateKey = getStateLabelIndexKey(s.stateNumber,labelIndex);\n\t\tif ( statesVisitedAtInputDepth.contains(thisStateKey) ) {\n\t\t\t/*\n\t\t\tSystem.out.println(\"### already visited \"+s.stateNumber+\" previously at index \"+\n\t\t\t\t\t\t   labelIndex);\n\t\t\t*/\n\t\t\treturn false;\n\t\t}\n\t\tstatesVisitedAtInputDepth.add(thisStateKey);\n\n\t\t/*\n\t\tSystem.out.println(\"enter state \"+s.stateNumber+\" visited states: \"+\n\t\t\t\t\t\t   statesVisitedAtInputDepth);\n        */\n\n\t\t// pick the first edge whose target is in states and whose\n\t\t// label is labels[labelIndex]\n\t\tfor (int i=0; i<s.getNumberOfTransitions(); i++) {\n\t\t\tTransition t = s.transition[i];\n\t\t\tNFAState edgeTarget = (NFAState)t.target;\n\t\t\tLabel label = (Label)labels.get(labelIndex);\n\t\t\t/*\n\t\t\tSystem.out.println(s.stateNumber+\"-\"+\n\t\t\t\t\t\t\t   t.label.toString(dfa.nfa.grammar)+\"->\"+\n\t\t\t\t\t\t\t   edgeTarget.stateNumber+\" ==\"+\n\t\t\t\t\t\t\t   label.toString(dfa.nfa.grammar)+\"?\");\n\t\t\t*/\n\t\t\tif ( t.label.isEpsilon() || t.label.isSemanticPredicate() ) {\n\t\t\t\t// nondeterministically backtrack down epsilon edges\n\t\t\t\tpath.add(edgeTarget);\n\t\t\t\tboolean found =\n\t\t\t\t\tgetNFAPath(edgeTarget, labelIndex, labels, path);\n\t\t\t\tif ( found ) {\n\t\t\t\t\tstatesVisitedAtInputDepth.remove(thisStateKey);\n\t\t\t\t\treturn true; // return to \"calling\" state\n\t\t\t\t}\n\t\t\t\tpath.remove(path.size()-1); // remove; didn't work out\n\t\t\t\tcontinue; // look at the next edge\n\t\t\t}\n\t\t\tif ( t.label.matches(label) ) {\n\t\t\t\tpath.add(edgeTarget);\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"found label \"+\n\t\t\t\t\t\t\t\t   t.label.toString(dfa.nfa.grammar)+\n\t\t\t\t\t\t\t\t   \" at state \"+s.stateNumber+\"; labelIndex=\"+labelIndex);\n\t\t\t\t*/\n\t\t\t\tif ( labelIndex==labels.size()-1 ) {\n\t\t\t\t\t// found last label; done!\n\t\t\t\t\tstatesVisitedAtInputDepth.remove(thisStateKey);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t// otherwise try to match remaining input\n\t\t\t\tboolean found =\n\t\t\t\t\tgetNFAPath(edgeTarget, labelIndex+1, labels, path);\n\t\t\t\tif ( found ) {\n\t\t\t\t\tstatesVisitedAtInputDepth.remove(thisStateKey);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"backtrack; path from \"+s.stateNumber+\"->\"+\n\t\t\t\t\t\t\t\t   t.label.toString(dfa.nfa.grammar)+\" didn't work\");\n\t\t\t\t*/\n\t\t\t\tpath.remove(path.size()-1); // remove; didn't work out\n\t\t\t\tcontinue; // keep looking for a path for labels\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"no epsilon or matching edge; removing \"+thisStateKey);\n\t\t// no edge was found matching label; is ok, some state will have it\n\t\tstatesVisitedAtInputDepth.remove(thisStateKey);\n\t\treturn false;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a sample input sequence, you usually would like to know the path taken through the NFA.  Return the list of NFA states visited while matching a list of labels.  This cannot use the usual interpreter, which does a deterministic walk.  We need to be able to take paths that are turned off during nondeterminism resolution. So, just do a depth-first walk traversing edges labeled with the current label.  Return true if a path was found emanating from state s.", "call_func_name": ["org.antlr.analysis.DecisionProbe.getStateLabelIndexKey", "java.util.Set.contains", "java.util.Set.add", "org.antlr.analysis.NFAState.getNumberOfTransitions", "java.util.List.get", "org.antlr.analysis.Label.isEpsilon", "org.antlr.analysis.Label.isSemanticPredicate", "java.util.List.add", "org.antlr.analysis.DecisionProbe.getNFAPath", "java.util.Set.remove", "java.util.List.size", "java.util.List.remove", "org.antlr.analysis.Label.matches"], "call_func_parameter": [["int", "int"], ["java.lang.Object"], ["java.lang.Object"], [""], ["int"], [""], [""], ["java.lang.Object"], ["org.antlr.analysis.NFAState", "int", "java.util.List", "java.util.List"], ["java.lang.Object"], [""], ["int"], ["org.antlr.analysis.Label"]], "passed_comments": [{"org.antlr.analysis.DecisionProbe.getNFAPath": "Given a sample input sequence, you usually would like to know the path taken through the NFA.  Return the list of NFA states visited while matching a list of labels.  This cannot use the usual interpreter, which does a deterministic walk.  We need to be able to take paths that are turned off during nondeterminism resolution. So, just do a depth-first walk traversing edges labeled with the current label.  Return true if a path was found emanating from state s."}]}, {"index": "438", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/DecisionProbe.java", "methodName": "org.antlr.analysis.DecisionProbe.getTokenNameForTokensRuleAlt", "methodParameterType": "int#", "methodParameterName": "alt#", "methodBody": "public String getTokenNameForTokensRuleAlt(int alt) {\n\t\tNFAState decisionState = dfa.getNFADecisionStartState();\n\t\tNFAState altState =\n\t\t\tdfa.nfa.grammar.getNFAStateForAltOfDecision(decisionState,alt);\n\t\tNFAState decisionLeft = (NFAState)altState.transition[0].target;\n\t\tRuleClosureTransition ruleCallEdge =\n\t\t\t(RuleClosureTransition)decisionLeft.transition[0];\n\t\tNFAState ruleStartState = (NFAState)ruleCallEdge.target;\n\t\t//System.out.println(\"alt = \"+decisionLeft.getEnclosingRule());\n\t\treturn ruleStartState.enclosingRule.name;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From an alt number associated with artificial Tokens rule, return the name of the token that is associated with that alt.", "call_func_name": ["org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}]}, {"index": "439", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/SemanticContext.java", "methodName": "org.antlr.analysis.SemanticContext.getGatedPredicateContext", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public abstract SemanticContext getGatedPredicateContext();", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Given a semantic context expression tree, return a tree with all nongated predicates set to true and then reduced.  So p&amp;&amp;(q||r) would return p&amp;&amp;r if q is nongated but p and r are gated.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "440", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/SemanticContext.java", "methodName": "org.antlr.analysis.SemanticContext.genExpr", "methodParameterType": "CodeGenerator#STGroup#DFA#", "methodParameterName": "generator#templates#dfa#", "methodBody": "public abstract ST genExpr(CodeGenerator generator,\n\t\t\t\t\t\t\t\t\t\t   STGroup templates,\n\t\t\t\t\t\t\t\t\t\t   DFA dfa);", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Generate an expression that will evaluate the semantic context, given a set of output templates.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "441", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/analysis/SemanticContext.java", "methodName": "org.antlr.analysis.SemanticContext.trackUseOfSyntacticPredicates", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public void trackUseOfSyntacticPredicates(Grammar g) {\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block)Block)MethodDeclaration", "methodDoc": "Notify the indicated grammar of any syn preds used within this context", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "442", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.create", "methodParameterType": "int#int#", "methodParameterName": "a#b#", "methodBody": "public static Interval create(int a, int b) {\n\t\t//return new Interval(a,b);\n\t\t// cache just a..a\n\t\tif ( a!=b || a<0 || a>INTERVAL_POOL_MAX_VALUE ) {\n\t\t\treturn new Interval(a,b);\n\t\t}\n\t\tif ( cache[a]==null ) {\n\t\t\tcache[a] = new Interval(a,a);\n\t\t}\n\t\treturn cache[a];\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Interval objects are used readonly so share all with the same single value a==b up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new Interval object with a..a in it.  On Java.g, 218623 IntervalSets have a..a (set with 1 element).", "call_func_name": ["org.antlr.misc.Interval.<init>"], "call_func_parameter": [["int", "int"]], "passed_comments": "/"}, {"index": "443", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.startsBeforeDisjoint", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean startsBeforeDisjoint(Interval other) {\n\t\treturn this.a<other.a && this.b<other.a;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Does this start completely before other? Disjoint", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "444", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.startsBeforeNonDisjoint", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean startsBeforeNonDisjoint(Interval other) {\n\t\treturn this.a<=other.a && this.b>=other.a;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Does this start at or before other? Nondisjoint", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "445", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.startsAfter", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean startsAfter(Interval other) { return this.a>other.a; }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Does this.a start after other.b? May or may not be disjoint", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "446", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.startsAfterDisjoint", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean startsAfterDisjoint(Interval other) {\n\t\treturn this.a>other.b;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Does this start completely after other? Disjoint", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "447", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.startsAfterNonDisjoint", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean startsAfterNonDisjoint(Interval other) {\n\t\treturn this.a>other.a && this.a<=other.b; // this.b>=other.b implied\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Does this start after other? NonDisjoint", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "448", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.disjoint", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean disjoint(Interval other) {\n\t\treturn startsBeforeDisjoint(other) || startsAfterDisjoint(other);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Are both ranges disjoint? I.e., no overlap?", "call_func_name": ["org.antlr.misc.Interval.startsBeforeDisjoint", "org.antlr.misc.Interval.startsAfterDisjoint"], "call_func_parameter": [["org.antlr.misc.Interval"], ["org.antlr.misc.Interval"]], "passed_comments": [{"org.antlr.misc.Interval.startsBeforeDisjoint": "Does this start completely before other? Disjoint"}, {"org.antlr.misc.Interval.startsAfterDisjoint": "Does this start completely after other? Disjoint"}]}, {"index": "449", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.adjacent", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public boolean adjacent(Interval other) {\n\t\treturn this.a == other.b+1 || this.b == other.a-1;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Are two intervals adjacent such as 0..41 and 42..42?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "450", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.union", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public Interval union(Interval other) {\n\t\treturn Interval.create(Math.min(a,other.a), Math.max(b,other.b));\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the interval computed from combining this and other", "call_func_name": ["java.lang.Math.min", "java.lang.Math.max", "org.antlr.misc.Interval.create"], "call_func_parameter": [["int", "int"], ["int", "int"], ["int", "int"]], "passed_comments": [{"org.antlr.misc.Interval.create": "Interval objects are used readonly so share all with the same single value a==b up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new Interval object with a..a in it.  On Java.g, 218623 IntervalSets have a..a (set with 1 element)."}]}, {"index": "451", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.intersection", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public Interval intersection(Interval other) {\n\t\treturn Interval.create(Math.max(a,other.a), Math.min(b,other.b));\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the interval in common between this and o", "call_func_name": ["java.lang.Math.max", "java.lang.Math.min", "org.antlr.misc.Interval.create"], "call_func_parameter": [["int", "int"], ["int", "int"], ["int", "int"]], "passed_comments": [{"org.antlr.misc.Interval.create": "Interval objects are used readonly so share all with the same single value a==b up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new Interval object with a..a in it.  On Java.g, 218623 IntervalSets have a..a (set with 1 element)."}]}, {"index": "452", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Interval.java", "methodName": "org.antlr.misc.Interval.differenceNotProperlyContained", "methodParameterType": "Interval#", "methodParameterName": "other#", "methodBody": "public Interval differenceNotProperlyContained(Interval other) {\n\t\tInterval diff = null;\n\t\t// other.a to left of this.a (or same)\n\t\tif ( other.startsBeforeNonDisjoint(this) ) {\n\t\t\tdiff = Interval.create(Math.max(this.a,other.b+1),\n\t\t\t\t\t\t\t\t   this.b);\n\t\t}\n\n\t\t// other.a to right of this.a\n\t\telse if ( other.startsAfterNonDisjoint(this) ) {\n\t\t\tdiff = Interval.create(this.a, other.a-1);\n\t\t}\n\t\treturn diff;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ThisExpression#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#MethodInvocation#ThisExpression#SimpleName#FieldAccess#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#ThisExpression#MethodInvocation#SimpleName#SimpleName#SimpleName#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)MethodInvocation)Assignment)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the interval with elements from this not in other; other must not be totally enclosed (properly contained) within this, which would result in two disjoint intervals instead of the single one returned by this method.", "call_func_name": ["org.antlr.misc.Interval.startsBeforeNonDisjoint", "java.lang.Math.max", "org.antlr.misc.Interval.create", "org.antlr.misc.Interval.startsAfterNonDisjoint"], "call_func_parameter": [["org.antlr.misc.Interval"], ["int", "int"], ["int", "int"], ["org.antlr.misc.Interval"]], "passed_comments": [{"org.antlr.misc.Interval.startsBeforeNonDisjoint": "Does this start at or before other? Nondisjoint"}, {"org.antlr.misc.Interval.create": "Interval objects are used readonly so share all with the same single value a==b up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new Interval object with a..a in it.  On Java.g, 218623 IntervalSets have a..a (set with 1 element)."}, {"org.antlr.misc.Interval.startsAfterNonDisjoint": "Does this start after other? NonDisjoint"}]}, {"index": "453", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.IntervalSet", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public IntervalSet() {\n        intervals = new ArrayList<Interval>(2); // most sets are 1 or 2 elements\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#NumberLiteral#ClassInstanceCreation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(NumberLiteral)NumberLiteral)ClassInstanceCreation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a set with no elements", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "454", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.of", "methodParameterType": "int#", "methodParameterName": "a#", "methodBody": "public static IntervalSet of(int a) {\n\t\tIntervalSet s = new IntervalSet();\n        s.add(a);\n        return s;\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a set with a single element, el.", "call_func_name": ["org.antlr.misc.IntervalSet.<init>", "org.antlr.misc.IntervalSet.add"], "call_func_parameter": [[""], ["int"]], "passed_comments": [{"org.antlr.misc.IntervalSet.add": "Add a single element to the set.  An isolated element is stored as a range el..el."}]}, {"index": "455", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.of", "methodParameterType": "int#int#", "methodParameterName": "a#b#", "methodBody": "public static IntervalSet of(int a, int b) {\n        IntervalSet s = new IntervalSet();\n        s.add(a,b);\n        return s;\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a set with all ints within range [a..b] (inclusive)", "call_func_name": ["org.antlr.misc.IntervalSet.<init>", "org.antlr.misc.IntervalSet.add"], "call_func_parameter": [[""], ["int", "int"]], "passed_comments": [{"org.antlr.misc.IntervalSet.add": "Add interval; i.e., add all integers from a to b to set. If b&lt;a, do nothing. Keep list in sorted order (by left range value). If overlap, combine ranges.  For example, If this is {1..5, 10..20}, adding 6..7 yields {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}."}]}, {"index": "456", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.add", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "@Override\n    public void add(int el) {\n        add(el,el);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Add a single element to the set.  An isolated element is stored as a range el..el.", "call_func_name": ["org.antlr.misc.IntervalSet.add"], "call_func_parameter": [["int", "int"]], "passed_comments": [{"org.antlr.misc.IntervalSet.add": "Add interval; i.e., add all integers from a to b to set. If b&lt;a, do nothing. Keep list in sorted order (by left range value). If overlap, combine ranges.  For example, If this is {1..5, 10..20}, adding 6..7 yields {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}."}]}, {"index": "457", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.add", "methodParameterType": "int#int#", "methodParameterName": "a#b#", "methodBody": "public void add(int a, int b) {\n        add(Interval.create(a,b));\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Add interval; i.e., add all integers from a to b to set. If b&lt;a, do nothing. Keep list in sorted order (by left range value). If overlap, combine ranges.  For example, If this is {1..5, 10..20}, adding 6..7 yields {1..5, 6..7, 10..20}.  Adding 4..8 yields {1..8, 10..20}.", "call_func_name": ["org.antlr.misc.Interval.create", "org.antlr.misc.IntervalSet.add"], "call_func_parameter": [["int", "int"], ["org.antlr.misc.Interval"]], "passed_comments": [{"org.antlr.misc.Interval.create": "Interval objects are used readonly so share all with the same single value a==b up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTERVAL_POOL_MAX_VALUE or a new Interval object with a..a in it.  On Java.g, 218623 IntervalSets have a..a (set with 1 element)."}]}, {"index": "458", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.complement", "methodParameterType": "IntSet#", "methodParameterName": "vocabulary#", "methodBody": "@Override\n    public IntervalSet complement(IntSet vocabulary) {\n        if ( vocabulary==null ) {\n            return null; // nothing in common with null set\n        }\n\t\tif ( !(vocabulary instanceof IntervalSet ) ) {\n\t\t\tthrow new IllegalArgumentException(\"can't complement with non IntervalSet (\"+\n\t\t\t\t\t\t\t\t\t\t\t   vocabulary.getClass().getName()+\")\");\n\t\t}\n\t\tIntervalSet vocabularyIS = ((IntervalSet)vocabulary);\n\t\tint maxElement = vocabularyIS.getMaxElement();\n\n\t\tIntervalSet compl = new IntervalSet();\n\t\tint n = intervals.size();\n\t\tif ( n ==0 ) {\n\t\t\treturn compl;\n\t\t}\n\t\tInterval first = intervals.get(0);\n\t\t// add a range from 0 to first.a constrained to vocab\n\t\tif ( first.a > 0 ) {\n\t\t\tIntervalSet s = IntervalSet.of(0, first.a-1);\n\t\t\tIntervalSet a = s.and(vocabularyIS);\n\t\t\tcompl.addAll(a);\n\t\t}\n\t\tfor (int i=1; i<n; i++) { // from 2nd interval .. nth\n\t\t\tInterval previous = intervals.get(i-1);\n\t\t\tInterval current = intervals.get(i);\n\t\t\tIntervalSet s = IntervalSet.of(previous.b+1, current.a-1);\n\t\t\tIntervalSet a = s.and(vocabularyIS);\n\t\t\tcompl.addAll(a);\n\t\t}\n\t\tInterval last = intervals.get(n -1);\n\t\t// add a range from last.b to maxElement constrained to vocab\n\t\tif ( last.b < maxElement ) {\n\t\t\tIntervalSet s = IntervalSet.of(last.b+1, maxElement);\n\t\t\tIntervalSet a = s.and(vocabularyIS);\n\t\t\tcompl.addAll(a);\n\t\t}\n\t\treturn compl;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given the set of possible values (rather than, say UNICODE or MAXINT), return a new set containing all elements in vocabulary, but not in this.  The computation is (vocabulary - this). 'this' is assumed to be either a subset or equal to vocabulary.", "call_func_name": ["org.antlr.misc.IntervalSet.complement"], "call_func_parameter": [["org.antlr.misc.IntSet"]], "passed_comments": [{"org.antlr.misc.IntervalSet.complement": "Given the set of possible values (rather than, say UNICODE or MAXINT), return a new set containing all elements in vocabulary, but not in this.  The computation is (vocabulary - this). 'this' is assumed to be either a subset or equal to vocabulary."}]}, {"index": "459", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.subtract", "methodParameterType": "IntSet#", "methodParameterName": "other#", "methodBody": "@Override\n\tpublic IntervalSet subtract(IntSet other) {\n\t\t// assume the whole unicode range here for the complement\n\t\t// because it doesn't matter.  Anything beyond the max of this' set\n\t\t// will be ignored since we are doing this & ~other.  The intersection\n\t\t// will be empty.  The only problem would be when this' set max value\n\t\t// goes beyond MAX_CHAR_VALUE, but hopefully the constant MAX_CHAR_VALUE\n\t\t// will prevent this.\n\t\treturn this.and(((IntervalSet)other).complement(COMPLETE_SET));\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Compute this-other via this&amp;~other. Return a new set containing all elements in this but not in other. other is assumed to be a subset of this; anything that is in other but not in this will be ignored.", "call_func_name": ["org.antlr.misc.IntervalSet.subtract"], "call_func_parameter": [["org.antlr.misc.IntSet"]], "passed_comments": [{"org.antlr.misc.IntervalSet.subtract": "Compute this-other via this&amp;~other. Return a new set containing all elements in this but not in other. other is assumed to be a subset of this; anything that is in other but not in this will be ignored."}]}, {"index": "460", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.or", "methodParameterType": "IntSet#", "methodParameterName": "a#", "methodBody": "@Override\n\tpublic IntSet or(IntSet a) {\n\t\tIntervalSet o = new IntervalSet();\n\t\to.addAll(this);\n\t\to.addAll(a);\n\t\t//throw new NoSuchMethodError();\n\t\treturn o;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "TODO: implement this!", "call_func_name": ["org.antlr.misc.IntervalSet.<init>", "org.antlr.misc.IntervalSet.addAll"], "call_func_parameter": [[""], ["org.antlr.misc.IntSet"]], "passed_comments": "/"}, {"index": "461", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.and", "methodParameterType": "IntSet#", "methodParameterName": "other#", "methodBody": "@Override\n\tpublic IntervalSet and(IntSet other) {\n\t\tif ( other==null ) { //|| !(other instanceof IntervalSet) ) {\n\t\t\treturn null; // nothing in common with null set\n\t\t}\n\n\t\tList<Interval> myIntervals = this.intervals;\n\t\tList<Interval> theirIntervals = ((IntervalSet)other).intervals;\n\t\tIntervalSet intersection = null;\n\t\tint mySize = myIntervals.size();\n\t\tint theirSize = theirIntervals.size();\n\t\tint i = 0;\n\t\tint j = 0;\n\t\t// iterate down both interval lists looking for nondisjoint intervals\n\t\twhile ( i<mySize && j<theirSize ) {\n\t\t\tInterval mine = myIntervals.get(i);\n\t\t\tInterval theirs = theirIntervals.get(j);\n\t\t\t//System.out.println(\"mine=\"+mine+\" and theirs=\"+theirs);\n\t\t\tif ( mine.startsBeforeDisjoint(theirs) ) {\n\t\t\t\t// move this iterator looking for interval that might overlap\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( theirs.startsBeforeDisjoint(mine) ) {\n\t\t\t\t// move other iterator looking for interval that might overlap\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if ( mine.properlyContains(theirs) ) {\n\t\t\t\t// overlap, add intersection, get next theirs\n\t\t\t\tif ( intersection==null ) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\t\t\t\tintersection.add(mine.intersection(theirs));\n\t\t\t\tj++;\n\t\t\t}\n\t\t\telse if ( theirs.properlyContains(mine) ) {\n\t\t\t\t// overlap, add intersection, get next mine\n\t\t\t\tif ( intersection==null ) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\t\t\t\tintersection.add(mine.intersection(theirs));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse if ( !mine.disjoint(theirs) ) {\n\t\t\t\t// overlap, add intersection\n\t\t\t\tif ( intersection==null ) {\n\t\t\t\t\tintersection = new IntervalSet();\n\t\t\t\t}\n\t\t\t\tintersection.add(mine.intersection(theirs));\n\t\t\t\t// Move the iterator of lower range [a..b], but not\n\t\t\t\t// the upper range as it may contain elements that will collide\n\t\t\t\t// with the next iterator. So, if mine=[0..115] and\n\t\t\t\t// theirs=[115..200], then intersection is 115 and move mine\n\t\t\t\t// but not theirs as theirs may collide with the next range\n\t\t\t\t// in thisIter.\n\t\t\t\t// move both iterators to next ranges\n\t\t\t\tif ( mine.startsAfterNonDisjoint(theirs) ) {\n\t\t\t\t\tj++;\n\t\t\t\t}\n\t\t\t\telse if ( theirs.startsAfterNonDisjoint(mine) ) {\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif ( intersection==null ) {\n\t\t\treturn new IntervalSet();\n\t\t}\n\t\treturn intersection;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#ThisExpression#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#IfStatement#Block#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#Block#WhileStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#ClassInstanceCreation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)IfStatement)Block)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement)Block)WhileStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a new set with the intersection of this set with other.  Because the intervals are sorted, we can use an iterator for each list and just walk them together.  This is roughly O(min(n,m)) for interval list lengths n and m.", "call_func_name": ["org.antlr.misc.IntervalSet.and"], "call_func_parameter": [["org.antlr.misc.IntSet"]], "passed_comments": [{"org.antlr.misc.IntervalSet.and": "Return a new set with the intersection of this set with other.  Because the intervals are sorted, we can use an iterator for each list and just walk them together.  This is roughly O(min(n,m)) for interval list lengths n and m."}]}, {"index": "462", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.member", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "@Override\n    public boolean member(int el) {\n\t\tint n = intervals.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tInterval I = intervals.get(i);\n\t\t\tint a = I.a;\n\t\t\tint b = I.b;\n\t\t\tif ( el<a ) {\n\t\t\t\tbreak; // list is sorted and el is before this interval; not here\n\t\t\t}\n\t\t\tif ( el>=a && el<=b ) {\n\t\t\t\treturn true; // found in this interval\n\t\t\t}\n\t\t}\n\t\treturn false;\n/*\n\t\tfor (ListIterator iter = intervals.listIterator(); iter.hasNext();) {\n            Interval I = (Interval) iter.next();\n            if ( el<I.a ) {\n                break; // list is sorted and el is before this interval; not here\n            }\n            if ( el>=I.a && el<=I.b ) {\n                return true; // found in this interval\n            }\n        }\n        return false;\n        */\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#BreakStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#ForStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(BreakStatement)BreakStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is el in any range of this set?", "call_func_name": ["java.util.List.size", "java.util.List.get"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "463", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.isNil", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public boolean isNil() {\n        return intervals==null || intervals.isEmpty();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return true if this set has no members", "call_func_name": ["java.util.List.isEmpty"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "464", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.getSingleElement", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int getSingleElement() {\n        if ( intervals!=null && intervals.size()==1 ) {\n            Interval I = intervals.get(0);\n            if ( I.a == I.b ) {\n                return I.a;\n            }\n        }\n        return Label.INVALID;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If this set is a single integer, return it otherwise Label.INVALID", "call_func_name": ["java.util.List.size", "java.util.List.get"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "465", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.getMinElement", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getMinElement() {\n\t\tif ( isNil() ) {\n\t\t\treturn Label.INVALID;\n\t\t}\n\t\tint n = intervals.size();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tInterval I = intervals.get(i);\n\t\t\tint a = I.a;\n\t\t\tint b = I.b;\n\t\t\tfor (int v=a; v<=b; v++) {\n\t\t\t\tif ( v>=0 ) return v;\n\t\t\t}\n\t\t}\n\t\treturn Label.INVALID;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#ReturnStatement#IfStatement#Block#ForStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ReturnStatement(SimpleName)SimpleName)ReturnStatement)IfStatement)Block)ForStatement)Block)ForStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return minimum element &gt;= 0", "call_func_name": ["org.antlr.misc.IntervalSet.isNil", "java.util.List.size", "java.util.List.get"], "call_func_parameter": [[""], [""], ["int"]], "passed_comments": [{"org.antlr.misc.IntervalSet.isNil": "return true if this set has no members"}]}, {"index": "466", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.getIntervals", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Interval> getIntervals() {\n        return intervals;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of Interval objects.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "467", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.equals", "methodParameterType": "Object#", "methodParameterName": "obj#", "methodBody": "@Override\n    public boolean equals(Object obj) {\n        if ( !(obj instanceof IntervalSet) ) {\n            return false;\n        }\n        IntervalSet other = (IntervalSet)obj;\n        return this.intervals.equals(other.intervals);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Are two IntervalSets equal?  Because all intervals are sorted and disjoint, equals is a simple linear walk over both lists to make sure they are the same.  Interval.equals() is used by the List.equals() method to check the ranges.", "call_func_name": ["java.util.List.equals"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "468", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntervalSet.java", "methodName": "org.antlr.misc.IntervalSet.get", "methodParameterType": "int#", "methodParameterName": "i#", "methodBody": "public int get(int i) {\n\t\tint n = intervals.size();\n\t\tint index = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tInterval I = intervals.get(j);\n\t\t\tint a = I.a;\n\t\t\tint b = I.b;\n\t\t\tfor (int v=a; v<=b; v++) {\n\t\t\t\tif ( index==i ) {\n\t\t\t\t\treturn v;\n\t\t\t\t}\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#ForStatement#Block#ForStatement#NumberLiteral#PrefixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)ForStatement)Block)ForStatement(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the ith element of ordered set.  Used only by RandomPhrase so don't bother to implement if you're not doing that for a new ANTLR code gen target.", "call_func_name": ["java.util.List.size", "java.util.List.get"], "call_func_parameter": [[""], ["int"]], "passed_comments": "/"}, {"index": "469", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntSet.java", "methodName": "org.antlr.misc.IntSet.add", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "void add(int el);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Add an element to the set", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "470", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntSet.java", "methodName": "org.antlr.misc.IntSet.addAll", "methodParameterType": "IntSet#", "methodParameterName": "set#", "methodBody": "void addAll(IntSet set);", "AST": "Javadoc#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Add all elements from incoming set to this set.  Can limit to set of its own type.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "471", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntSet.java", "methodName": "org.antlr.misc.IntSet.and", "methodParameterType": "IntSet#", "methodParameterName": "a#", "methodBody": "IntSet and(IntSet a);", "AST": "Javadoc#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "Return the intersection of this set with the argument, creating a new set.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "472", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntSet.java", "methodName": "org.antlr.misc.IntSet.size", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "int size();", "AST": "Javadoc#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Return the size of this set (not the underlying implementation's allocated memory size, for example).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "473", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntSet.java", "methodName": "org.antlr.misc.IntSet.remove", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "void remove(int el);", "AST": "Javadoc#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#MethodDeclaration#", "SBT": "(MethodDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration)MethodDeclaration", "methodDoc": "remove this element from this set", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "474", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.BitSet", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public BitSet() {\n        this(BITS);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(ConstructorInvocation(SimpleName)SimpleName)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Construct a bitset of size one word (64 bits)", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "475", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.BitSet", "methodParameterType": "long[]#", "methodParameterName": "bits_#", "methodBody": "public BitSet(long[] bits_) {\n        bits = bits_;\n    }", "AST": "Javadoc#Modifier#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Construction from a static array of longs", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "476", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.BitSet", "methodParameterType": "int#", "methodParameterName": "nbits#", "methodBody": "public BitSet(int nbits) {\n        bits = new long[((nbits - 1) >> LOG_BITS) + 1];\n    }", "AST": "Javadoc#Modifier#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#ArrayCreation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(InfixExpression(ParenthesizedExpression(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression)ArrayCreation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Construct a bitset given the size", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "477", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.add", "methodParameterType": "int#", "methodParameterName": "el#", "methodBody": "@Override\n    public void add(int el) {\n        //System.out.println(\"add(\"+el+\")\");\n        int n = wordNumber(el);\n        //System.out.println(\"word number is \"+n);\n        //System.out.println(\"bits.length \"+bits.length);\n        if (n >= bits.length) {\n            growToInclude(el);\n        }\n        bits[n] |= bitMask(el);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "or this element into this set (grow as necessary to accommodate)", "call_func_name": ["org.antlr.misc.BitSet.wordNumber", "org.antlr.misc.BitSet.growToInclude", "org.antlr.misc.BitSet.bitMask"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.misc.BitSet.growToInclude": "Grows the set to a larger number of bits."}]}, {"index": "478", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.growToInclude", "methodParameterType": "int#", "methodParameterName": "bit#", "methodBody": "public void growToInclude(int bit) {\n        int newSize = Math.max(bits.length << 1, numWordsToHold(bit));\n        long newbits[] = new long[newSize];\n        System.arraycopy(bits, 0, newbits, 0, bits.length);\n        bits = newbits;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#Dimension#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(Dimension)Dimension(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Grows the set to a larger number of bits.", "call_func_name": ["org.antlr.misc.BitSet.numWordsToHold", "java.lang.Math.max", "java.lang.System.arraycopy"], "call_func_parameter": [["int"], ["int", "int"], ["java.lang.Object", "int", "java.lang.Object", "int", "int"]], "passed_comments": "/"}, {"index": "479", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.getSingleElement", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int getSingleElement() {\n        for (int i = 0; i < (bits.length << LOG_BITS); i++) {\n            if (member(i)) {\n                return i;\n            }\n        }\n        return Label.INVALID;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the first element you find and return it.  Return Label.INVALID otherwise.", "call_func_name": ["org.antlr.misc.BitSet.member"], "call_func_parameter": [["int"]], "passed_comments": "/"}, {"index": "480", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.notInPlace", "methodParameterType": "int#", "methodParameterName": "maxBit#", "methodBody": "public void notInPlace(int maxBit) {\n        notInPlace(0, maxBit);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "complement bits in the range 0..maxBit.", "call_func_name": ["org.antlr.misc.BitSet.notInPlace"], "call_func_parameter": [["int", "int"]], "passed_comments": [{"org.antlr.misc.BitSet.notInPlace": "complement bits in the range minBit..maxBit."}]}, {"index": "481", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.notInPlace", "methodParameterType": "int#int#", "methodParameterName": "minBit#maxBit#", "methodBody": "public void notInPlace(int minBit, int maxBit) {\n        // make sure that we have room for maxBit\n        growToInclude(maxBit);\n        for (int i = minBit; i <= maxBit; i++) {\n            int n = wordNumber(i);\n            bits[n] ^= bitMask(i);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "complement bits in the range minBit..maxBit.", "call_func_name": ["org.antlr.misc.BitSet.growToInclude", "org.antlr.misc.BitSet.wordNumber", "org.antlr.misc.BitSet.bitMask"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.misc.BitSet.growToInclude": "Grows the set to a larger number of bits."}]}, {"index": "482", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.or", "methodParameterType": "IntSet#", "methodParameterName": "a#", "methodBody": "@Override\n    public IntSet or(IntSet a) {\n\t\tif ( a==null ) {\n\t\t\treturn this;\n\t\t}\n        BitSet s = (BitSet)this.clone();\n        s.orInPlace((BitSet)a);\n        return s;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ThisExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(ThisExpression)ThisExpression)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return this | a in a new set", "call_func_name": ["org.antlr.misc.BitSet.clone", "org.antlr.misc.BitSet.orInPlace"], "call_func_parameter": [[""], ["org.antlr.misc.BitSet"]], "passed_comments": "/"}, {"index": "483", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.setSize", "methodParameterType": "int#", "methodParameterName": "nwords#", "methodBody": "private void setSize(int nwords) {\n        long newbits[] = new long[nwords];\n        int n = Math.min(nwords, bits.length);\n        System.arraycopy(bits, 0, newbits, 0, n);\n        bits = newbits;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#Dimension#PrimitiveType#Dimension#ArrayType#SimpleName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#NumberLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(Dimension)Dimension(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets the size of a set.", "call_func_name": ["java.lang.Math.min", "java.lang.System.arraycopy"], "call_func_parameter": [["int", "int"], ["java.lang.Object", "int", "java.lang.Object", "int", "int"]], "passed_comments": "/"}, {"index": "484", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.lengthInLongWords", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int lengthInLongWords() {\n        return bits.length;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "return how much space is being used by the bits array not how many actually have member bits on.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "485", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.subset", "methodParameterType": "BitSet#", "methodParameterName": "a#", "methodBody": "public boolean subset(BitSet a) {\n        if (a == null) return false;\n        return this.and(a).equals(this);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#ThisExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is this contained within a?", "call_func_name": ["org.antlr.misc.BitSet.and", "org.antlr.misc.IntSet.equals"], "call_func_parameter": [["org.antlr.misc.IntSet"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "486", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.subtractInPlace", "methodParameterType": "BitSet#", "methodParameterName": "a#", "methodBody": "public void subtractInPlace(BitSet a) {\n        if (a == null) return;\n        // for all words of 'a', turn off corresponding bits of 'this'\n        for (int i = 0; i < bits.length && i < a.bits.length; i++) {\n            bits[i] &= ~a.bits[i];\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#PrefixExpression#Assignment#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement)ReturnStatement)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(PrefixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess)PrefixExpression)Assignment)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Subtract the elements of 'a' from 'this' in-place. Basically, just turn off all bits of 'this' that are in 'a'.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "487", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.toString", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "@Override\n    public String toString(Grammar g) {\n        StringBuilder buf = new StringBuilder();\n        String separator = \",\";\n\t\tboolean havePrintedAnElement = false;\n\t\tbuf.append('{');\n\n        for (int i = 0; i < (bits.length << LOG_BITS); i++) {\n            if (member(i)) {\n                if (i > 0 && havePrintedAnElement ) {\n                    buf.append(separator);\n                }\n                if ( g!=null ) {\n                    buf.append(g.getTokenDisplayName(i));\n                }\n                else {\n                    buf.append(i);\n                }\n\t\t\t\thavePrintedAnElement = true;\n            }\n        }\n\t\tbuf.append('}');\n        return buf.toString();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#NumberLiteral#InfixExpression#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Transform a bit set into a string by formatting each element as an integer separator The string to put in between elements", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.antlr.misc.BitSet.member", "java.lang.StringBuilder.append", "org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["char"], ["int"], ["java.lang.String"], ["int"], ["int"], [""]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "488", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.toString", "methodParameterType": "String#List<String>#", "methodParameterName": "separator#vocabulary#", "methodBody": "public String toString(String separator, List<String> vocabulary) {\n        if (vocabulary == null) {\n            return toString(null);\n        }\n        String str = \"\";\n        for (int i = 0; i < (bits.length << LOG_BITS); i++) {\n            if (member(i)) {\n                if (str.length() > 0) {\n                    str += separator;\n                }\n                if (i >= vocabulary.size()) {\n                    str += \"'\" + (char)i + \"'\";\n                }\n                else if (vocabulary.get(i) == null) {\n                    str += \"'\" + (char)i + \"'\";\n                }\n                else {\n                    str += vocabulary.get(i);\n                }\n            }\n        }\n        return str;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#NullLiteral#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#StringLiteral#PrimitiveType#SimpleName#CastExpression#StringLiteral#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#StringLiteral#PrimitiveType#SimpleName#CastExpression#StringLiteral#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a string representation where instead of integer elements, the ith element of vocabulary is displayed instead.  Vocabulary is a Vector of Strings. separator The string to put in between elements", "call_func_name": ["org.antlr.misc.BitSet.toString", "org.antlr.misc.BitSet.member", "java.lang.String.length", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.util.List.size", "java.lang.StringBuilder.append", "java.util.List.get"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["int"], [""], [""], ["java.lang.String"], [""], [""], ["char"], ["int"]], "passed_comments": [{"org.antlr.misc.BitSet.toString": "Transform a bit set into a string by formatting each element as an integer separator The string to put in between elements"}]}, {"index": "489", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.toStringOfHalfWords", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toStringOfHalfWords() {\n        StringBuilder s = new StringBuilder();\n        for (int i = 0; i < bits.length; i++) {\n            if (i != 0) s.append(\", \");\n            long tmp = bits[i];\n            tmp &= 0xFFFFFFFFL;\n            s.append(tmp);\n\t\t\ts.append(\"UL\");\n            s.append(\", \");\n            tmp = bits[i] >>> 32;\n            tmp &= 0xFFFFFFFFL;\n\t\t\ts.append(tmp);\n\t\t\ts.append(\"UL\");\n        }\n\t\treturn s.toString();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#ArrayAccess#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Dump a comma-separated list of the words making up the bit set. Split each 64 bit number into two more manageable 32 bit numbers. This generates a comma-separated list of C++-like unsigned long constants.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["long"], [""]], "passed_comments": "/"}, {"index": "490", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/BitSet.java", "methodName": "org.antlr.misc.BitSet.toStringOfWords", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toStringOfWords() {\n\t\tStringBuilder s = new StringBuilder();\n        for (int i = 0; i < bits.length; i++) {\n            if (i != 0) s.append(\", \");\n            s.append(bits[i]);\n\t\t\ts.append(\"L\");\n        }\n        return s.toString();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Dump a comma-separated list of the words making up the bit set. This generates a comma-separated list of Java-like long int constants.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["long"], [""]], "passed_comments": "/"}, {"index": "491", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Graph.java", "methodName": "org.antlr.misc.Graph.sort", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<T> sort() {\n        Set<Node<T>> visited = new OrderedHashSet<Node<T>>();\n        ArrayList<T> sorted = new ArrayList<T>();\n        while ( visited.size() < nodes.size() ) {\n            // pick any unvisited node, n\n            Node<T> n = null;\n            for (Node<T> tNode : nodes.values()) {\n                n = tNode;\n                if ( !visited.contains(n) ) break;\n            }\n            DFS(n, visited, sorted);\n        }\n        return sorted;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#BreakStatement#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(BreakStatement)BreakStatement)IfStatement)Block)EnhancedForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "DFS-based topological sort.  A valid sort is the reverse of the post-order DFA traversal.  Amazingly simple but true. For sorting, I'm not following convention here since ANTLR needs the opposite.  Here's what I assume for sorting: If there exists an edge u &rarr; v then u depends on v and v must happen before u. So if this gives nonreversed postorder traversal, I get the order I want.", "call_func_name": ["org.antlr.misc.OrderedHashSet.<init>", "java.util.ArrayList.<init>", "java.util.Set.size", "java.util.Map.size", "java.util.Map.values", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.util.Set.contains"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], [""], [""], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "492", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Barrier.java", "methodName": "org.antlr.misc.Barrier.action", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void action() {\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block)Block)MethodDeclaration", "methodDoc": "What to do when everyone reaches barrier", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "493", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/IntArrayList.java", "methodName": "org.antlr.misc.IntArrayList.set", "methodParameterType": "int#int#", "methodParameterName": "i#newValue#", "methodBody": "public int set(int i, int newValue) {\n\t\tif ( i>=n ) {\n\t\t\tsetSize(i); // unlike definition of set in ArrayList, set size\n\t\t}\n\t\tint v = elements[i];\n\t\telements[i] = newValue;\n\t\treturn v;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Set the ith element.  Like ArrayList, this does NOT affect size.", "call_func_name": ["org.antlr.misc.IntArrayList.setSize"], "call_func_parameter": [["int"]], "passed_comments": "/"}, {"index": "494", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/OrderedHashSet.java", "methodName": "org.antlr.misc.OrderedHashSet.set", "methodParameterType": "int#T#", "methodParameterName": "i#value#", "methodBody": "public T set(int i, T value) {\n        T oldElement = elements.get(i);\n        elements.set(i,value); // update list\n        super.remove(oldElement); // now update the set: remove/add\n        super.add(value);\n        return oldElement;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Replace an existing value with a new value; updates the element list and the hash table, but not the key as that has not changed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "495", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/OrderedHashSet.java", "methodName": "org.antlr.misc.OrderedHashSet.add", "methodParameterType": "T#", "methodParameterName": "value#", "methodBody": "@Override\n    public boolean add(T value) {\n        boolean result = super.add(value);\n\t\tif ( result ) {  // only track if new element not in set\n\t\t\telements.add(value);\n\t\t}\n\t\treturn result;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Add a value to list; keep in hashtable for consistency also; Key is object itself.  Good for say asking if a certain string is in a list of strings.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "496", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/OrderedHashSet.java", "methodName": "org.antlr.misc.OrderedHashSet.elements", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<T> elements() {\n        return elements;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the List holding list of table elements.  Note that you are NOT getting a copy so don't write to the list.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "497", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Utils.java", "methodName": "org.antlr.misc.Utils.integer", "methodParameterType": "int#", "methodParameterName": "x#", "methodBody": "public static Integer integer(int x) {\n\t\tif ( x<0 || x>INTEGER_POOL_MAX_VALUE ) {\n\t\t\treturn x;\n\t\t}\n\t\tif ( ints[x]==null ) {\n\t\t\tints[x] = x;\n\t\t}\n\t\treturn ints[x];\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#ArrayAccess#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#ArrayAccess#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it.", "call_func_name": ["java.lang.Integer.valueOf"], "call_func_parameter": [["int"]], "passed_comments": "/"}, {"index": "498", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/misc/Utils.java", "methodName": "org.antlr.misc.Utils.replace", "methodParameterType": "String#String#String#", "methodParameterName": "src#replacee#replacer#", "methodBody": "public static String replace(String src, String replacee, String replacer) {\n\t\tStringBuilder result = new StringBuilder(src.length() + 50);\n\t\tint startIndex = 0;\n\t\tint endIndex = src.indexOf(replacee);\n\t\twhile(endIndex != -1) {\n\t\t\tresult.append(src.substring(startIndex,endIndex));\n\t\t\tif ( replacer!=null ) {\n\t\t\t\tresult.append(replacer);\n\t\t\t}\n\t\t\tstartIndex = endIndex + replacee.length();\n\t\t\tendIndex = src.indexOf(replacee,startIndex);\n\t\t}\n\t\tresult.append(src.substring(startIndex,src.length()));\n\t\treturn result.toString();\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a source string, src, a string to replace, replacee, and a string to replace with, replacer, return a new string w/ the replacing done. You can use replacer==null to remove replacee from the string. This should be faster than Java's String.replaceAll as that one uses regex (I only want to play with strings anyway).", "call_func_name": ["java.lang.String.length", "java.lang.StringBuilder.<init>", "java.lang.String.indexOf", "java.lang.String.substring", "java.lang.StringBuilder.append", "java.lang.String.indexOf", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["int"], ["java.lang.String"], ["int", "int"], ["java.lang.String"], ["java.lang.String", "int"], [""]], "passed_comments": "/"}, {"index": "499", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.main", "methodParameterType": "String[]#", "methodParameterName": "args#", "methodBody": "public static void main(String[] args) {\n        Tool antlr = new Tool(args);\n\n        if (!exitNow) {\n            antlr.process();\n\t\t\tif ( return_dont_exit ) return;\n            if (ErrorManager.getNumErrors() > 0) {\n                System.exit(1);\n            }\n            System.exit(0);\n        }\n    }", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(SimpleName)SimpleName(ReturnStatement)ReturnStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "A list of dependency generators that are accumulated aaaas (and if) the tool is required to sort the provided grammars into build dependency order. protected Map&lt;String, BuildDependencyGenerator&gt; buildDependencyGenerators;", "call_func_name": ["org.antlr.Tool.<init>", "org.antlr.Tool.process", "org.antlr.tool.ErrorManager.getNumErrors", "java.lang.System.exit"], "call_func_parameter": [["java.lang.String[]"], [""], [""], ["int"]], "passed_comments": "/"}, {"index": "500", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.loadResources", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "private void loadResources() {\n        InputStream in;\n        in = this.getClass().getResourceAsStream(\"antlr.properties\");\n\n        // If we found the resource, then load it, otherwise revert to the\n        // defaults.\n        //\n        if (in != null) {\n            try {\n                // Load the resources into the map\n                //\n                antlrSettings.load(in);\n\n                // Set any variables that we need to populate from the resources\n                //\n//                VERSION = antlrSettings.getProperty(\"antlr.version\");\n            } catch (Exception e) {\n                // Do nothing, just leave the defaults in place\n            }\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ThisExpression#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#Block#CatchClause#TryStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block)Block)CatchClause)TryStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Load the properties file org/antlr/antlr.properties and populate any variables that must be initialized from it, such as the version of ANTLR.", "call_func_name": ["java.lang.Object.getClass", "java.lang.Class.getResourceAsStream", "java.util.Properties.load"], "call_func_parameter": [[""], ["java.lang.String"], ["java.io.InputStream"]], "passed_comments": "/"}, {"index": "501", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.buildRequired", "methodParameterType": "String#", "methodParameterName": "grammarFileName#", "methodBody": "public boolean buildRequired(String grammarFileName)\n        throws IOException\n    {\n        BuildDependencyGenerator bd =\n            new BuildDependencyGenerator(this, grammarFileName);\n\n        List<File> outputFiles = bd.getGeneratedFileList();\n        List<File> inputFiles = bd.getDependenciesFileList();\n        // Note that input directory must be set to use buildRequired\n        File grammarFile;\n        if (haveInputDir) {\n            grammarFile = new File(inputDirectory, grammarFileName);\n        }\n        else {\n            grammarFile = new File(grammarFileName);\n        }\n        long grammarLastModified = grammarFile.lastModified();\n        for (File outputFile : outputFiles) {\n            if (!outputFile.exists() || grammarLastModified > outputFile.lastModified()) {\n                // One of the output files does not exist or is out of date, so we must build it\n\t\t\t\tif (isVerbose()) {\n\t\t\t\t\tif (!outputFile.exists()) {\n\t\t\t\t\t\tSystem.out.println(\"Output file \" + outputFile + \" does not exist: must build \" + grammarFile);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tSystem.out.println(\"Output file \" + outputFile + \" is not up-to-date: must build \" + grammarFile);\n\t\t\t\t\t}\n\t\t\t\t}\n\n                return true;\n            }\n            // Check all of the imported grammars and see if any of these are younger\n            // than any of the output files.\n            if (inputFiles != null) {\n                for (File inputFile : inputFiles) {\n\n                    if (inputFile.lastModified() > outputFile.lastModified()) {\n                        // One of the imported grammar files has been updated so we must build\n\t\t\t\t\t\tif (isVerbose()) {\n\t\t\t\t\t\t\tSystem.out.println(\"Input file \" + inputFile + \" is newer than output: must rebuild \" + grammarFile);\n\t\t\t\t\t\t}\n\n                        return true;\n                    }\n                }\n            }\n        }\n        if (isVerbose()) {\n            System.out.println(\"Grammar \" + grammarFile + \" is up to date - build skipped\");\n        }\n        return false;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#EnhancedForStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)EnhancedForStatement)Block)IfStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Checks to see if the list of outputFiles all exist, and have last-modified timestamps which are later than the last-modified timestamp of all the grammar files involved in build the output (imports must be checked). If these conditions hold, the method returns false, otherwise, it returns true.", "call_func_name": ["org.antlr.tool.BuildDependencyGenerator.<init>", "org.antlr.tool.BuildDependencyGenerator.getGeneratedFileList", "org.antlr.tool.BuildDependencyGenerator.getDependenciesFileList", "java.io.File.<init>", "java.io.File.<init>", "java.io.File.lastModified", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.io.File.exists", "org.antlr.Tool.isVerbose", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println"], "call_func_parameter": [["org.antlr.Tool", "java.lang.String"], [""], [""], ["java.lang.String", "java.lang.String"], ["java.lang.String"], [""], [""], [""], [""], [""], [""], [""], ["java.lang.String"], ["java.lang.Object"], [""], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.BuildDependencyGenerator.getGeneratedFileList": "From T.g return a list of File objects that name files ANTLR will emit from T.g."}, {"org.antlr.tool.BuildDependencyGenerator.getDependenciesFileList": "Return a list of File objects that name files ANTLR will read to process T.g; This can be .tokens files if the grammar uses the tokenVocab option as well as any imported grammar files."}, {"org.antlr.Tool.isVerbose": "Indicates whether ANTLR will be verbose when analyzing grammar files, such as displaying the names of the files it is generating and similar information."}]}, {"index": "502", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getRootGrammar", "methodParameterType": "String#", "methodParameterName": "grammarFileName#", "methodBody": "public Grammar getRootGrammar(String grammarFileName)\n        throws IOException\n    {\n        //ST.setLintMode(true);\n        // grammars mentioned on command line are either roots or single grammars.\n        // create the necessary composite in case it's got delegates; even\n        // single grammar needs it to get token types.\n        CompositeGrammar composite = new CompositeGrammar();\n        Grammar grammar = new Grammar(this, grammarFileName, composite);\n        composite.setDelegationRoot(grammar);\n        FileReader fr;\n        File f;\n\n        if (haveInputDir) {\n            f = new File(inputDirectory, grammarFileName);\n        }\n        else {\n            f = new File(grammarFileName);\n        }\n\n        // Store the location of this grammar as if we import files, we can then\n        // search for imports in the same location as the original grammar as well as in\n        // the lib directory.\n        //\n        parentGrammarDirectory = f.getParent();\n\n        if (grammarFileName.lastIndexOf(File.separatorChar) == -1) {\n            grammarOutputDirectory = \".\";\n        }\n        else {\n            grammarOutputDirectory = grammarFileName.substring(0, grammarFileName.lastIndexOf(File.separatorChar));\n        }\n        fr = new FileReader(f);\n        BufferedReader br = new BufferedReader(fr);\n        grammar.parseAndBuildAST(br);\n        composite.watchNFAConversion = internalOption_watchNFAConversion;\n        br.close();\n        fr.close();\n        return grammar;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get a grammar mentioned on the command-line and any delegates", "call_func_name": ["org.antlr.tool.CompositeGrammar.<init>", "org.antlr.tool.Grammar.<init>", "org.antlr.tool.CompositeGrammar.setDelegationRoot", "java.io.File.<init>", "java.io.File.<init>", "java.io.File.getParent", "java.lang.String.lastIndexOf", "java.lang.String.substring", "java.io.FileReader.<init>", "java.io.BufferedReader.<init>", "org.antlr.tool.Grammar.parseAndBuildAST", "java.io.BufferedReader.close", "java.io.FileReader.close"], "call_func_parameter": [[""], ["org.antlr.Tool", "java.lang.String", "org.antlr.tool.CompositeGrammar"], ["org.antlr.tool.Grammar"], ["java.lang.String", "java.lang.String"], ["java.lang.String"], [""], ["int"], ["int", "int"], ["java.io.File"], ["java.io.Reader"], ["java.io.Reader"], [""], [""]], "passed_comments": "/"}, {"index": "503", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.generateRecognizer", "methodParameterType": "Grammar#", "methodParameterName": "grammar#", "methodBody": "protected void generateRecognizer(Grammar grammar) {\n        String language = (String) grammar.getOption(\"language\");\n        if (language != null) {\n            CodeGenerator generator = new CodeGenerator(this, grammar, language);\n            grammar.setCodeGenerator(generator);\n            generator.setDebug(isDebug());\n            generator.setProfile(isProfile());\n            generator.setTrace(isTrace());\n\n            // generate NFA early in case of crash later (for debugging)\n            if (isGenerate_NFA_dot()) {\n                generateNFAs(grammar);\n            }\n\n            // GENERATE CODE\n            generator.genRecognizer();\n\n            if (isGenerate_DFA_dot()) {\n                generateDFAs(grammar);\n            }\n\n            List<Grammar> delegates = grammar.getDirectDelegates();\n            for (int i = 0; delegates != null && i < delegates.size(); i++) {\n                Grammar delegate = delegates.get(i);\n                if (delegate != grammar) { // already processing this one\n                    generateRecognizer(delegate);\n                }\n            }\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Create NFA, DFA and generate code for grammar. Create NFA for any delegates first.  Once all NFA are created, it's ok to create DFA, which must check for left-recursion.  That check is done by walking the full NFA, which therefore must be complete. After all NFA, comes DFA conversion for root grammar then code gen for root grammar.  DFA and code gen for delegates comes next.", "call_func_name": ["org.antlr.tool.Grammar.getOption", "org.antlr.codegen.CodeGenerator.<init>", "org.antlr.tool.Grammar.setCodeGenerator", "org.antlr.Tool.isDebug", "org.antlr.codegen.CodeGenerator.setDebug", "org.antlr.Tool.isProfile", "org.antlr.codegen.CodeGenerator.setProfile", "org.antlr.Tool.isTrace", "org.antlr.codegen.CodeGenerator.setTrace", "org.antlr.Tool.isGenerate_NFA_dot", "org.antlr.Tool.generateNFAs", "org.antlr.codegen.CodeGenerator.genRecognizer", "org.antlr.Tool.isGenerate_DFA_dot", "org.antlr.Tool.generateDFAs", "org.antlr.tool.Grammar.getDirectDelegates", "java.util.List.size", "java.util.List.get", "org.antlr.Tool.generateRecognizer"], "call_func_parameter": [["java.lang.String"], ["org.antlr.Tool", "org.antlr.tool.Grammar", "java.lang.String"], ["org.antlr.codegen.CodeGenerator"], [""], ["boolean"], [""], ["boolean"], [""], ["boolean"], [""], ["org.antlr.tool.Grammar"], [""], [""], ["org.antlr.tool.Grammar"], [""], [""], ["int"], ["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.Tool.isDebug": "Indicate if ANTLR has generated, or will generate a debug version of the recognizer. Debug versions of a parser communicate with a debugger such as that contained in ANTLRWorks and at start up will 'hang' waiting for a connection on an IP port (49100 by default)."}, {"org.antlr.Tool.isProfile": "Indicates whether ANTLR has generated or will generate a version of the recognizer that gathers statistics about its execution, which it prints when it terminates."}, {"org.antlr.Tool.isTrace": "Indicate whether ANTLR has generated, or will generate a version of the recognizer that prints trace messages on entry and exit of each rule."}, {"org.antlr.Tool.isGenerate_NFA_dot": "Indicates whether ANTLR has gnerated or will generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>"}, {"org.antlr.codegen.CodeGenerator.genRecognizer": "Given the grammar to which we are attached, walk the AST associated with that grammar to create NFAs.  Then create the DFAs for all decision points in the grammar by converting the NFAs to DFAs. Finally, walk the AST again to generate code. Either 1 or 2 files are written: recognizer: the main parser/lexer/treewalker item header file: language like C/C++ need extern definitions The target, such as JavaTarget, dictates which files get written."}, {"org.antlr.Tool.isGenerate_DFA_dot": "Indicates whether ANTLR has generated or will generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>"}, {"org.antlr.Tool.generateRecognizer": "Create NFA, DFA and generate code for grammar. Create NFA for any delegates first.  Once all NFA are created, it's ok to create DFA, which must check for left-recursion.  That check is done by walking the full NFA, which therefore must be complete. After all NFA, comes DFA conversion for root grammar then code gen for root grammar.  DFA and code gen for delegates comes next."}]}, {"index": "504", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setMaxSwitchCaseLabels", "methodParameterType": "int#", "methodParameterName": "maxSwitchCaseLabels#", "methodBody": "public void setMaxSwitchCaseLabels(int maxSwitchCaseLabels) {\n        CodeGenerator.MAX_SWITCH_CASE_LABELS = maxSwitchCaseLabels;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the threshold of case labels beyond which ANTLR will not instruct the target template to generate switch() { case xxx: ...", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "505", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setMinSwitchAlts", "methodParameterType": "int#", "methodParameterName": "minSwitchAlts#", "methodBody": "public void setMinSwitchAlts(int minSwitchAlts) {\n        CodeGenerator.MIN_SWITCH_ALTS = minSwitchAlts;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the threshold of the number alts, below which ANTLR will not instruct the target template to use a switch statement.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "506", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setOutputDirectory", "methodParameterType": "String#", "methodParameterName": "outputDirectory#", "methodBody": "public void setOutputDirectory(String outputDirectory) {\n        haveOutputDir = true;\n        this.outputDirectory = outputDirectory;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the location (base directory) where output files should be produced by the ANTLR tool.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "507", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setForceRelativeOutput", "methodParameterType": "boolean#", "methodParameterName": "forceRelativeOutput#", "methodBody": "public void setForceRelativeOutput(boolean forceRelativeOutput) {\n        this.forceRelativeOutput = forceRelativeOutput;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Used by build tools to force the output files to always be relative to the base output directory, even though the tool had to set the output directory to an absolute path as it cannot rely on the workign directory like command line invocation can.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "508", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setInputDirectory", "methodParameterType": "String#", "methodParameterName": "inputDirectory#", "methodBody": "public void setInputDirectory(String inputDirectory) {\n        this.inputDirectory = inputDirectory;\n        haveInputDir = true;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the base location of input files. Normally (when the tool is invoked from the command line), the inputDirectory is not set, but for build tools such as Maven, we need to be able to locate the input files relative to the base, as the working directory could be anywhere and changing workig directories is not a valid concept for JVMs because of threading and so on. Setting the directory just means that the getFileDirectory() method will try to open files relative to this input directory.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "509", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getOutputFile", "methodParameterType": "Grammar#String#", "methodParameterName": "g#fileName#", "methodBody": "public Writer getOutputFile(Grammar g, String fileName) throws IOException {\n        if (getOutputDirectory() == null) {\n            return new StringWriter();\n        }\n        // output directory is a function of where the grammar file lives\n        // for subdir/T.g, you get subdir here.  Well, depends on -o etc...\n        // But, if this is a .tokens file, then we force the output to\n        // be the base output directory (or current directory if there is not a -o)\n        //\n        File outputDir;\n        if (fileName.endsWith(CodeGenerator.VOCAB_FILE_EXTENSION)) {\n            if (haveOutputDir) {\n                outputDir = new File(getOutputDirectory());\n            }\n            else {\n                outputDir = new File(\".\");\n            }\n        }\n        else {\n            outputDir = getOutputDirectory(g.getFileName());\n        }\n        File outputFile = new File(outputDir, fileName);\n\n        if (!outputDir.exists()) {\n            outputDir.mkdirs();\n        }\n        FileWriter fw = new FileWriter(outputFile);\n        return new BufferedWriter(fw);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleType#ClassInstanceCreation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(Block(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "This method is used by all code generators to create new output files. If the outputDir set by -o is not present it will be created. The final filename is sensitive to the output directory and the directory where the grammar file was found.  If -o is /tmp and the original grammar file was foo/t.g then output files go in /tmp/foo. The output dir -o spec takes precedence if it's absolute. E.g., if the grammar file dir is absolute the output dir is given precendence. \"-o /tmp /usr/lib/t.g\" results in \"/tmp/T.java\" as output (assuming t.g holds T.java). If no -o is specified, then just write to the directory where the grammar file was found. If outputDirectory==null then write a String.", "call_func_name": ["org.antlr.Tool.getOutputDirectory", "java.io.StringWriter.<init>", "java.lang.String.endsWith", "java.io.File.<init>", "org.antlr.tool.Grammar.getFileName", "org.antlr.Tool.getOutputDirectory", "java.io.File.<init>", "java.io.File.exists", "java.io.File.mkdirs", "java.io.FileWriter.<init>", "java.io.BufferedWriter.<init>"], "call_func_parameter": [[""], [""], ["java.lang.String"], ["java.lang.String"], [""], ["java.lang.String"], ["java.io.File", "java.lang.String"], [""], [""], ["java.io.File"], ["java.io.Writer"]], "passed_comments": [{"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}, {"org.antlr.Tool.getOutputDirectory": "Return the Path to the base output directory, where ANTLR will generate all the output files for the current language target as well as any ancillary files such as .tokens vocab files."}, {"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}]}, {"index": "510", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getOutputDirectory", "methodParameterType": "String#", "methodParameterName": "fileNameWithPath#", "methodBody": "public File getOutputDirectory(String fileNameWithPath) {\n\n        File outputDir;\n        String fileDirectory;\n\n        // Some files are given to us without a PATH but should should\n        // still be written to the output directory in the relative path of\n        // the output directory. The file directory is either the set of sub directories\n        // or just or the relative path recorded for the parent grammar. This means\n        // that when we write the tokens files, or the .java files for imported grammars\n        // taht we will write them in the correct place.\n        //\n        if (fileNameWithPath.lastIndexOf(File.separatorChar) == -1) {\n\n            // No path is included in the file name, so make the file\n            // directory the same as the parent grammar (which might sitll be just \"\"\n            // but when it is not, we will write the file in the correct place.\n            //\n            fileDirectory = grammarOutputDirectory;\n\n        }\n        else {\n            fileDirectory = fileNameWithPath.substring(0, fileNameWithPath.lastIndexOf(File.separatorChar));\n        }\n        if (haveOutputDir) {\n            // -o /tmp /var/lib/t.g => /tmp/T.java\n            // -o subdir/output /usr/lib/t.g => subdir/output/T.java\n            // -o . /usr/lib/t.g => ./T.java\n            if ((fileDirectory != null && !forceRelativeOutput) &&\n                (new File(fileDirectory).isAbsolute() ||\n                 fileDirectory.startsWith(\"~\")) || // isAbsolute doesn't count this :(\n                isForceAllFilesToOutputDir()) {\n                // somebody set the dir, it takes precendence; write new file there\n                outputDir = new File(getOutputDirectory());\n            }\n            else {\n                // -o /tmp subdir/t.g => /tmp/subdir/t.g\n                if (fileDirectory != null) {\n                    outputDir = new File(getOutputDirectory(), fileDirectory);\n                }\n                else {\n                    outputDir = new File(getOutputDirectory());\n                }\n            }\n        }\n        else {\n            // they didn't specify a -o dir so just write to location\n            // where grammar is, absolute or relative, this will only happen\n            // with command line invocation as build tools will always\n            // supply an output directory.\n            //\n            outputDir = new File(fileDirectory);\n        }\n        return outputDir;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#PrefixExpression#InfixExpression#ParenthesizedExpression#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#SimpleName#MethodInvocation#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(IfStatement(InfixExpression(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression)InfixExpression)ParenthesizedExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression)ParenthesizedExpression)InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory.", "call_func_name": ["java.lang.String.lastIndexOf", "java.lang.String.substring", "java.io.File.<init>", "java.io.File.isAbsolute", "java.lang.String.startsWith", "org.antlr.Tool.isForceAllFilesToOutputDir", "org.antlr.Tool.getOutputDirectory", "java.io.File.<init>"], "call_func_parameter": [["int"], ["int", "int"], ["java.lang.String"], [""], ["java.lang.String"], [""], [""], ["java.lang.String", "java.lang.String"]], "passed_comments": [{"org.antlr.Tool.isForceAllFilesToOutputDir": "Indicates whether ANTLR will force all files to the output directory, even if the input files have relative paths from the input directory."}, {"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}, {"org.antlr.Tool.getOutputDirectory": "Return the Path to the base output directory, where ANTLR will generate all the output files for the current language target as well as any ancillary files such as .tokens vocab files."}]}, {"index": "511", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getLibraryFile", "methodParameterType": "String#", "methodParameterName": "fileName#", "methodBody": "public String getLibraryFile(String fileName) throws IOException {\n\n        // First, see if we can find the file in the library directory\n        //\n        File f = new File(getLibraryDirectory() + File.separator + fileName);\n\n        if (f.exists()) {\n\n            // Found in the library directory\n            //\n            return f.getAbsolutePath();\n        }\n\n        // Need to assume it is in the same location as the input file. Note that\n        // this is only relevant for external build tools and when the input grammar\n        // was specified relative to the source directory (working directory if using\n        // the command line.\n        //\n        return parentGrammarDirectory + File.separator + fileName;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Name a file from the -lib dir.  Imported grammars and .tokens files If we do not locate the file in the library directory, then we try the location of the originating grammar.", "call_func_name": ["java.lang.StringBuilder.<init>", "org.antlr.Tool.getLibraryDirectory", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.File.<init>", "java.io.File.exists", "java.io.File.getAbsolutePath"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["java.lang.String"], [""], [""]], "passed_comments": [{"org.antlr.Tool.getLibraryDirectory": "Return the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files."}]}, {"index": "512", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getFileDirectory", "methodParameterType": "String#", "methodParameterName": "fileName#", "methodBody": "public String getFileDirectory(String fileName) {\n\n        File f;\n        if (haveInputDir && !fileName.startsWith(File.separator)) {\n            f = new File(inputDirectory, fileName);\n        }\n        else {\n            f = new File(fileName);\n        }\n        // And ask Java what the base directory of this location is\n        //\n        return f.getParent();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the directory containing the grammar file for this grammar. normally this is a relative path from current directory.  People will often do \"java org.antlr.Tool grammars/", "call_func_name": ["java.lang.String.startsWith", "java.io.File.<init>", "java.io.File.<init>", "java.io.File.getParent"], "call_func_parameter": [["java.lang.String"], ["java.lang.String", "java.lang.String"], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "513", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getImportedVocabFile", "methodParameterType": "String#", "methodParameterName": "vocabName#", "methodBody": "public File getImportedVocabFile(String vocabName) {\n\n        File f = new File(getLibraryDirectory(),\n                          File.separator +\n                          vocabName +\n                          CodeGenerator.VOCAB_FILE_EXTENSION);\n        if (f.exists()) {\n            return f;\n        }\n\n        // We did not find the vocab file in the lib directory, so we need\n        // to look for it in the output directory which is where .tokens\n        // files are generated (in the base, not relative to the input\n        // location.)\n        //\n        if (haveOutputDir) {\n            f = new File(getOutputDirectory(), vocabName + CodeGenerator.VOCAB_FILE_EXTENSION);\n        }\n        else {\n            f = new File(vocabName + CodeGenerator.VOCAB_FILE_EXTENSION);\n        }\n        return f;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName)MethodInvocation(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a File descriptor for vocab file.  Look in library or in -o output path.  antlr -o foo T.g U.g where U needs T.tokens won't work unless we look in foo too. If we do not find the file in the lib directory then must assume that the .tokens file is going to be generated as part of this build and we have defined .tokens files so that they ALWAYS are generated in the base output directory, which means the current directory for the command line tool if there was no output directory specified.", "call_func_name": ["org.antlr.Tool.getLibraryDirectory", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.File.<init>", "java.io.File.exists", "org.antlr.Tool.getOutputDirectory", "java.io.File.<init>"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["java.lang.String", "java.lang.String"], [""], [""], ["java.lang.String"]], "passed_comments": [{"org.antlr.Tool.getLibraryDirectory": "Return the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files."}, {"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}, {"org.antlr.Tool.getOutputDirectory": "Return the Path to the base output directory, where ANTLR will generate all the output files for the current language target as well as any ancillary files such as .tokens vocab files."}]}, {"index": "514", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.panic", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void panic() {\n        throw new Error(\"ANTLR panic\");\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)MethodDeclaration", "methodDoc": "If the tool needs to panic/exit, how do we do that?", "call_func_name": ["java.lang.Error.<init>"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "515", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getCurrentTimeStamp", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public static String getCurrentTimeStamp() {\n        GregorianCalendar calendar = new java.util.GregorianCalendar();\n        int y = calendar.get(Calendar.YEAR);\n        int m = calendar.get(Calendar.MONTH) + 1; // zero-based for months\n        int d = calendar.get(Calendar.DAY_OF_MONTH);\n        int h = calendar.get(Calendar.HOUR_OF_DAY);\n        int min = calendar.get(Calendar.MINUTE);\n        int sec = calendar.get(Calendar.SECOND);\n        String sy = String.valueOf(y);\n        String sm = m < 10 ? \"0\" + m : String.valueOf(m);\n        String sd = d < 10 ? \"0\" + d : String.valueOf(d);\n        String sh = h < 10 ? \"0\" + h : String.valueOf(h);\n        String smin = min < 10 ? \"0\" + min : String.valueOf(min);\n        String ssec = sec < 10 ? \"0\" + sec : String.valueOf(sec);\n        return new StringBuffer().append(sy).append(\"-\").append(sm).append(\"-\").append(sd).append(\" \").append(sh).append(\":\").append(smin).append(\":\").append(ssec).toString();\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#ClassInstanceCreation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a time stamp string accurate to sec: yyyy-mm-dd hh:mm:ss", "call_func_name": ["java.util.GregorianCalendar.<init>", "java.util.GregorianCalendar.get", "java.lang.String.valueOf", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.StringBuffer.toString"], "call_func_parameter": [[""], ["int"], ["int"], [""], ["java.lang.String"], ["int"], [""], [""], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "516", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getGrammarFileNames", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<String> getGrammarFileNames() {\n        return grammarFileNames;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Provide the List of all grammar file names that the ANTLR tool will process or has processed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "517", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isGenerate_NFA_dot", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isGenerate_NFA_dot() {\n        return generate_NFA_dot;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has gnerated or will generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "518", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isGenerate_DFA_dot", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isGenerate_DFA_dot() {\n        return generate_DFA_dot;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has generated or will generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "519", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getOutputDirectory", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getOutputDirectory() {\n        return outputDirectory;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the Path to the base output directory, where ANTLR will generate all the output files for the current language target as well as any ancillary files such as .tokens vocab files.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "520", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getLibraryDirectory", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getLibraryDirectory() {\n        return libDirectory;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "521", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isDebug", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isDebug() {\n        return debug;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicate if ANTLR has generated, or will generate a debug version of the recognizer. Debug versions of a parser communicate with a debugger such as that contained in ANTLRWorks and at start up will 'hang' waiting for a connection on an IP port (49100 by default).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "522", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isTrace", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isTrace() {\n        return trace;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR has generated, or will generate a version of the recognizer that prints trace messages on entry and exit of each rule.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "523", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isProfile", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isProfile() {\n        return profile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has generated or will generate a version of the recognizer that gathers statistics about its execution, which it prints when it terminates.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "524", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isReport", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isReport() {\n        return report;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has generated or will generate a report of various elements of the grammar analysis, once it it has finished analyzing a grammar file.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "525", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isPrintGrammar", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isPrintGrammar() {\n        return printGrammar;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has printed, or will print, a version of the input grammar file(s) that is stripped of any action code embedded within.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "526", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isDepend", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isDepend() {\n        return depend;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR has supplied, or will supply, a list of all the things that the input grammar depends upon and all the things that will be generated when that grammar is successfully analyzed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "527", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isForceAllFilesToOutputDir", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isForceAllFilesToOutputDir() {\n        return forceAllFilesToOutputDir;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR will force all files to the output directory, even if the input files have relative paths from the input directory.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "528", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.isVerbose", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean isVerbose() {\n        return verbose;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR will be verbose when analyzing grammar files, such as displaying the names of the files it is generating and similar information.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "529", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getConversionTimeout", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getConversionTimeout() {\n        return DFA.MAX_TIME_PER_DFA_CREATION;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Provide the current setting of the conversion timeout on DFA creation.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "530", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getMessageFormat", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getMessageFormat() {\n        return ErrorManager.getMessageFormat().toString();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Returns the current setting of the message format descriptor", "call_func_name": ["org.antlr.tool.ErrorManager.getMessageFormat", "org.stringtemplate.v4.ST.toString"], "call_func_parameter": [[""], [""]], "passed_comments": "/"}, {"index": "531", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getNumErrors", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getNumErrors() {\n        return ErrorManager.getNumErrors();\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Returns the number of errors that the analysis/processing threw up.", "call_func_name": ["org.antlr.tool.ErrorManager.getNumErrors"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "532", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.getMake", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean getMake() {\n        return make;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether the tool will analyze the dependencies of the provided grammar file list and ensure that grammars with dependencies are built after any of the other gramamrs in the list that they are dependent on. Setting this option also has the side effect that any grammars that are includes for other grammars in the list are excluded from individual analysis, which allows the caller to invoke the tool via org.antlr.tool -make", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "533", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setMessageFormat", "methodParameterType": "String#", "methodParameterName": "format#", "methodBody": "public void setMessageFormat(String format) {\n        ErrorManager.setFormat(format);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the message format to one of ANTLR, gnu, vs2005", "call_func_name": ["org.antlr.tool.ErrorManager.setFormat"], "call_func_parameter": [["java.lang.String"]], "passed_comments": [{"org.antlr.tool.ErrorManager.setFormat": "The format gets reset either from the Tool if the user supplied a command line option to that effect Otherwise we just use the default \"antlr\"."}]}, {"index": "534", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setGrammarFileNames", "methodParameterType": "List<String>#", "methodParameterName": "grammarFileNames#", "methodBody": "public void setGrammarFileNames(List<String> grammarFileNames) {\n        this.grammarFileNames = grammarFileNames;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Provide the List of all grammar file names that the ANTLR tool should process.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "535", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setGenerate_NFA_dot", "methodParameterType": "boolean#", "methodParameterName": "generate_NFA_dot#", "methodBody": "public void setGenerate_NFA_dot(boolean generate_NFA_dot) {\n        this.generate_NFA_dot = generate_NFA_dot;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "536", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setGenerate_DFA_dot", "methodParameterType": "boolean#", "methodParameterName": "generate_DFA_dot#", "methodBody": "public void setGenerate_DFA_dot(boolean generate_DFA_dot) {\n        this.generate_DFA_dot = generate_DFA_dot;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR should generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "537", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setLibDirectory", "methodParameterType": "String#", "methodParameterName": "libDirectory#", "methodBody": "public void setLibDirectory(String libDirectory) {\n        this.libDirectory = libDirectory;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "538", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setDebug", "methodParameterType": "boolean#", "methodParameterName": "debug#", "methodBody": "public void setDebug(boolean debug) {\n        this.debug = debug;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should generate a debug version of the recognizer. Debug versions of a parser communicate with a debugger such as that contained in ANTLRWorks and at start up will 'hang' waiting for a connection on an IP port (49100 by default).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "539", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setTrace", "methodParameterType": "boolean#", "methodParameterName": "trace#", "methodBody": "public void setTrace(boolean trace) {\n        this.trace = trace;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should generate a version of the recognizer that prints trace messages on entry and exit of each rule", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "540", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setProfile", "methodParameterType": "boolean#", "methodParameterName": "profile#", "methodBody": "public void setProfile(boolean profile) {\n        this.profile = profile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should generate a version of the recognizer that gathers statistics about its execution, which it prints when it terminates.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "541", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setReport", "methodParameterType": "boolean#", "methodParameterName": "report#", "methodBody": "public void setReport(boolean report) {\n        this.report = report;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should generate a report of various elements of the grammar analysis, once it it has finished analyzing a grammar file.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "542", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setPrintGrammar", "methodParameterType": "boolean#", "methodParameterName": "printGrammar#", "methodBody": "public void setPrintGrammar(boolean printGrammar) {\n        this.printGrammar = printGrammar;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should print a version of the input grammar file(s) that is stripped of any action code embedded within.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "543", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setDepend", "methodParameterType": "boolean#", "methodParameterName": "depend#", "methodBody": "public void setDepend(boolean depend) {\n        this.depend = depend;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should supply a list of all the things that the input grammar depends upon and all the things that will be generated when that gramamr is successfully analyzed.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "544", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setForceAllFilesToOutputDir", "methodParameterType": "boolean#", "methodParameterName": "forceAllFilesToOutputDir#", "methodBody": "public void setForceAllFilesToOutputDir(boolean forceAllFilesToOutputDir) {\n        this.forceAllFilesToOutputDir = forceAllFilesToOutputDir;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicates whether ANTLR will force all files to the output directory, even if the input files have relative paths from the input directory.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "545", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setVerbose", "methodParameterType": "boolean#", "methodParameterName": "verbose#", "methodBody": "public void setVerbose(boolean verbose) {\n        this.verbose = verbose;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether ANTLR should be verbose when analyzing grammar files, such as displaying the names of the files it is generating and similar information.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "546", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/Tool.java", "methodName": "org.antlr.Tool.setMake", "methodParameterType": "boolean#", "methodParameterName": "make#", "methodBody": "public void setMake(boolean make) {\n        this.make = make;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Indicate whether the tool should analyze the dependencies of the provided grammar file list and ensure that the grammars with dependencies are built after any of the other gramamrs in the list that they are dependent on. Setting this option also has the side effect that any grammars that are includes for other grammars in the list are excluded from individual analysis, which allows the caller to invoke the tool via org.antlr.tool -make", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "547", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.getBlockOptions", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Map<String, Object> getBlockOptions() {\n        return blockOptions;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "/", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "548", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.setBlockOptions", "methodParameterType": "Map<String,Object>#", "methodParameterName": "blockOptions#", "methodBody": "public void setBlockOptions(Map<String, Object> blockOptions) {\n        this.blockOptions = blockOptions;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "@param blockOptions", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "549", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.setBlockOption", "methodParameterType": "Grammar#String#Object#", "methodParameterName": "grammar#key#value#", "methodBody": "public String setBlockOption(Grammar grammar, String key, Object value) {\n\t\tif ( blockOptions == null ) {\n\t\t\tblockOptions = new HashMap<String, Object>();\n\t\t}\n\t\treturn setOption(blockOptions, Grammar.legalBlockOptions, grammar, key, value);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Save the option key/value pair and process it; return the key or null if invalid option.", "call_func_name": ["java.util.HashMap.<init>", "org.antlr.tool.GrammarAST.setOption"], "call_func_parameter": [[""], ["java.util.Map", "java.util.Set", "org.antlr.tool.Grammar", "java.lang.String", "java.lang.Object"]], "passed_comments": "/"}, {"index": "550", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.equals", "methodParameterType": "Object#", "methodParameterName": "ast#", "methodBody": "@Override\n\tpublic boolean equals(Object ast) {\n\t\tif ( this == ast ) {\n\t\t\treturn true;\n\t\t}\n\t\tif ( !(ast instanceof GrammarAST) ) {\n\t\t\treturn this.getType() == ((Tree)ast).getType();\n\t\t}\n\t\tGrammarAST t = (GrammarAST)ast;\n\t\treturn token.getLine() == t.getLine() &&\n\t\t\t   token.getCharPositionInLine() == t.getCharPositionInLine();\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#ThisExpression#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(ThisExpression)ThisExpression(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(Block(ReturnStatement(InfixExpression(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)InfixExpression)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Make nodes unique based upon Token so we can add them to a Set; if not a GrammarAST, check type.", "call_func_name": ["org.antlr.tool.GrammarAST.getType", "org.antlr.runtime.tree.Tree.getType", "org.antlr.runtime.Token.getLine", "org.antlr.tool.GrammarAST.getLine", "org.antlr.runtime.Token.getCharPositionInLine", "org.antlr.tool.GrammarAST.getCharPositionInLine"], "call_func_parameter": [[""], [""], [""], [""], [""], [""]], "passed_comments": [{"org.antlr.runtime.tree.Tree.getType": "Return a token type; needed for tree parsing"}, {"org.antlr.runtime.Token.getLine": "The line number on which this token was matched; line=1..n"}, {"org.antlr.runtime.Token.getCharPositionInLine": "The index of the first character relative to the beginning of the line 0..n-1"}]}, {"index": "551", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.hashCode", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public int hashCode(){\n        if (token == null)\n            return 0;\n\n        return token.hashCode();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#NumberLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Make nodes unique based upon Token so we can add them to a Set; if not a GrammarAST, check type.", "call_func_name": ["java.lang.Object.hashCode"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "552", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.hasSameTreeStructure", "methodParameterType": "Tree#", "methodParameterName": "other#", "methodBody": "public boolean hasSameTreeStructure(Tree other) {\n\t\t// check roots first.\n\t\tif (this.getType() != other.getType()) return false;\n\t\t// if roots match, do full list match test on children.\n\t\tIterator<Tree> thisDescendants = descendants(this, true).iterator();\n\t\tIterator<Tree> otherDescendants = descendants(other, true).iterator();\n\t\twhile (thisDescendants.hasNext()) {\n\t\t\tif (!otherDescendants.hasNext())\n\t\t\t\treturn false;\n\t\t\tif (thisDescendants.next().getType() != otherDescendants.next().getType())\n\t\t\t\treturn false;\n\t\t}\n\t\treturn !otherDescendants.hasNext();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#ThisExpression#BooleanLiteral#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#PrefixExpression#BooleanLiteral#ReturnStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#InfixExpression#BooleanLiteral#ReturnStatement#IfStatement#Block#WhileStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(ThisExpression)ThisExpression(BooleanLiteral)BooleanLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)IfStatement)Block)WhileStatement(ReturnStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "See if tree has exact token types and structure; no text", "call_func_name": ["org.antlr.tool.GrammarAST.getType", "org.antlr.runtime.tree.Tree.getType", "org.antlr.tool.GrammarAST.descendants", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next"], "call_func_parameter": [[""], [""], ["org.antlr.runtime.tree.Tree", "boolean"], [""], [""], [""]], "passed_comments": [{"org.antlr.runtime.tree.Tree.getType": "Return a token type; needed for tree parsing"}]}, {"index": "553", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.dupTreeNoActions", "methodParameterType": "GrammarAST#GrammarAST#", "methodParameterName": "t#parent#", "methodBody": "public static GrammarAST dupTreeNoActions(GrammarAST t, GrammarAST parent) {\n\t\tif ( t==null ) {\n\t\t\treturn null;\n\t\t}\n\t\tGrammarAST result = (GrammarAST)t.dupNode();\n\t\tfor (GrammarAST subchild : getChildrenForDupTree(t)) {\n\t\t\tresult.addChild(dupTreeNoActions(subchild, result));\n\t\t}\n\t\treturn result;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Duplicate a tree, assuming this is a root node of a tree-- duplicate that node and what's below; ignore siblings of root node.", "call_func_name": ["org.antlr.tool.GrammarAST.dupNode", "org.antlr.tool.GrammarAST.getChildrenForDupTree", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.GrammarAST.dupTreeNoActions", "org.antlr.tool.GrammarAST.addChild"], "call_func_parameter": [[""], ["org.antlr.tool.GrammarAST"], [""], [""], [""], ["org.antlr.tool.GrammarAST", "org.antlr.tool.GrammarAST"], ["org.antlr.runtime.tree.Tree"]], "passed_comments": [{"org.antlr.tool.GrammarAST.dupTreeNoActions": "Duplicate a tree, assuming this is a root node of a tree-- duplicate that node and what's below; ignore siblings of root node."}]}, {"index": "554", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarAST.java", "methodName": "org.antlr.tool.GrammarAST.setTokenBoundaries", "methodParameterType": "Token#Token#", "methodParameterName": "startToken#stopToken#", "methodBody": "public void setTokenBoundaries(Token startToken, Token stopToken) {\n\t\tif ( startToken!=null ) startIndex = startToken.getTokenIndex();\n\t\tif ( stopToken!=null ) stopIndex = stopToken.getTokenIndex();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "Track start/stop token for subtree root created for a rule. Only works with Tree nodes.  For rules that match nothing, seems like this will yield start=i and stop=i-1 in a nil node. Might be useful info so I'll not force to be i..i.", "call_func_name": ["org.antlr.runtime.Token.getTokenIndex"], "call_func_parameter": [[""]], "passed_comments": [{"org.antlr.runtime.Token.getTokenIndex": "An index from 0..n-1 of the token object in the input stream. This must be valid in order to use the ANTLRWorks debugger."}]}, {"index": "555", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/AttributeScope.java", "methodName": "org.antlr.tool.AttributeScope.addAttributes", "methodParameterType": "String#int#", "methodParameterName": "definitions#separator#", "methodBody": "public void addAttributes(String definitions, int separator) {\n\t\tList<String> attrs = new ArrayList<String>();\n\t\tCodeGenerator.getListOfArgumentsFromAction(definitions,0,-1,separator,attrs);\n\t\tfor (String a : attrs) {\n\t\t\tAttribute attr = new Attribute(a);\n\t\t\tif ( !isReturnScope && attr.initValue!=null ) {\n\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_ARG_INIT_VALUES_ILLEGAL,\n\t\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t\t  derivedFromToken,\n\t\t\t\t\t\t\t\t\t\t  attr.name);\n\t\t\t\tattr.initValue=null; // wipe it out\n\t\t\t}\n\t\t\tattributes.put(attr.name, attr);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#NumberLiteral#PrefixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "From a chunk of text holding the definitions of the attributes, pull them apart and create an Attribute for each one.  Add to the list of attributes for this scope.  Pass in the character that terminates a definition such as ',' or ';'.  For example, scope symbols { int n; List names; } would pass in definitions equal to the text in between {...} and separator=';'.  It results in two Attribute objects.", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Attribute.<init>", "org.antlr.tool.ErrorManager.grammarError", "java.util.LinkedHashMap.put"], "call_func_parameter": [[""], ["java.lang.String", "int", "int", "int", "java.util.List"], [""], [""], [""], ["java.lang.String"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction": "Given an arg action like [x, ("}]}, {"index": "556", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/AttributeScope.java", "methodName": "org.antlr.tool.AttributeScope.defineNamedAction", "methodParameterType": "GrammarAST#GrammarAST#", "methodParameterName": "nameAST#actionAST#", "methodBody": "public final void defineNamedAction(GrammarAST nameAST, GrammarAST actionAST)\n\t{\n\t\tString actionName = nameAST.getText();\n\t\tGrammarAST a = actions.get(actionName);\n\t\tif (a != null) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_ACTION_REDEFINITION,\n\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t  nameAST.getToken(),\n\t\t\t\t\t\t\t\t\t  nameAST.getText());\n\t\t} else {\n\t\t\tactions.put(actionName, actionAST);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Given @scope::name {action} define it for this attribute scope. Later, the code generator will ask for the actions table.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.util.LinkedHashMap.get", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.ErrorManager.grammarError", "java.util.LinkedHashMap.put"], "call_func_parameter": [[""], ["java.lang.Object"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "557", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/AttributeScope.java", "methodName": "org.antlr.tool.AttributeScope.getAttributes", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Attribute> getAttributes() {\n\t\tList<Attribute> a = new ArrayList<Attribute>();\n\t\ta.addAll(attributes.values());\n\t\treturn a;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Used by templates to get all attributes", "call_func_name": ["java.util.ArrayList.<init>", "java.util.LinkedHashMap.values", "java.util.List.addAll"], "call_func_parameter": [[""], [""], ["java.util.Collection"]], "passed_comments": "/"}, {"index": "558", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/AttributeScope.java", "methodName": "org.antlr.tool.AttributeScope.intersection", "methodParameterType": "AttributeScope#", "methodParameterName": "other#", "methodBody": "public Set<String> intersection(AttributeScope other) {\n\t\tif ( other==null || other.size()==0 || size()==0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tSet<String> inter = new HashSet<String>();\n\t\tSet<String> thisKeys = attributes.keySet();\n\t\tfor (String key : thisKeys) {\n\t\t\tif ( other.attributes.get(key)!=null ) {\n\t\t\t\tinter.add(key);\n\t\t\t}\n\t\t}\n\t\tif ( inter.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn inter;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the set of keys that collide from this and other.", "call_func_name": ["org.antlr.tool.AttributeScope.size", "java.util.HashSet.<init>", "java.util.LinkedHashMap.keySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.util.LinkedHashMap.get", "java.util.Set.add", "java.util.Set.isEmpty"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["java.lang.Object"], ["java.lang.Object"], [""]], "passed_comments": "/"}, {"index": "559", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/RuleLabelScope.java", "methodName": "org.antlr.tool.RuleLabelScope.getAttribute", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "@Override\n\tpublic Attribute getAttribute(String name) {\n\t\tAttributeScope rulePropertiesScope =\n\t\t\tRuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];\n\t\tif ( rulePropertiesScope.getAttribute(name)!=null ) {\n\t\t\treturn rulePropertiesScope.getAttribute(name);\n\t\t}\n\n\t\tif ( referencedRule.returnScope!=null ) {\n\t\t\treturn referencedRule.returnScope.getAttribute(name);\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If you label a rule reference, you can access that rule's return values as well as any predefined attributes.", "call_func_name": ["org.antlr.tool.AttributeScope.getAttribute"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "560", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/FASerializer.java", "methodName": "org.antlr.tool.FASerializer.FASerializer", "methodParameterType": "Grammar#", "methodParameterName": "grammar#", "methodBody": "public FASerializer(Grammar grammar) {\n        this.grammar = grammar;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "This aspect is associated with a grammar; used to get token names", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "561", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/FASerializer.java", "methodName": "org.antlr.tool.FASerializer.serialize", "methodParameterType": "State#boolean#", "methodParameterName": "s#renumber#", "methodBody": "public String serialize(State s, boolean renumber) {\n        markedStates = new HashSet<State>();\n        stateCounter = 0;\n\t\tif ( renumber ) {\n\t\t\tstateNumberTranslator = new HashMap<State, Integer>();\n        \twalkFANormalizingStateNumbers(s);\n\t\t}\n\t\tList<String> lines = new ArrayList<String>();\n        if ( s.getNumberOfTransitions()>0 ) {\n\t\t\twalkSerializingFA(lines, s);\n\t\t}\n\t\telse {\n\t\t\t// special case: s0 is an accept\n\t\t\tString s0 = getStateString(0, s);\n\t\t\tlines.add(s0+\"\\n\");\n\t\t}\n        StringBuilder buf = new StringBuilder(0);\n        // sort lines to normalize; makes states come out ordered\n        // and then ordered by edge labels then by target state number :)\n        Collections.sort(lines);\n        for (int i = 0; i < lines.size(); i++) {\n            String line = lines.get(i);\n            buf.append(line);\n        }\n        return buf.toString();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#NumberLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#NumberLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(NumberLiteral)NumberLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a string representation of a state machine.  Two identical NFAs or DFAs will have identical serialized representations.  The state numbers inside the state are not used; instead, a new number is computed and because the serialization will walk the two machines using the same specific algorithm, then the state numbers will be identical.  Accept states are distinguished from regular states.", "call_func_name": ["java.util.HashSet.<init>", "java.util.HashMap.<init>", "org.antlr.tool.FASerializer.walkFANormalizingStateNumbers", "java.util.ArrayList.<init>", "org.antlr.analysis.State.getNumberOfTransitions", "org.antlr.tool.FASerializer.walkSerializingFA", "org.antlr.tool.FASerializer.getStateString", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.util.List.add", "java.lang.StringBuilder.<init>", "java.util.Collections.sort", "java.util.List.size", "java.util.List.get"], "call_func_parameter": [[""], [""], ["org.antlr.analysis.State"], [""], [""], ["java.util.List", "org.antlr.analysis.State"], ["int", "org.antlr.analysis.State"], [""], ["java.lang.String"], [""], ["java.lang.Object"], ["int"], ["java.util.List"], [""], ["int"]], "passed_comments": [{"org.antlr.tool.FASerializer.walkFANormalizingStateNumbers": "In stateNumberTranslator, get a map from State to new, normalized state number.  Used by walkSerializingFA to make sure any two identical state machines will serialize the same way."}]}, {"index": "562", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/FASerializer.java", "methodName": "org.antlr.tool.FASerializer.walkFANormalizingStateNumbers", "methodParameterType": "State#", "methodParameterName": "s#", "methodBody": "protected void walkFANormalizingStateNumbers(State s) {\n\t\tif ( s==null ) {\n\t\t\tErrorManager.internalError(\"null state s\");\n\t\t\treturn;\n\t\t}\n        if ( stateNumberTranslator.get(s)!=null ) {\n            return; // already did this state\n        }\n        // assign a new state number for this node if there isn't one\n        stateNumberTranslator.put(s, Utils.integer(stateCounter));\n        stateCounter++;\n\n        // visit nodes pointed to by each transition;\n        for (int i = 0; i < s.getNumberOfTransitions(); i++) {\n            Transition edge = s.transition(i);\n            walkFANormalizingStateNumbers(edge.target); // keep walkin'\n            // if this transition is a rule reference, the node \"following\" this state\n            // will not be found and appear to be not in graph.  Must explicitly jump\n            // to it, but don't \"draw\" an edge.\n            if ( edge instanceof RuleClosureTransition ) {\n\t\t\t\twalkFANormalizingStateNumbers(((RuleClosureTransition) edge).followState);\n            }\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#FieldAccess#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(FieldAccess(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)FieldAccess)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "In stateNumberTranslator, get a map from State to new, normalized state number.  Used by walkSerializingFA to make sure any two identical state machines will serialize the same way.", "call_func_name": ["org.antlr.tool.ErrorManager.internalError", "java.util.Map.get", "org.antlr.misc.Utils.integer", "java.util.Map.put", "org.antlr.analysis.State.getNumberOfTransitions", "org.antlr.analysis.State.transition", "org.antlr.tool.FASerializer.walkFANormalizingStateNumbers"], "call_func_parameter": [["java.lang.Object"], ["java.lang.Object"], ["int"], ["java.lang.Object", "java.lang.Object"], [""], ["int"], ["org.antlr.analysis.State"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.tool.FASerializer.walkFANormalizingStateNumbers": "In stateNumberTranslator, get a map from State to new, normalized state number.  Used by walkSerializingFA to make sure any two identical state machines will serialize the same way."}]}, {"index": "563", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.Grammar", "methodParameterType": "Tool#String#CompositeGrammar#", "methodParameterName": "tool#fileName#composite#", "methodBody": "public Grammar(Tool tool, String fileName, CompositeGrammar composite) {\n\t\tthis.composite = composite;\n\t\tsetTool(tool);\n\t\tsetFileName(fileName);\n\t\t// ensure we have the composite set to something\n\t\tif ( composite.delegateGrammarTreeRoot==null ) {\n\t\t\tcomposite.setDelegationRoot(this);\n\t\t}\n\t\tSTGroup lexerGrammarSTG = new STGroupString(lexerGrammarTemplate);\n\t\tlexerGrammarST = lexerGrammarSTG.getInstanceOf(\"grammar\");\n\t\ttarget = CodeGenerator.loadLanguageTarget((String) getOption(\"language\"));\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#MethodInvocation#CastExpression#MethodInvocation#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)MethodInvocation)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Create a grammar from file name.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "564", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.Grammar", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Grammar() { this((Tool)null); }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#NullLiteral#CastExpression#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(Block(ConstructorInvocation(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(NullLiteral)NullLiteral)CastExpression)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Useful for when you are sure that you are not part of a composite already.  Used in Interp/RandomPhrase and testing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "565", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.Grammar", "methodParameterType": "String#", "methodParameterName": "grammarString#", "methodBody": "public Grammar(String grammarString)\n\t\t\tthrows RecognitionException\n\t{\n\t\tthis(null, grammarString);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#NullLiteral#SimpleName#ConstructorInvocation#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(ConstructorInvocation(NullLiteral)NullLiteral(SimpleName)SimpleName)ConstructorInvocation)Block)MethodDeclaration", "methodDoc": "Used for testing; only useful on noncomposite grammars.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "566", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.Grammar", "methodParameterType": "Tool#String#", "methodParameterName": "tool#grammarString#", "methodBody": "public Grammar(Tool tool, String grammarString)\n\t\tthrows RecognitionException\n\t{\n\t\tthis(tool);\n\t\tsetFileName(\"<string>\");\n\t\tStringReader r = new StringReader(grammarString);\n\t\tparseAndBuildAST(r);\n\t\tcomposite.assignTokenTypes();\n\t\t//composite.translateLeftRecursiveRules();\n\t\taddRulesForSyntacticPredicates();\n\t\tcomposite.defineGrammarSymbols();\n\t\t//composite.createNFAs();\n\t\tcheckNameSpaceAndActions();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#ConstructorInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(ConstructorInvocation(SimpleName)SimpleName)ConstructorInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Used for testing and Interp/RandomPhrase.  Only useful on noncomposite grammars.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "567", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.checkNameSpaceAndActions", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void checkNameSpaceAndActions() {\n\t\texamineAllExecutableActions();\n\t\tcheckAllRulesForUselessLabels();\n\n\t\tnameSpaceChecker.checkConflicts();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "ANALYZE ACTIONS, LOOKING FOR LABEL AND ATTR REFS, sanity check", "call_func_name": ["org.antlr.tool.Grammar.examineAllExecutableActions", "org.antlr.tool.Grammar.checkAllRulesForUselessLabels", "org.antlr.tool.NameSpaceChecker.checkConflicts"], "call_func_parameter": [[""], [""], [""]], "passed_comments": [{"org.antlr.tool.Grammar.examineAllExecutableActions": "Before generating code, we examine all actions that can have $x.y and $y stuff in them because some code generation depends on Rule.referencedPredefinedRuleAttributes.  I need to remove unused rule labels for example."}, {"org.antlr.tool.Grammar.checkAllRulesForUselessLabels": "Remove all labels on rule refs whose target rules have no return value. Do this for all rules in grammar."}]}, {"index": "568", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.validImport", "methodParameterType": "Grammar#", "methodParameterName": "delegate#", "methodBody": "public boolean validImport(Grammar delegate) {\n\t\tList<Integer> validDelegators = validDelegations.get(delegate.type);\n\t\treturn validDelegators!=null && validDelegators.contains(this.type);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#ThisExpression#SimpleName#FieldAccess#MethodInvocation#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)MethodInvocation)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Many imports are illegal such as lexer into a tree grammar", "call_func_name": ["java.lang.Integer.valueOf", "org.antlr.misc.MultiMap.get", "java.util.List.contains"], "call_func_parameter": [["int"], ["java.lang.Object"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "569", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getLexerGrammar", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getLexerGrammar() {\n\t\tif ( lexerGrammarST.getAttribute(\"literals\")==null &&\n\t\t\t lexerGrammarST.getAttribute(\"rules\")==null )\n\t\t{\n\t\t\t// if no rules, return nothing\n\t\t\treturn null;\n\t\t}\n\t\tlexerGrammarST.add(\"name\", name);\n\t\t// if there are any actions set for lexer, pass them in\n\t\tif ( getActions().get(\"lexer\")!=null ) {\n\t\t\tlexerGrammarST.add(\"actionNames\",\n\t\t\t\t\t\t\t\t\t\tgetActions().get(\"lexer\").keySet());\n\t\t\tlexerGrammarST.add(\"actions\",\n\t\t\t\t\t\t\t\t\t\tgetActions().get(\"lexer\").values());\n\t\t}\n\t\t// make sure generated grammar has the same options\n\t\tif ( options!=null ) {\n\t\t\tfor (String optionName : options.keySet()) {\n\t\t\t\tif ( !doNotCopyOptionsToLexer.contains(optionName) ) {\n\t\t\t\t\tObject value = options.get(optionName);\n\t\t\t\t\tlexerGrammarST.addAggr(\"options.{name,value}\", optionName, value);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn lexerGrammarST.render();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If the grammar is a combined grammar, return the text of the implicit lexer grammar.", "call_func_name": ["org.stringtemplate.v4.ST.getAttribute", "org.stringtemplate.v4.ST.add", "org.antlr.tool.Grammar.getActions", "java.util.Map.get", "java.util.Map.keySet", "java.util.Map.values", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.util.Set.contains", "org.stringtemplate.v4.ST.addAggr", "org.stringtemplate.v4.ST.render"], "call_func_parameter": [["java.lang.String"], ["java.lang.String", "java.lang.Object"], [""], ["java.lang.Object"], [""], [""], [""], [""], [""], ["java.lang.Object"], ["java.lang.String", "java.lang.Object[]"], [""]], "passed_comments": "/"}, {"index": "570", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getRecognizerName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getRecognizerName() {\n\t\tString suffix = \"\";\n\t\tList<Grammar> grammarsFromRootToMe = composite.getDelegators(this);\n\t\t//System.out.println(\"grammarsFromRootToMe=\"+grammarsFromRootToMe);\n\t\tString qualifiedName = name;\n\t\tif ( grammarsFromRootToMe!=null ) {\n\t\t\tStringBuilder buf = new StringBuilder();\n\t\t\tfor (Grammar g : grammarsFromRootToMe) {\n\t\t\t\tbuf.append(g.name);\n\t\t\t\tbuf.append('_');\n\t\t\t}\n\t\t\tbuf.append(name);\n\t\t\tqualifiedName = buf.toString();\n\t\t}\n\t\tif ( type==Grammar.COMBINED ||\n\t\t\t (type==Grammar.LEXER && implicitLexer) )\n\t\t{\n\t\t\tsuffix = Grammar.grammarTypeToFileNameSuffix[type];\n\t\t}\n\t\treturn qualifiedName+suffix;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(SimpleName)SimpleName)InfixExpression)ParenthesizedExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the name of the generated recognizer; may or may not be same as grammar name. Recognizer is TParser and TLexer from T if combined, else just use T regardless of grammar type.", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDelegators", "java.lang.StringBuilder.<init>", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [["org.antlr.tool.Grammar"], [""], [""], [""], [""], ["java.lang.String"], ["char"], [""]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegators": "Return list of delegate grammars from root down to g. Order is root, ..., g.parent.  (g not included)."}]}, {"index": "571", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.addArtificialMatchTokensRule", "methodParameterType": "GrammarAST#List<String>#List<String>#boolean#", "methodParameterName": "grammarAST#ruleNames#delegateNames#filterMode#", "methodBody": "public GrammarAST addArtificialMatchTokensRule(GrammarAST grammarAST,\n\t\t\t\t\t\t\t\t\t\t\t\t   List<String> ruleNames,\n\t\t\t\t\t\t\t\t\t\t\t\t   List<String> delegateNames,\n\t\t\t\t\t\t\t\t\t\t\t\t   boolean filterMode) {\n\t\tST matchTokenRuleST;\n\t\tif ( filterMode ) {\n\t\t\tmatchTokenRuleST = new ST(\n\t\t\t\t\tARTIFICIAL_TOKENS_RULENAME+\n\t\t\t\t\t\" options {k=1; backtrack=true;} : <rules; separator=\\\"|\\\">;\");\n\t\t}\n\t\telse {\n\t\t\tmatchTokenRuleST = new ST(\n\t\t\t\t\tARTIFICIAL_TOKENS_RULENAME+\" : <rules; separator=\\\"|\\\">;\");\n\t\t}\n\n\t\t// Now add token rule references\n\t\tfor (int i = 0; i < ruleNames.size(); i++) {\n\t\t\tString rname = ruleNames.get(i);\n\t\t\tmatchTokenRuleST.add(\"rules\", rname);\n\t\t}\n\t\tfor (int i = 0; i < delegateNames.size(); i++) {\n\t\t\tString dname = delegateNames.get(i);\n\t\t\tmatchTokenRuleST.add(\"rules\", dname+\".Tokens\");\n\t\t}\n\t\t//System.out.println(\"tokens rule: \"+matchTokenRuleST.toString());\n\t\tGrammarAST r = parseArtificialRule(matchTokenRuleST.render());\n\t\taddRule(grammarAST, r);\n\t\t//addRule((GrammarAST)parser.getAST());\n\t\t//return (GrammarAST)parser.getAST();\n\t\treturn r;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Parse a rule we add artificially that is a list of the other lexer rules like this: \"Tokens : ID | INT | SEMI ;\"  nextToken() will invoke this to set the current token.  Add char literals before the rule references. If in filter mode, we want every alt to backtrack and we need to do k=1 to force the \"first token def wins\" rule.  Otherwise, the longest-match rule comes into play with LL(", "call_func_name": ["org.stringtemplate.v4.ST.<init>", "java.util.List.size", "java.util.List.get", "org.stringtemplate.v4.ST.add", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.stringtemplate.v4.ST.render", "org.antlr.tool.Grammar.parseArtificialRule", "org.antlr.tool.Grammar.addRule"], "call_func_parameter": [["java.lang.String"], [""], ["int"], ["java.lang.String", "java.lang.Object"], [""], ["java.lang.String"], [""], [""], ["java.lang.String"], ["org.antlr.tool.GrammarAST", "org.antlr.tool.GrammarAST"]], "passed_comments": "/"}, {"index": "572", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getArtificialRulesForSyntacticPredicates", "methodParameterType": "LinkedHashMap<String,GrammarAST>#", "methodParameterName": "nameToSynpredASTMap#", "methodBody": "protected List<? extends GrammarAST> getArtificialRulesForSyntacticPredicates(LinkedHashMap<String,GrammarAST> nameToSynpredASTMap)\n\t{\n\t\tList<GrammarAST> rules = new ArrayList<GrammarAST>();\n\t\tif ( nameToSynpredASTMap==null ) {\n\t\t\treturn rules;\n\t\t}\n\t\tboolean isLexer = grammarTree.getType()==ANTLRParser.LEXER_GRAMMAR;\n\t\tfor (Map.Entry<String, GrammarAST> entry : nameToSynpredASTMap.entrySet()) {\n\t\t\tString synpredName = entry.getKey();\n\t\t\tGrammarAST fragmentAST = entry.getValue();\n\t\t\tGrammarAST ruleAST =\n\t\t\t\tANTLRParser.createSimpleRuleAST(synpredName,\n\t\t\t\t\t\t\t\t\t\t\t\tfragmentAST,\n\t\t\t\t\t\t\t\t\t\t\t\tisLexer);\n\t\t\trules.add(ruleAST);\n\t\t}\n\t\treturn rules;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "for any syntactic predicates, we need to define rules for them; they will get defined automatically like any other rule. :)", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.GrammarAST.getType", "java.util.LinkedHashMap.entrySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.grammar.v3.ANTLRParser.createSimpleRuleAST", "java.util.List.add"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["java.lang.String", "org.antlr.tool.GrammarAST", "boolean"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "573", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.createRuleStartAndStopNFAStates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void createRuleStartAndStopNFAStates() {\n\t\t//System.out.println(\"### createRuleStartAndStopNFAStates \"+getGrammarTypeString()+\" grammar \"+name+\" NFAs\");\n\t\tif ( nfa!=null ) {\n\t\t\treturn;\n\t\t}\n\t\tnfa = new NFA(this);\n\t\tfactory = new NFAFactory(nfa);\n\n\t\tCollection<Rule> rules = getRules();\n\t\tfor (Rule r : rules) {\n\t\t\tString ruleName = r.name;\n\t\t\tNFAState ruleBeginState = factory.newState();\n\t\t\truleBeginState.setDescription(\"rule \"+ruleName+\" start\");\n\t\t\truleBeginState.enclosingRule = r;\n\t\t\tr.startState = ruleBeginState;\n\t\t\tNFAState ruleEndState = factory.newState();\n\t\t\truleEndState.setDescription(\"rule \"+ruleName+\" end\");\n\t\t\truleEndState.setAcceptState(true);\n\t\t\truleEndState.enclosingRule = r;\n\t\t\tr.stopState = ruleEndState;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#ThisExpression#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Define all the rule begin/end NFAStates to solve forward reference issues.  Critical for composite grammars too. This is normally called on all root/delegates manually and then buildNFA() is called afterwards because the NFA construction needs to see rule start/stop states from potentially every grammar. Has to be have these created a priori.  Testing routines will often just call buildNFA(), which forces a call to this method if not done already. Works ONLY for single noncomposite grammars.", "call_func_name": ["org.antlr.analysis.NFA.<init>", "org.antlr.tool.NFAFactory.<init>", "org.antlr.tool.Grammar.getRules", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.NFAFactory.newState", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.analysis.NFAState.setDescription", "org.antlr.analysis.NFAState.setAcceptState"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["org.antlr.analysis.NFA"], [""], [""], [""], [""], [""], [""], ["java.lang.String"], [""], ["java.lang.String"], ["boolean"]], "passed_comments": "/"}, {"index": "574", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.createLookaheadDFAs", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void createLookaheadDFAs() {\n\t\tcreateLookaheadDFAs(true);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "For each decision in this grammar, compute a single DFA using the NFA states associated with the decision.  The DFA construction determines whether or not the alternatives in the decision are separable using a regular lookahead language. Store the lookahead DFAs in the AST created from the user's grammar so the code generator or whoever can easily access it. This is a separate method because you might want to create a Grammar without doing the expensive analysis.", "call_func_name": ["org.antlr.tool.Grammar.createLookaheadDFAs"], "call_func_parameter": [["boolean"]], "passed_comments": "/"}, {"index": "575", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.externallyAbortNFAToDFAConversion", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void externallyAbortNFAToDFAConversion() {\n\t\texternalAnalysisAbort = true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Terminate DFA creation (grammar analysis).", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "576", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getNewTokenType", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getNewTokenType() {\n\t\tcomposite.maxTokenType++;\n\t\treturn composite.maxTokenType;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a new unique integer in the token type space", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "577", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineToken", "methodParameterType": "String#int#", "methodParameterName": "text#tokenType#", "methodBody": "public void defineToken(String text, int tokenType) {\n\t\t//System.out.println(\"defineToken(\"+text+\", \"+tokenType+\")\");\n\t\tif ( composite.tokenIDToTypeMap.get(text)!=null ) {\n\t\t\t// already defined?  Must be predefined one like EOF;\n\t\t\t// do nothing\n\t\t\treturn;\n\t\t}\n\t\t// the index in the typeToTokenList table is actually shifted to\n\t\t// hold faux labels as you cannot have negative indices.\n\t\tif ( text.charAt(0)=='\\'' ) {\n\t\t\tcomposite.stringLiteralToTypeMap.put(text, Utils.integer(tokenType));\n\t\t\t// track in reverse index too\n\t\t\tif ( tokenType>=composite.typeToStringLiteralList.size() ) {\n\t\t\t\tcomposite.typeToStringLiteralList.setSize(tokenType+1);\n\t\t\t}\n\t\t\tcomposite.typeToStringLiteralList.set(tokenType, text);\n\t\t}\n\t\telse { // must be a label like ID\n\t\t\tcomposite.tokenIDToTypeMap.put(text, Utils.integer(tokenType));\n\t\t}\n\t\tint index = Label.NUM_FAUX_LABELS+tokenType-1;\n\t\t//System.out.println(\"defining \"+name+\" token \"+text+\" at type=\"+tokenType+\", index=\"+index);\n\t\tcomposite.maxTokenType = Math.max(composite.maxTokenType, tokenType);\n\t\tif ( index>=composite.typeToTokenList.size() ) {\n\t\t\tcomposite.typeToTokenList.setSize(index+1);\n\t\t}\n\t\tString prevToken = composite.typeToTokenList.get(index);\n\t\tif ( prevToken==null || prevToken.charAt(0)=='\\'' ) {\n\t\t\t// only record if nothing there before or if thing before was a literal\n\t\t\tcomposite.typeToTokenList.set(index, text);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Define a token at a particular token type value.  Blast an old value with a new one.  This is called normal grammar processsing and during import vocab operations to set tokens with specific values.", "call_func_name": ["java.util.Map.get", "java.lang.String.charAt", "org.antlr.misc.Utils.integer", "java.util.Map.put", "java.util.Vector.size", "java.util.Vector.setSize", "java.util.Vector.set", "java.lang.Math.max", "java.util.Vector.get"], "call_func_parameter": [["java.lang.Object"], ["int"], ["int"], ["java.lang.Object", "java.lang.Object"], [""], ["int"], ["int", "java.lang.Object"], ["int", "int"], ["int"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "578", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineRule", "methodParameterType": "Token#String#Map<String,Object>#GrammarAST#GrammarAST#int#", "methodParameterName": "ruleToken#modifier#options#tree#argActionAST#numAlts#", "methodBody": "public void defineRule(Token ruleToken,\n\t\t\t\t\t\t   String modifier,\n\t\t\t\t\t\t   Map<String, Object> options,\n\t\t\t\t\t\t   GrammarAST tree,\n\t\t\t\t\t\t   GrammarAST argActionAST,\n\t\t\t\t\t\t   int numAlts)\n\t{\n\t\tString ruleName = ruleToken.getText();\n\t\tif ( getLocallyDefinedRule(ruleName)!=null ) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_RULE_REDEFINITION,\n\t\t\t\t\t\t\t\t\t  this, ruleToken, ruleName);\n\t\t\treturn;\n\t\t}\n\n\t\tif ( (type==Grammar.PARSER||type==Grammar.TREE_PARSER) &&\n\t\t\t Character.isUpperCase(ruleName.charAt(0)) )\n\t\t{\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_LEXER_RULES_NOT_ALLOWED,\n\t\t\t\t\t\t\t\t\t  this, ruleToken, ruleName);\n\t\t\treturn;\n\t\t}\n\n\t\tRule r = new Rule(this, ruleName, composite.ruleIndex, numAlts);\n\t\t/*\n\t\tSystem.out.println(\"defineRule(\"+ruleName+\",modifier=\"+modifier+\n\t\t\t\t\t\t   \"): index=\"+r.index+\", nalts=\"+numAlts);\n\t\t*/\n\t\tr.modifier = modifier;\n\t\tnameToRuleMap.put(ruleName, r);\n\t\tsetRuleAST(ruleName, tree);\n\t\tr.setOptions(options, ruleToken);\n\t\tr.argActionAST = argActionAST;\n\t\tcomposite.ruleIndexToRuleList.setSize(composite.ruleIndex+1);\n\t\tcomposite.ruleIndexToRuleList.set(composite.ruleIndex, r);\n\t\tcomposite.ruleIndex++;\n\t\tif ( ruleName.startsWith(SYNPRED_RULE_PREFIX) ) {\n\t\t\tr.isSynPred = true;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)ParenthesizedExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Define a new rule.  A new rule index is created by incrementing ruleIndex.", "call_func_name": ["org.antlr.runtime.Token.getText", "org.antlr.tool.Grammar.getLocallyDefinedRule", "org.antlr.tool.ErrorManager.grammarError", "java.lang.String.charAt", "java.lang.Character.isUpperCase", "org.antlr.tool.Rule.<init>", "java.util.LinkedHashMap.put", "org.antlr.tool.Grammar.setRuleAST", "org.antlr.tool.Rule.setOptions", "java.util.Vector.setSize", "java.util.Vector.set", "java.lang.String.startsWith"], "call_func_parameter": [[""], ["java.lang.String"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["int"], ["char"], ["org.antlr.tool.Grammar", "java.lang.String", "int", "int"], ["java.lang.Object", "java.lang.Object"], ["java.lang.String", "org.antlr.tool.GrammarAST"], ["java.util.Map", "org.antlr.runtime.Token"], ["int"], ["int", "java.lang.Object"], ["java.lang.String"]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}]}, {"index": "579", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineSyntacticPredicate", "methodParameterType": "GrammarAST#String#", "methodParameterName": "blockAST#currentRuleName#", "methodBody": "public String defineSyntacticPredicate(GrammarAST blockAST,\n\t\t\t\t\t\t\t\t\t\t   String currentRuleName)\n\t{\n\t\tif ( nameToSynpredASTMap==null ) {\n\t\t\tnameToSynpredASTMap = new LinkedHashMap<String, GrammarAST>();\n\t\t}\n\t\tString predName =\n\t\t\tSYNPRED_RULE_PREFIX+(nameToSynpredASTMap.size() + 1)+\"_\"+name;\n\t\tblockAST.setTreeEnclosingRuleNameDeeply(predName);\n\t\tnameToSynpredASTMap.put(predName, blockAST);\n\t\treturn predName;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ParenthesizedExpression#StringLiteral#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Define a new predicate and get back its name for use in building a semantic predicate reference to the syn pred.", "call_func_name": ["java.util.LinkedHashMap.<init>", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.util.LinkedHashMap.size", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.GrammarAST.setTreeEnclosingRuleNameDeeply", "java.util.LinkedHashMap.put"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["int"], [""], ["java.lang.String"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "580", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineNamedAction", "methodParameterType": "GrammarAST#String#GrammarAST#GrammarAST#", "methodParameterName": "ampersandAST#scope#nameAST#actionAST#", "methodBody": "public void defineNamedAction(GrammarAST ampersandAST,\n\t\t\t\t\t\t\t\t  String scope,\n\t\t\t\t\t\t\t\t  GrammarAST nameAST,\n\t\t\t\t\t\t\t\t  GrammarAST actionAST)\n\t{\n\t\tif ( scope==null ) {\n\t\t\tscope = getDefaultActionScope(type);\n\t\t}\n\t\t//System.out.println(\"Grammar \"+name+\" define @\"+scope+\"::\"+nameAST.getText()+\"{\"+actionAST.getText()+\"}\");\n\t\tString actionName = nameAST.getText();\n\t\tMap<String, Object> scopeActions = getActions().get(scope);\n\t\tif ( scopeActions==null ) {\n\t\t\tscopeActions = new HashMap<String, Object>();\n\t\t\tgetActions().put(scope, scopeActions);\n\t\t}\n\t\tObject a = scopeActions.get(actionName);\n\t\tif ( a!=null ) {\n\t\t\tErrorManager.grammarError(\n\t\t\t\tErrorManager.MSG_ACTION_REDEFINITION,this,\n\t\t\t\tnameAST.getToken(),nameAST.getText());\n\t\t}\n\t\telse {\n\t\t\tscopeActions.put(actionName,actionAST);\n\t\t}\n        // propogate header (regardless of scope (lexer, parser, ...) ?\n        if ( this==composite.getRootGrammar() && actionName.equals(\"header\") ) {\n            List<Grammar> allgrammars = composite.getRootGrammar().getDelegates();\n            for (Grammar delegate : allgrammars) {\n\t\t\t\tif ( target.isValidActionScope(delegate.type, scope) ) {\n\t\t\t\t\t//System.out.println(\"propogate to \"+delegate.name);\n                \tdelegate.defineNamedAction(ampersandAST, scope, nameAST, actionAST);\n\t\t\t\t}\n            }\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ThisExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(ThisExpression)ThisExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Given @scope::name {action} define it for this grammar.  Later, the code generator will ask for the actions table.  For composite grammars, make sure header action propogates down to all delegates.", "call_func_name": ["org.antlr.tool.Grammar.getDefaultActionScope", "org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getActions", "java.util.Map.get", "java.util.HashMap.<init>", "java.util.Map.put", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.ErrorManager.grammarError", "org.antlr.tool.CompositeGrammar.getRootGrammar", "java.lang.String.equals", "org.antlr.tool.Grammar.getDelegates", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.codegen.Target.isValidActionScope", "org.antlr.tool.Grammar.defineNamedAction"], "call_func_parameter": [["int"], [""], [""], ["java.lang.Object"], [""], ["java.lang.Object", "java.lang.Object"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], [""], ["java.lang.Object"], [""], [""], [""], [""], ["int", "java.lang.String"], ["org.antlr.tool.GrammarAST", "java.lang.String", "org.antlr.tool.GrammarAST", "org.antlr.tool.GrammarAST"]], "passed_comments": [{"org.antlr.tool.Grammar.getDefaultActionScope": "Given a grammar type, what should be the default action scope? If I say @members in a COMBINED grammar, for example, the default scope should be \"parser\"."}, {"org.antlr.tool.Grammar.getDelegates": "Get list of all delegates from all grammars directly or indirectly imported into this grammar."}, {"org.antlr.codegen.Target.isValidActionScope": "Is scope in @scope::name {action} valid for this kind of grammar? Targets like C++ may want to allow new scopes like headerfile or some such.  The action names themselves are not policed at the moment so targets can add template actions w/o having to recompile ANTLR."}, {"org.antlr.tool.Grammar.defineNamedAction": "Given @scope::name {action} define it for this grammar.  Later, the code generator will ask for the actions table.  For composite grammars, make sure header action propogates down to all delegates."}]}, {"index": "581", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getDefaultActionScope", "methodParameterType": "int#", "methodParameterName": "grammarType#", "methodBody": "public String getDefaultActionScope(int grammarType) {\n\t\tswitch (grammarType) {\n\t\t\tcase Grammar.LEXER :\n\t\t\t\treturn \"lexer\";\n\t\t\tcase Grammar.PARSER :\n\t\t\tcase Grammar.COMBINED :\n\t\t\t\treturn \"parser\";\n\t\t\tcase Grammar.TREE_PARSER :\n\t\t\t\treturn \"treeparser\";\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SwitchCase#StringLiteral#ReturnStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#StringLiteral#ReturnStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#StringLiteral#ReturnStatement#SwitchStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SwitchStatement(SimpleName)SimpleName(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)SwitchStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a grammar type, what should be the default action scope? If I say @members in a COMBINED grammar, for example, the default scope should be \"parser\".", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "582", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineLexerRuleForAliasedStringLiteral", "methodParameterType": "String#String#int#", "methodParameterName": "tokenID#literal#tokenType#", "methodBody": "public void defineLexerRuleForAliasedStringLiteral(String tokenID,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   String literal,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   int tokenType)\n\t{\n\t\tif ( getGrammarIsRoot() ) { // don't build lexers for delegates\n\t\t\t//System.out.println(\"defineLexerRuleForAliasedStringLiteral: \"+literal+\" \"+tokenType);\n\t\t\tlexerGrammarST.addAggr(\"literals.{ruleName,type,literal}\",\n\t\t\t\t\t\t\t\t\t\ttokenID,\n\t\t\t\t\t\t\t\t\t\tUtils.integer(tokenType),\n\t\t\t\t\t\t\t\t\t\tliteral);\n\t\t}\n\t\t// track this lexer rule's name\n\t\tcomposite.lexerRules.add(tokenID);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If someone does PLUS='+' in the parser, must make sure we get \"PLUS : '+' ;\" in lexer not \"T73 : '+';\"", "call_func_name": ["org.antlr.tool.Grammar.getGrammarIsRoot", "org.antlr.misc.Utils.integer", "org.stringtemplate.v4.ST.addAggr", "java.util.Set.add"], "call_func_parameter": [[""], ["int"], ["java.lang.String", "java.lang.Object[]"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "583", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.generateMethodForRule", "methodParameterType": "String#", "methodParameterName": "ruleName#", "methodBody": "public boolean generateMethodForRule(String ruleName) {\n\t\tif ( ruleName.equals(ARTIFICIAL_TOKENS_RULENAME) ) {\n\t\t\t// always generate Tokens rule to satisfy lexer interface\n\t\t\t// but it may have no alternatives.\n\t\t\treturn true;\n\t\t}\n\t\tif ( overriddenRules.contains(ruleName) ) {\n\t\t\t// don't generate any overridden rules\n\t\t\treturn false;\n\t\t}\n\t\t// generate if non-synpred or synpred used in a DFA\n\t\tRule r = getLocallyDefinedRule(ruleName);\n\t\treturn !r.isSynPred ||\n\t\t\t   (r.isSynPred&&synPredNamesUsedInDFA.contains(ruleName));\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#ParenthesizedExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ParenthesizedExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Should codegen.g gen rule for ruleName? If synpred, only gen if used in a DFA. If regular rule, only gen if not overridden in delegator Always gen Tokens rule though.", "call_func_name": ["java.lang.String.equals", "java.util.Set.contains", "org.antlr.tool.Grammar.getLocallyDefinedRule"], "call_func_parameter": [["java.lang.Object"], ["java.lang.Object"], ["java.lang.String"]], "passed_comments": "/"}, {"index": "584", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getGlobalScope", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "public AttributeScope getGlobalScope(String name) {\n\t\treturn scopes.get(name);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get a global scope", "call_func_name": ["java.util.Map.get"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "585", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.defineLabel", "methodParameterType": "Rule#Token#GrammarAST#int#", "methodParameterName": "r#label#element#type#", "methodBody": "protected void defineLabel(Rule r, Token label, GrammarAST element, int type) {\n\t\tboolean err = nameSpaceChecker.checkForLabelTypeMismatch(r, label, type);\n\t\tif ( err ) {\n\t\t\treturn;\n\t\t}\n\t\tr.defineLabel(label, element, type);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Define a label defined in a rule r; check the validity then ask the Rule object to actually define it.", "call_func_name": ["org.antlr.tool.NameSpaceChecker.checkForLabelTypeMismatch", "org.antlr.tool.Rule.defineLabel"], "call_func_parameter": [["org.antlr.tool.Rule", "org.antlr.runtime.Token", "int"], ["org.antlr.runtime.Token", "org.antlr.tool.GrammarAST", "int"]], "passed_comments": [{"org.antlr.tool.NameSpaceChecker.checkForLabelTypeMismatch": "If type of previous label differs from new label's type, that's an error."}]}, {"index": "586", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getLabels", "methodParameterType": "Set<GrammarAST>#int#", "methodParameterName": "rewriteElements#labelType#", "methodBody": "public Set<String> getLabels(Set<GrammarAST> rewriteElements, int labelType) {\n\t\tSet<String> labels = new HashSet<String>();\n\t\tfor (GrammarAST el : rewriteElements) {\n\t\t\tif ( el.getType()==ANTLRParser.LABEL ) {\n\t\t\t\tString labelName = el.getText();\n\t\t\t\tRule enclosingRule = getLocallyDefinedRule(el.enclosingRuleName);\n\t\t\t\tif ( enclosingRule==null ) continue;\n\t\t\t\tLabelElementPair pair = enclosingRule.getLabel(labelName);\n                /*\n                // if tree grammar and we have a wildcard, only notice it\n                // when looking for rule labels not token label. x=. should\n                // look like a rule ref since could be subtree.\n                if ( type==TREE_PARSER && pair!=null &&\n                     pair.elementRef.getType()==ANTLRParser.WILDCARD )\n                {\n                    if ( labelType==WILDCARD_TREE_LABEL ) {\n                        labels.add(labelName);\n                        continue;\n                    }\n                    else continue;\n                }\n                 */\n                // if valid label and type is what we're looking for\n\t\t\t\t// and not ref to old value val $rule, add to list\n\t\t\t\tif ( pair!=null && pair.type==labelType &&\n\t\t\t\t\t !labelName.equals(el.enclosingRuleName) )\n\t\t\t\t{\n\t\t\t\t\tlabels.add(labelName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn labels;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a set of all rewrite elements on right of -&gt;, filter for label types such as Grammar.TOKEN_LABEL, Grammar.TOKEN_LIST_LABEL, ... Return a displayable token type name computed from the GrammarAST.", "call_func_name": ["java.util.HashSet.<init>", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.GrammarAST.getType", "org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getLocallyDefinedRule", "org.antlr.tool.Rule.getLabel", "java.lang.String.equals", "java.util.Set.add"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["java.lang.String"], ["java.lang.String"], ["java.lang.Object"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "587", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.examineAllExecutableActions", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected void examineAllExecutableActions() {\n\t\tCollection<Rule> rules = getRules();\n\t\tfor (Rule r : rules) {\n\t\t\t// walk all actions within the rule elements, args, and exceptions\n\t\t\tList<GrammarAST> actions = r.getInlineActions();\n\t\t\tfor (int i = 0; i < actions.size(); i++) {\n\t\t\t\tGrammarAST actionAST = actions.get(i);\n\t\t\t\tActionAnalysis sniffer =\n\t\t\t\t\tnew ActionAnalysis(this, r.name, actionAST);\n\t\t\t\tsniffer.analyze();\n\t\t\t}\n\t\t\t// walk any named actions like @init, @after\n\t\t\tCollection<? extends Object> namedActions = r.getActions().values();\n\t\t\tfor (Object namedAction : namedActions) {\n\t\t\t\tGrammarAST actionAST = (GrammarAST)namedAction;\n\t\t\t\tActionAnalysis sniffer =\n\t\t\t\t\tnew ActionAnalysis(this, r.name, actionAST);\n\t\t\t\tsniffer.analyze();\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Before generating code, we examine all actions that can have $x.y and $y stuff in them because some code generation depends on Rule.referencedPredefinedRuleAttributes.  I need to remove unused rule labels for example.", "call_func_name": ["org.antlr.tool.Grammar.getRules", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Rule.getInlineActions", "java.util.List.size", "java.util.List.get", "org.antlr.grammar.v3.ActionAnalysis.<init>", "org.antlr.grammar.v3.ActionAnalysis.analyze", "org.antlr.tool.Rule.getActions", "java.util.Map.values"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["int"], ["org.antlr.tool.Grammar", "java.lang.String", "org.antlr.tool.GrammarAST"], [""], [""], [""]], "passed_comments": "/"}, {"index": "588", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.checkAllRulesForUselessLabels", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void checkAllRulesForUselessLabels() {\n\t\tif ( type==LEXER ) {\n\t\t\treturn;\n\t\t}\n\t\tSet<String> rules = nameToRuleMap.keySet();\n\t\tfor (String ruleName : rules) {\n\t\t\tRule r = getRule(ruleName);\n\t\t\tremoveUselessLabels(r.getRuleLabels());\n\t\t\tremoveUselessLabels(r.getRuleListLabels());\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Remove all labels on rule refs whose target rules have no return value. Do this for all rules in grammar.", "call_func_name": ["java.util.LinkedHashMap.keySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getRule", "org.antlr.tool.Rule.getRuleLabels", "org.antlr.tool.Grammar.removeUselessLabels", "org.antlr.tool.Rule.getRuleListLabels"], "call_func_parameter": [[""], [""], [""], [""], ["java.lang.String"], [""], ["java.util.Map"], [""]], "passed_comments": [{"org.antlr.tool.Grammar.removeUselessLabels": "A label on a rule is useless if the rule has no return value, no tree or template output, and it is not referenced in an action."}]}, {"index": "589", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.removeUselessLabels", "methodParameterType": "Map<String,LabelElementPair>#", "methodParameterName": "ruleToElementLabelPairMap#", "methodBody": "protected void removeUselessLabels(Map<String, LabelElementPair> ruleToElementLabelPairMap) {\n\t\tif ( ruleToElementLabelPairMap==null ) {\n\t\t\treturn;\n\t\t}\n\t\tCollection<LabelElementPair> labels = ruleToElementLabelPairMap.values();\n\t\tList<String> kill = new ArrayList<String>();\n\t\tfor (LabelElementPair pair : labels) {\n\t\t\tRule refdRule = getRule(pair.elementRef.getText());\n\t\t\tif ( refdRule!=null && !refdRule.getHasReturnValue() && !pair.actionReferencesLabel ) {\n\t\t\t\t//System.out.println(pair.label.getText()+\" is useless\");\n\t\t\t\tkill.add(pair.label.getText());\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < kill.size(); i++) {\n\t\t\tString labelToKill = kill.get(i);\n\t\t\t// System.out.println(\"kill \"+labelToKill);\n\t\t\truleToElementLabelPairMap.remove(labelToKill);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression)InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "A label on a rule is useless if the rule has no return value, no tree or template output, and it is not referenced in an action.", "call_func_name": ["java.util.Map.values", "java.util.ArrayList.<init>", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getRule", "org.antlr.tool.Rule.getHasReturnValue", "org.antlr.runtime.Token.getText", "java.util.List.add", "java.util.List.size", "java.util.List.get", "java.util.Map.remove"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["java.lang.String"], [""], [""], ["java.lang.Object"], [""], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}]}, {"index": "590", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.altReferencesRule", "methodParameterType": "String#GrammarAST#GrammarAST#int#", "methodParameterName": "enclosingRuleName#refScopeAST#refAST#outerAltNum#", "methodBody": "public void altReferencesRule(String enclosingRuleName,\n\t\t\t\t\t\t\t\t  GrammarAST refScopeAST,\n\t\t\t\t\t\t\t\t  GrammarAST refAST,\n\t\t\t\t\t\t\t\t  int outerAltNum)\n\t{\n\t\t/* Do nothing for now; not sure need; track S.x as x\n\t\tString scope = null;\n\t\tGrammar scopeG = null;\n\t\tif ( refScopeAST!=null ) {\n\t\t\tif ( !scopedRuleRefs.contains(refScopeAST) ) {\n\t\t\t\tscopedRuleRefs.add(refScopeAST);\n\t\t\t}\n\t\t\tscope = refScopeAST.getText();\n\t\t}\n\t\t*/\n\t\tRule r = getRule(enclosingRuleName);\n\t\tif ( r==null ) {\n\t\t\treturn; // no error here; see NameSpaceChecker\n\t\t}\n\t\tr.trackRuleReferenceInAlt(refAST, outerAltNum);\n\t\tToken refToken = refAST.getToken();\n\t\tif ( !ruleRefs.contains(refAST) ) {\n\t\t\truleRefs.add(refAST);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track a rule reference within an outermost alt of a rule.  Used at the moment to decide if $ruleref refers to a unique rule ref in the alt.  Rewrite rules force tracking of all rule AST results. This data is also used to verify that all rules have been defined.", "call_func_name": ["org.antlr.tool.Grammar.getRule", "org.antlr.tool.Rule.trackRuleReferenceInAlt", "org.antlr.tool.GrammarAST.getToken", "java.util.Set.contains", "java.util.Set.add"], "call_func_parameter": [["java.lang.String"], ["org.antlr.tool.GrammarAST", "int"], [""], ["java.lang.Object"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "591", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.altReferencesTokenID", "methodParameterType": "String#GrammarAST#int#", "methodParameterName": "ruleName#refAST#outerAltNum#", "methodBody": "public void altReferencesTokenID(String ruleName, GrammarAST refAST, int outerAltNum) {\n\t\tRule r = getLocallyDefinedRule(ruleName);\n\t\tif ( r==null ) {\n\t\t\treturn;\n\t\t}\n\t\tr.trackTokenReferenceInAlt(refAST, outerAltNum);\n\t\tif ( !tokenIDRefs.contains(refAST.getToken()) ) {\n\t\t\ttokenIDRefs.add(refAST.getToken());\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track a token reference within an outermost alt of a rule.  Used to decide if $tokenref refers to a unique token ref in the alt. Does not track literals! Rewrite rules force tracking of all tokens.", "call_func_name": ["org.antlr.tool.Grammar.getLocallyDefinedRule", "org.antlr.tool.Rule.trackTokenReferenceInAlt", "org.antlr.tool.GrammarAST.getToken", "java.util.Set.contains", "java.util.Set.add"], "call_func_parameter": [["java.lang.String"], ["org.antlr.tool.GrammarAST", "int"], [""], ["java.lang.Object"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.Rule.trackTokenReferenceInAlt": "Track a token ID or literal like '+' and \"void\" as having been referenced somewhere within the alts (not rewrite sections) of a rule. This differs from Grammar.altReferencesTokenID(), which tracks all token IDs to check for token IDs without corresponding lexer rules."}]}, {"index": "592", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.referenceRuleLabelPredefinedAttribute", "methodParameterType": "String#", "methodParameterName": "ruleName#", "methodBody": "public void referenceRuleLabelPredefinedAttribute(String ruleName) {\n\t\tRule r = getRule(ruleName);\n\t\tif ( r!=null && type!=LEXER ) {\n\t\t\t// indicate that an action ref'd an attr unless it's in a lexer\n\t\t\t// so that $ID.text refs don't force lexer rules to define\n\t\t\t// return values...Token objects are created by the caller instead.\n\t\t\tr.referencedPredefinedRuleAttributes = true;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "To yield smaller, more readable code, track which rules have their predefined attributes accessed.  If the rule has no user-defined return values, then don't generate the return value scope classes etc...  Make the rule have void return value.  Don't track for lexer rules.", "call_func_name": ["org.antlr.tool.Grammar.getRule"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "593", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getLeftRecursiveRules", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<Rule> getLeftRecursiveRules() {\n\t\tif ( nfa==null ) {\n\t\t\tbuildNFA();\n\t\t}\n\t\tif ( leftRecursiveRules!=null ) {\n\t\t\treturn leftRecursiveRules;\n\t\t}\n\t\tsanity.checkAllRulesForLeftRecursion();\n\t\treturn leftRecursiveRules;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of left-recursive rules; no analysis can be done successfully on these.  Useful to skip these rules then and also for ANTLRWorks to highlight them.", "call_func_name": ["org.antlr.tool.Grammar.buildNFA", "org.antlr.tool.GrammarSanity.checkAllRulesForLeftRecursion"], "call_func_parameter": [[""], [""]], "passed_comments": [{"org.antlr.tool.GrammarSanity.checkAllRulesForLeftRecursion": "Check all rules for infinite left recursion before analysis. Return list of troublesome rule cycles.  This method has two side-effects: it notifies the error manager that we have problems and it sets the list of recursive rules that we should ignore during analysis."}]}, {"index": "594", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.isEmptyRule", "methodParameterType": "GrammarAST#", "methodParameterName": "block#", "methodBody": "public boolean isEmptyRule(GrammarAST block) {\n\t\tBitSet nonEmptyTerminals = new BitSet();\n\t\tnonEmptyTerminals.set(ANTLRParser.TOKEN_REF);\n\t\tnonEmptyTerminals.set(ANTLRParser.STRING_LITERAL);\n\t\tnonEmptyTerminals.set(ANTLRParser.CHAR_LITERAL);\n\t\tnonEmptyTerminals.set(ANTLRParser.WILDCARD);\n\t\tnonEmptyTerminals.set(ANTLRParser.RULE_REF);\n\t\treturn findFirstTypeOutsideRewrite(block, nonEmptyTerminals) == null;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Rules like \"a : ;\" and \"a : {...} ;\" should not generate try/catch blocks for RecognitionException.  To detect this it's probably ok to just look for any reference to an atom that can match some input.  W/o that, the rule is unlikey to have any else.", "call_func_name": ["java.util.BitSet.<init>", "java.util.BitSet.set", "org.antlr.tool.Grammar.findFirstTypeOutsideRewrite"], "call_func_parameter": [[""], ["int"], ["org.antlr.tool.GrammarAST", "java.util.BitSet"]], "passed_comments": "/"}, {"index": "595", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getTokenIDs", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<String> getTokenIDs() {\n\t\treturn composite.tokenIDToTypeMap.keySet();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the list of tokens that are IDs like BLOCK and LPAREN", "call_func_name": ["java.util.Map.keySet"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "596", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getTokenTypesWithoutID", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Collection<Integer> getTokenTypesWithoutID() {\n\t\tList<Integer> types = new ArrayList<Integer>();\n\t\tfor (int t =Label.MIN_TOKEN_TYPE; t<=getMaxTokenType(); t++) {\n\t\t\tString name = getTokenDisplayName(t);\n\t\t\tif ( name.charAt(0)=='\\'' ) {\n\t\t\t\ttypes.add(Utils.integer(t));\n\t\t\t}\n\t\t}\n\t\treturn types;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return an ordered integer list of token types that have no corresponding token ID like INT or KEYWORD_BEGIN; for stuff like 'begin'.", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.Grammar.getMaxTokenType", "org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt", "org.antlr.misc.Utils.integer", "java.util.List.add"], "call_func_parameter": [[""], [""], ["int"], ["int"], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.Grammar.getMaxTokenType": "How many token types have been allocated so far?"}, {"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "597", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getTokenDisplayNames", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<String> getTokenDisplayNames() {\n\t\tSet<String> names = new HashSet<String>();\n\t\tfor (int t =Label.MIN_TOKEN_TYPE; t <=getMaxTokenType(); t++) {\n\t\t\tnames.add(getTokenDisplayName(t));\n\t\t}\n\t\treturn names;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get a list of all token IDs and literals that have an associated token type.", "call_func_name": ["java.util.HashSet.<init>", "org.antlr.tool.Grammar.getMaxTokenType", "org.antlr.tool.Grammar.getTokenDisplayName", "java.util.Set.add"], "call_func_parameter": [[""], [""], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.Grammar.getMaxTokenType": "How many token types have been allocated so far?"}, {"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "598", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral", "methodParameterType": "String#", "methodParameterName": "literal#", "methodBody": "public static int getCharValueFromGrammarCharLiteral(String literal) {\n\t\tswitch ( literal.length() ) {\n\t\t\tcase 3 :\n\t\t\t\t// 'x'\n\t\t\t\treturn literal.charAt(1); // no escape char\n\t\t\tcase 4 :\n\t\t\t\t// '\\x'  (antlr lexer will catch invalid char)\n\t\t\t\tif ( Character.isDigit(literal.charAt(2)) ) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   \"invalid char literal: \"+literal);\n\t\t\t\t\treturn -1;\n\t\t\t\t}\n\t\t\t\tint escChar = literal.charAt(2);\n\t\t\t\tint charVal = ANTLRLiteralEscapedCharValue[escChar];\n\t\t\t\tif ( charVal==0 ) {\n\t\t\t\t\t// Unnecessary escapes like '\\{' should just yield {\n\t\t\t\t\treturn escChar;\n\t\t\t\t}\n\t\t\t\treturn charVal;\n\t\t\tcase 8 :\n\t\t\t\t// '\\u1234'\n\t\t\t\tString unicodeChars = literal.substring(3,literal.length()-1);\n\t\t\t\treturn Integer.parseInt(unicodeChars, 16);\n\t\t\tdefault :\n\t\t\t\tErrorManager.error(ErrorManager.MSG_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t   \"invalid char literal: \"+literal);\n\t\t\t\treturn -1;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#NumberLiteral#SwitchCase#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ReturnStatement#NumberLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#NumberLiteral#PrefixExpression#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#NumberLiteral#SwitchCase#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#ReturnStatement#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#NumberLiteral#PrefixExpression#ReturnStatement#SwitchStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SwitchStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SwitchCase(NumberLiteral)NumberLiteral)SwitchCase(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ReturnStatement(SwitchCase(NumberLiteral)NumberLiteral)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement(SwitchCase(NumberLiteral)NumberLiteral)SwitchCase(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)ReturnStatement(SwitchCase)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement)SwitchStatement)Block)MethodDeclaration", "methodDoc": "Given a literal like (the 3 char sequence with single quotes) 'a', return the int value of 'a'. Convert escape sequences here also. ANTLR's antlr.g parser does not convert escape sequences. 11/26/2005: I changed literals to always be '...' even for strings. This routine still works though.", "call_func_name": ["java.lang.String.length", "java.lang.String.charAt", "java.lang.Character.isDigit", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.ErrorManager.error", "java.lang.String.substring", "java.lang.Integer.parseInt"], "call_func_parameter": [[""], ["int"], ["char"], [""], ["java.lang.String"], [""], ["int", "java.lang.Object"], ["int", "int"], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "599", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getUnescapedStringFromGrammarStringLiteral", "methodParameterType": "String#", "methodParameterName": "literal#", "methodBody": "public static StringBuffer getUnescapedStringFromGrammarStringLiteral(String literal) {\n\t\t//System.out.println(\"escape: [\"+literal+\"]\");\n\t\tStringBuffer buf = new StringBuffer();\n\t\tint last = literal.length()-1; // skip quotes on outside\n\t\tfor (int i=1; i<last; i++) {\n\t\t\tchar c = literal.charAt(i);\n\t\t\tif ( c=='\\\\' ) {\n\t\t\t\ti++;\n\t\t\t\tc = literal.charAt(i);\n\t\t\t\tif ( Character.toUpperCase(c)=='U' ) {\n\t\t\t\t\t// \\u0000\n\t\t\t\t\ti++;\n\t\t\t\t\tString unicodeChars = literal.substring(i,i+4);\n\t\t\t\t\t// parse the unicode 16 bit hex value\n\t\t\t\t\tint val = Integer.parseInt(unicodeChars, 16);\n\t\t\t\t\ti+=4-1; // loop will inc by 1; only jump 3 then\n\t\t\t\t\tbuf.append((char)val);\n\t\t\t\t}\n\t\t\t\telse if ( Character.isDigit(c) ) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   \"invalid char literal: \"+literal);\n\t\t\t\t\tbuf.append(\"\\\\\").append(c);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.append((char)ANTLRLiteralEscapedCharValue[c]); // normal \\x escape\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf.append(c); // simple char x\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"string: [\"+buf.toString()+\"]\");\n\t\treturn buf;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#CharacterLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#PrimitiveType#SimpleName#SimpleName#ArrayAccess#CastExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)CastExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "ANTLR does not convert escape sequences during the parse phase because it could not know how to print String/char literals back out when printing grammars etc...  Someone in China might use the real unicode char in a literal as it will display on their screen; when printing back out, I could not know whether to display or use a unicode escape. This routine converts a string literal with possible escape sequences into a pure string of 16-bit char values.  Escapes and unicode \\u0000 specs are converted to pure chars.  return in a buffer; people may want to walk/manipulate further. The NFA construction routine must know the actual char values.", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.String.length", "java.lang.String.charAt", "java.lang.Character.toUpperCase", "java.lang.String.substring", "java.lang.Integer.parseInt", "java.lang.StringBuffer.append", "java.lang.Character.isDigit", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.ErrorManager.error", "java.lang.StringBuffer.append"], "call_func_parameter": [[""], [""], ["int"], ["char"], ["int", "int"], ["java.lang.String", "int"], ["char"], ["char"], [""], ["java.lang.String"], [""], ["int", "java.lang.Object"], ["java.lang.String"]], "passed_comments": "/"}, {"index": "600", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.importTokenVocabulary", "methodParameterType": "Grammar#", "methodParameterName": "importFromGr#", "methodBody": "public int importTokenVocabulary(Grammar importFromGr) {\n\t\tSet<String> importedTokenIDs = importFromGr.getTokenIDs();\n\t\tfor (String tokenID : importedTokenIDs) {\n\t\t\tint tokenType = importFromGr.getTokenType(tokenID);\n\t\t\tcomposite.maxTokenType = Math.max(composite.maxTokenType,tokenType);\n\t\t\tif ( tokenType>=Label.MIN_TOKEN_TYPE ) {\n\t\t\t\t//System.out.println(\"import token from grammar \"+tokenID+\"=\"+tokenType);\n\t\t\t\tdefineToken(tokenID, tokenType);\n\t\t\t}\n\t\t}\n\t\treturn composite.maxTokenType; // return max found\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Pull your token definitions from an existing grammar in memory. You must use Grammar() ctor then this method then setGrammarContent() to make this work.  This was useful primarily for testing and interpreting grammars until I added import grammar functionality. When you import a grammar you implicitly import its vocabulary as well and keep the same token type values. Returns the max token type found.", "call_func_name": ["org.antlr.tool.Grammar.getTokenIDs", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getTokenType", "java.lang.Math.max", "org.antlr.tool.Grammar.defineToken"], "call_func_parameter": [[""], [""], [""], [""], ["java.lang.String"], ["int", "int"], ["java.lang.String", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenIDs": "Get the list of tokens that are IDs like BLOCK and LPAREN"}, {"org.antlr.tool.Grammar.defineToken": "Define a token at a particular token type value.  Blast an old value with a new one.  This is called normal grammar processsing and during import vocab operations to set tokens with specific values."}]}, {"index": "601", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.importGrammar", "methodParameterType": "GrammarAST#String#", "methodParameterName": "grammarNameAST#label#", "methodBody": "public void importGrammar(GrammarAST grammarNameAST, String label) {\n\t\tString grammarName = grammarNameAST.getText();\n\t\t//System.out.println(\"import \"+gfile.getName());\n\t\tString gname = grammarName + GRAMMAR_FILE_EXTENSION;\n\t\tBufferedReader br = null;\n\t\ttry {\n\t\t\tString fullName = tool.getLibraryFile(gname);\n\t\t\tFileReader fr = new FileReader(fullName);\n\t\t\tbr = new BufferedReader(fr);\n\t\t\tGrammar delegateGrammar;\n\t\t\tdelegateGrammar = new Grammar(tool, gname, composite);\n\t\t\tdelegateGrammar.label = label;\n\n\t\t\taddDelegateGrammar(delegateGrammar);\n\n\t\t\tdelegateGrammar.parseAndBuildAST(br);\n\t\t\tdelegateGrammar.addRulesForSyntacticPredicates();\n\t\t\tif ( !validImport(delegateGrammar) ) {\n\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_INVALID_IMPORT,\n\t\t\t\t\t\t\t\t\t\t  this,\n\t\t\t\t\t\t\t\t\t\t  grammarNameAST.token,\n\t\t\t\t\t\t\t\t\t\t  this,\n\t\t\t\t\t\t\t\t\t\t  delegateGrammar);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( this.type==COMBINED &&\n\t\t\t\t (delegateGrammar.name.equals(this.name+grammarTypeToFileNameSuffix[LEXER])||\n\t\t\t\t  delegateGrammar.name.equals(this.name+grammarTypeToFileNameSuffix[PARSER])) )\n\t\t\t{\n\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_IMPORT_NAME_CLASH,\n\t\t\t\t\t\t\t\t\t\t  this,\n\t\t\t\t\t\t\t\t\t\t  grammarNameAST.token,\n\t\t\t\t\t\t\t\t\t\t  this,\n\t\t\t\t\t\t\t\t\t\t  delegateGrammar);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif ( delegateGrammar.grammarTree!=null ) {\n\t\t\t\t// we have a valid grammar\n\t\t\t\t// deal with combined grammars\n\t\t\t\tif ( delegateGrammar.type == LEXER && this.type == COMBINED ) {\n\t\t\t\t\t// ooops, we wasted some effort; tell lexer to read it in\n\t\t\t\t\t// later\n\t\t\t\t\tlexerGrammarST.add(\"imports\", grammarName);\n\t\t\t\t\t// but, this parser grammar will need the vocab\n\t\t\t\t\t// so add to composite anyway so we suck in the tokens later\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"Got grammar:\\n\"+delegateGrammar);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tErrorManager.error(ErrorManager.MSG_CANNOT_OPEN_FILE,\n\t\t\t\t\t\t\t   gname,\n\t\t\t\t\t\t\t   ioe);\n\t\t}\n\t\tfinally {\n\t\t\tif ( br!=null ) {\n\t\t\t\ttry {\n\t\t\t\t\tbr.close();\n\t\t\t\t}\n\t\t\t\tcatch (IOException ioe) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_CANNOT_CLOSE_FILE,\n\t\t\t\t\t\t\t\t\t   gname,\n\t\t\t\t\t\t\t\t\t   ioe);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#ArrayAccess#InfixExpression#MethodInvocation#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#IfStatement#Block#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)InfixExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)InfixExpression)MethodInvocation)InfixExpression)ParenthesizedExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)IfStatement)Block)TryStatement)Block)MethodDeclaration", "methodDoc": "Import the rules/tokens of a delegate grammar. All delegate grammars are read during the ctor of first Grammar created. Do not create NFA here because NFA construction needs to hook up with overridden rules in delegation root grammar.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.Tool.getLibraryFile", "java.io.FileReader.<init>", "java.io.BufferedReader.<init>", "org.antlr.tool.Grammar.<init>", "org.antlr.tool.Grammar.addDelegateGrammar", "org.antlr.tool.Grammar.parseAndBuildAST", "org.antlr.tool.Grammar.addRulesForSyntacticPredicates", "org.antlr.tool.Grammar.validImport", "org.antlr.tool.ErrorManager.grammarError", "java.io.BufferedReader.close", "org.antlr.tool.ErrorManager.error", "java.lang.String.equals", "org.stringtemplate.v4.ST.add"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.String"], ["java.io.Reader"], ["org.antlr.Tool", "java.lang.String", "org.antlr.tool.CompositeGrammar"], ["org.antlr.tool.Grammar"], ["java.io.Reader"], [""], ["org.antlr.tool.Grammar"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"], [""], ["int", "java.lang.Object", "java.lang.Throwable"], ["java.lang.Object"], ["java.lang.String", "java.lang.Object"]], "passed_comments": [{"org.antlr.Tool.getLibraryFile": "Name a file from the -lib dir.  Imported grammars and .tokens files If we do not locate the file in the library directory, then we try the location of the originating grammar."}, {"org.antlr.tool.Grammar.addDelegateGrammar": "add new delegate to composite tree"}, {"org.antlr.tool.Grammar.validImport": "Many imports are illegal such as lexer into a tree grammar"}]}, {"index": "602", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.addDelegateGrammar", "methodParameterType": "Grammar#", "methodParameterName": "delegateGrammar#", "methodBody": "protected void addDelegateGrammar(Grammar delegateGrammar) {\n\t\tCompositeGrammarTree t = composite.delegateGrammarTreeRoot.findNode(this);\n\t\tt.addChild(new CompositeGrammarTree(delegateGrammar));\n\t\t// make sure new grammar shares this composite\n\t\tdelegateGrammar.composite = this.composite;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ThisExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#FieldAccess#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "add new delegate to composite tree", "call_func_name": ["org.antlr.tool.CompositeGrammarTree.findNode", "org.antlr.tool.CompositeGrammarTree.<init>", "org.antlr.tool.CompositeGrammarTree.addChild"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["org.antlr.tool.Grammar"], ["org.antlr.tool.CompositeGrammarTree"]], "passed_comments": "/"}, {"index": "603", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.importTokenVocabulary", "methodParameterType": "GrammarAST#String#", "methodParameterName": "tokenVocabOptionAST#vocabName#", "methodBody": "public int importTokenVocabulary(GrammarAST tokenVocabOptionAST,\n\t\t\t\t\t\t\t\t\t String vocabName)\n\t{\n\t\tif ( !getGrammarIsRoot() ) {\n\t\t\tErrorManager.grammarWarning(ErrorManager.MSG_TOKEN_VOCAB_IN_DELEGATE,\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\ttokenVocabOptionAST.token,\n\t\t\t\t\t\t\t\t\t\tname);\n\t\t\treturn composite.maxTokenType;\n\t\t}\n\n\t\tFile fullFile = tool.getImportedVocabFile(vocabName);\n\t\ttry {\n\t\t\tFileReader fr = new FileReader(fullFile);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tStreamTokenizer tokenizer = new StreamTokenizer(br);\n\t\t\ttokenizer.parseNumbers();\n\t\t\ttokenizer.wordChars('_', '_');\n\t\t\ttokenizer.eolIsSignificant(true);\n\t\t\ttokenizer.slashSlashComments(true);\n\t\t\ttokenizer.slashStarComments(true);\n\t\t\ttokenizer.ordinaryChar('=');\n\t\t\ttokenizer.quoteChar('\\'');\n\t\t\ttokenizer.whitespaceChars(' ',' ');\n\t\t\ttokenizer.whitespaceChars('\\t','\\t');\n\t\t\tint lineNum = 1;\n\t\t\tint token = tokenizer.nextToken();\n\t\t\twhile (token != StreamTokenizer.TT_EOF) {\n\t\t\t\tString tokenID;\n\t\t\t\tif ( token == StreamTokenizer.TT_WORD ) {\n\t\t\t\t\ttokenID = tokenizer.sval;\n\t\t\t\t}\n\t\t\t\telse if ( token == '\\'' ) {\n\t\t\t\t\ttokenID = \"'\"+tokenizer.sval+\"'\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   vocabName+CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t   Utils.integer(lineNum));\n\t\t\t\t\twhile ( tokenizer.nextToken() != StreamTokenizer.TT_EOL ) {}\n\t\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\tif ( token != '=' ) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   vocabName+CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t   Utils.integer(lineNum));\n\t\t\t\t\twhile ( tokenizer.nextToken() != StreamTokenizer.TT_EOL ) {}\n\t\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttoken = tokenizer.nextToken(); // skip '='\n\t\t\t\tif ( token != StreamTokenizer.TT_NUMBER ) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   vocabName+CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t   Utils.integer(lineNum));\n\t\t\t\t\twhile ( tokenizer.nextToken() != StreamTokenizer.TT_EOL ) {}\n\t\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tint tokenType = (int)tokenizer.nval;\n\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\t//System.out.println(\"import \"+tokenID+\"=\"+tokenType);\n\t\t\t\tcomposite.maxTokenType = Math.max(composite.maxTokenType,tokenType);\n\t\t\t\tdefineToken(tokenID, tokenType);\n\t\t\t\tlineNum++;\n\t\t\t\tif ( token != StreamTokenizer.TT_EOL ) {\n\t\t\t\t\tErrorManager.error(ErrorManager.MSG_TOKENS_FILE_SYNTAX_ERROR,\n\t\t\t\t\t\t\t\t\t   vocabName+CodeGenerator.VOCAB_FILE_EXTENSION,\n\t\t\t\t\t\t\t\t\t   Utils.integer(lineNum));\n\t\t\t\t\twhile ( tokenizer.nextToken() != StreamTokenizer.TT_EOL ) {}\n\t\t\t\t\ttoken = tokenizer.nextToken();\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\ttoken = tokenizer.nextToken(); // skip newline\n\t\t\t}\n\t\t\tbr.close();\n\t\t}\n\t\tcatch (FileNotFoundException fnfe) {\n\t\t\tErrorManager.error(ErrorManager.MSG_CANNOT_FIND_TOKENS_FILE,\n\t\t\t\t\t\t\t   fullFile);\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tErrorManager.error(ErrorManager.MSG_ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t   fullFile,\n\t\t\t\t\t\t\t   ioe);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tErrorManager.error(ErrorManager.MSG_ERROR_READING_TOKENS_FILE,\n\t\t\t\t\t\t\t   fullFile,\n\t\t\t\t\t\t\t   e);\n\t\t}\n\t\treturn composite.maxTokenType;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#CharacterLiteral#CharacterLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#CharacterLiteral#InfixExpression#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#Block#WhileStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block)Block)WhileStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block)Block)WhileStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block)Block)WhileStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(WhileStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block)Block)WhileStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Load a vocab file &lt;vocabName&gt;.tokens and return max token type found.", "call_func_name": ["org.antlr.tool.Grammar.getGrammarIsRoot", "org.antlr.tool.ErrorManager.grammarWarning", "org.antlr.Tool.getImportedVocabFile", "java.io.FileReader.<init>", "java.io.BufferedReader.<init>", "java.io.StreamTokenizer.<init>", "java.io.StreamTokenizer.parseNumbers", "java.io.StreamTokenizer.wordChars", "java.io.StreamTokenizer.eolIsSignificant", "java.io.StreamTokenizer.slashSlashComments", "java.io.StreamTokenizer.slashStarComments", "java.io.StreamTokenizer.ordinaryChar", "java.io.StreamTokenizer.quoteChar", "java.io.StreamTokenizer.whitespaceChars", "java.io.StreamTokenizer.nextToken", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.misc.Utils.integer", "org.antlr.tool.ErrorManager.error", "java.lang.Math.max", "org.antlr.tool.Grammar.defineToken", "java.io.BufferedReader.close", "org.antlr.tool.ErrorManager.error", "org.antlr.tool.ErrorManager.error"], "call_func_parameter": [[""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.String"], ["java.io.File"], ["java.io.Reader"], ["java.io.Reader"], [""], ["int", "int"], ["boolean"], ["boolean"], ["boolean"], ["int"], ["int"], ["int", "int"], [""], [""], ["java.lang.String"], [""], ["int"], ["int", "java.lang.Object", "java.lang.Object"], ["int", "int"], ["java.lang.String", "int"], [""], ["int", "java.lang.Object"], ["int", "java.lang.Object", "java.lang.Throwable"]], "passed_comments": [{"org.antlr.Tool.getImportedVocabFile": "Return a File descriptor for vocab file.  Look in library or in -o output path.  antlr -o foo T.g U.g where U needs T.tokens won't work unless we look in foo too. If we do not find the file in the lib directory then must assume that the .tokens file is going to be generated as part of this build and we have defined .tokens files so that they ALWAYS are generated in the base output directory, which means the current directory for the command line tool if there was no output directory specified."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.tool.Grammar.defineToken": "Define a token at a particular token type value.  Blast an old value with a new one.  This is called normal grammar processsing and during import vocab operations to set tokens with specific values."}]}, {"index": "604", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getTokenDisplayName", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "public String getTokenDisplayName(int ttype) {\n\t\tString tokenName;\n\t\tint index;\n\t\t// inside any target's char range and is lexer grammar?\n\t\tif ( this.type==LEXER &&\n\t\t\t ttype >= Label.MIN_CHAR_VALUE && ttype <= Label.MAX_CHAR_VALUE )\n\t\t{\n\t\t\treturn getANTLRCharLiteralForChar(ttype);\n\t\t}\n\t\t// faux label?\n\t\telse if ( ttype<0 ) {\n\t\t\ttokenName = composite.typeToTokenList.get(Label.NUM_FAUX_LABELS+ttype);\n\t\t}\n\t\telse {\n\t\t\t// compute index in typeToTokenList for ttype\n\t\t\tindex = ttype-1; // normalize to 0..n-1\n\t\t\tindex += Label.NUM_FAUX_LABELS;     // jump over faux tokens\n\n\t\t\tif ( index<composite.typeToTokenList.size() ) {\n\t\t\t\ttokenName = composite.typeToTokenList.get(index);\n\t\t\t\tif ( tokenName!=null &&\n\t\t\t\t\t tokenName.startsWith(AUTO_GENERATED_TOKEN_NAME_PREFIX) )\n\t\t\t\t{\n\t\t\t\t\ttokenName = composite.typeToStringLiteralList.get(ttype);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttokenName = String.valueOf(ttype);\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"getTokenDisplayName ttype=\"+ttype+\", index=\"+index+\", name=\"+tokenName);\n\t\treturn tokenName;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal.", "call_func_name": ["org.antlr.tool.Grammar.getANTLRCharLiteralForChar", "java.util.Vector.get", "java.util.Vector.size", "java.lang.String.startsWith", "java.lang.String.valueOf"], "call_func_parameter": [["int"], ["int"], [""], ["java.lang.String"], ["int"]], "passed_comments": [{"org.antlr.tool.Grammar.getANTLRCharLiteralForChar": "Return a string representing the escaped char for code c.  E.g., If c has value 0x100, you will get \"\\u0100\".  ASCII gets the usual char (non-hex) representation.  Control characters are spit out as unicode.  While this is specially set up for returning Java strings, it can be used by any language target that has the same syntax. :) 11/26/2005: I changed this to use double quotes, consistent with antlr.g 12/09/2005: I changed so everything is single quotes"}]}, {"index": "605", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getStringLiterals", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<String> getStringLiterals() {\n\t\treturn composite.stringLiteralToTypeMap.keySet();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the list of ANTLR String literals", "call_func_name": ["java.util.Map.keySet"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "606", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.setOption", "methodParameterType": "String#Object#Token#", "methodParameterName": "key#value#optionsStartToken#", "methodBody": "public String setOption(String key, Object value, Token optionsStartToken) {\n\t\tif ( legalOption(key) ) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_ILLEGAL_OPTION,\n\t\t\t\t\t\t\t\t\t  this,\n\t\t\t\t\t\t\t\t\t  optionsStartToken,\n\t\t\t\t\t\t\t\t\t  key);\n\t\t\treturn null;\n\t\t}\n\t\tif ( !optionIsValid(key, value) ) {\n\t\t\treturn null;\n\t\t}\n        if ( key.equals(\"backtrack\") && value.toString().equals(\"true\") ) {\n            composite.getRootGrammar().atLeastOneBacktrackOption = true;\n        }\n        if ( options==null ) {\n\t\t\toptions = new HashMap<String, Object>();\n\t\t}\n\t\toptions.put(key, value);\n\t\treturn key;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ThisExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#FieldAccess#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Save the option key/value pair and process it; return the key or null if invalid option.", "call_func_name": ["org.antlr.tool.Grammar.legalOption", "org.antlr.tool.ErrorManager.grammarError", "org.antlr.tool.Grammar.optionIsValid", "java.lang.String.equals", "java.lang.Object.toString", "org.antlr.tool.CompositeGrammar.getRootGrammar", "java.util.HashMap.<init>", "java.util.Map.put"], "call_func_parameter": [["java.lang.String"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.String", "java.lang.Object"], ["java.lang.Object"], [""], [""], [""], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "607", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getDelegatedRules", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<? extends Rule> getDelegatedRules() {\n\t\treturn composite.getDelegatedRules(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the set of Rules that need to have manual delegations like \"void rule() { importedGrammar.rule(); }\" If this grammar is master, get list of all rule definitions from all delegate grammars.  Only master has complete interface from combined grammars...we will generated delegates as helper objects. Composite grammars that are not the root/master do not have complete interfaces.  It is not my intention that people use subcomposites. Only the outermost grammar should be used from outside code.  The other grammar components are specifically generated to work only with the master/root. delegatedRules = imported - overridden", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDelegatedRules"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegatedRules": "Get set of rules for grammar g that need to have manual delegation methods.  This is the list of rules collected from all direct/indirect delegates minus rules overridden in grammar g. This returns null except for the delegate root because it is the only one that has to have a complete grammar rule interface.  The delegates should not be instantiated directly for use as parsers (you can create them to pass to the root parser's ctor as arguments)."}]}, {"index": "608", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getAllImportedRules", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<? extends Rule> getAllImportedRules() {\n\t\treturn composite.getAllImportedRules(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get set of all rules imported from all delegate grammars even if indirectly delegated.", "call_func_name": ["org.antlr.tool.CompositeGrammar.getAllImportedRules"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getAllImportedRules": "Get all rule definitions from all direct/indirect delegate grammars of g."}]}, {"index": "609", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getDelegates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Grammar> getDelegates() {\n\t\treturn composite.getDelegates(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get list of all delegates from all grammars directly or indirectly imported into this grammar.", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDelegates"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegates": "Get list of all delegates from all grammars in the delegate subtree of g. The grammars are in delegation tree preorder.  Don't include g itself in list as it is not a delegate of itself."}]}, {"index": "610", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getIndirectDelegates", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Grammar> getIndirectDelegates() {\n\t\treturn composite.getIndirectDelegates(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get delegates below direct delegates", "call_func_name": ["org.antlr.tool.CompositeGrammar.getIndirectDelegates"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getIndirectDelegates": "Get delegates below direct delegates of g"}]}, {"index": "611", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getDelegators", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Grammar> getDelegators() {\n\t\treturn composite.getDelegators(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get list of all delegators.  This amounts to the grammars on the path to the root of the delegation tree.", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDelegators"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegators": "Return list of delegate grammars from root down to g. Order is root, ..., g.parent.  (g not included)."}]}, {"index": "612", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getDelegator", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Grammar getDelegator() {\n\t\treturn composite.getDelegator(this);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ThisExpression#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Who's my direct parent grammar?", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDelegator"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegator": "Get parent of this grammar"}]}, {"index": "613", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getLookaheadDFAColumnsForLineInFile", "methodParameterType": "int#", "methodParameterName": "line#", "methodBody": "public List<Integer> getLookaheadDFAColumnsForLineInFile(int line) {\n\t\tString prefix = line+\":\";\n\t\tList<Integer> columns = new ArrayList<Integer>();\n\t\tfor (String key : lineColumnToLookaheadDFAMap.keySet()) {\n\t\t\tif(key.startsWith(prefix)) {\n\t\t\t\tcolumns.add(Integer.valueOf(key.substring(prefix.length())));\n\t\t\t}\n\t\t}\n\t\treturn columns;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "returns a list of column numbers for all decisions on a particular line so ANTLRWorks choose the decision depending on the location of the cursor (otherwise, ANTLRWorks has to give the", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.util.ArrayList.<init>", "java.util.Map.keySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.lang.String.startsWith", "java.lang.String.length", "java.lang.String.substring", "java.lang.Integer.valueOf", "java.util.List.add"], "call_func_parameter": [[""], ["int"], ["java.lang.String"], [""], [""], [""], [""], [""], [""], ["java.lang.String"], [""], ["int"], ["java.lang.String"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "614", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getLookaheadDFAFromPositionInFile", "methodParameterType": "int#int#", "methodParameterName": "line#col#", "methodBody": "public DFA getLookaheadDFAFromPositionInFile(int line, int col) {\n\t\treturn lineColumnToLookaheadDFAMap.get(\n\t\t\tnew StringBuffer().append(line).append(\":\").append(col).toString());\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(MethodInvocation(MethodInvocation(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Useful for ANTLRWorks to map position in file to the DFA for display", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.StringBuffer.append", "java.lang.StringBuffer.toString", "java.util.Map.get"], "call_func_parameter": [[""], ["int"], ["java.lang.String"], [""], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "615", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.setLookaheadDFA", "methodParameterType": "int#DFA#", "methodParameterName": "decision#lookaheadDFA#", "methodBody": "public void setLookaheadDFA(int decision, DFA lookaheadDFA) {\n\t\tDecision d = createDecision(decision);\n\t\td.dfa = lookaheadDFA;\n\t\tGrammarAST ast = d.startState.associatedASTNode;\n\t\tast.setLookaheadDFA(lookaheadDFA);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set the lookahead DFA for a particular decision.  This means that the appropriate AST node must updated to have the new lookahead DFA.  This method could be used to properly set the DFAs without using the createLookaheadDFAs() method.  You could do this Grammar g = new Grammar(\"...\"); g.setLookahead(1, dfa1); g.setLookahead(2, dfa2); ...", "call_func_name": ["org.antlr.tool.Grammar.createDecision", "org.antlr.tool.GrammarAST.setLookaheadDFA"], "call_func_parameter": [["int"], ["org.antlr.analysis.DFA"]], "passed_comments": "/"}, {"index": "616", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getMaxTokenType", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getMaxTokenType() {\n\t\treturn composite.maxTokenType;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "How many token types have been allocated so far?", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "617", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getMaxCharValue", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getMaxCharValue() {\n\t\tif ( generator!=null ) {\n\t\t\treturn generator.target.getMaxCharValue(generator);\n\t\t}\n\t\telse {\n\t\t\treturn Label.MAX_CHAR_VALUE;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "What is the max char value possible for this grammar's target?  Use unicode max if no target defined.", "call_func_name": ["org.antlr.codegen.Target.getMaxCharValue"], "call_func_parameter": [["org.antlr.codegen.CodeGenerator"]], "passed_comments": [{"org.antlr.codegen.Target.getMaxCharValue": "Some targets only support ASCII or 8-bit chars/strings.  For example, C++ will probably want to return 0xFF here."}]}, {"index": "618", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getTokenTypes", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public IntSet getTokenTypes() {\n\t\tif ( type==LEXER ) {\n\t\t\treturn getAllCharValues();\n\t\t}\n\t\treturn IntervalSet.of(Label.MIN_TOKEN_TYPE, getMaxTokenType());\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#InfixExpression#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a set of all possible token or char types for this grammar", "call_func_name": ["org.antlr.tool.Grammar.getAllCharValues", "org.antlr.tool.Grammar.getMaxTokenType", "org.antlr.misc.IntervalSet.of"], "call_func_parameter": [[""], [""], ["int", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getAllCharValues": "If there is a char vocabulary, use it; else return min to max char as defined by the target.  If no target, use max unicode char value."}, {"org.antlr.tool.Grammar.getMaxTokenType": "How many token types have been allocated so far?"}, {"org.antlr.misc.IntervalSet.of": "Create a set with all ints within range [a..b] (inclusive)"}]}, {"index": "619", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getAllCharValues", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public IntSet getAllCharValues() {\n\t\tif ( charVocabulary!=null ) {\n\t\t\treturn charVocabulary;\n\t\t}\n\t\tIntSet allChar = IntervalSet.of(Label.MIN_CHAR_VALUE, getMaxCharValue());\n\t\treturn allChar;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If there is a char vocabulary, use it; else return min to max char as defined by the target.  If no target, use max unicode char value.", "call_func_name": ["org.antlr.tool.Grammar.getMaxCharValue", "org.antlr.misc.IntervalSet.of"], "call_func_parameter": [[""], ["int", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getMaxCharValue": "What is the max char value possible for this grammar's target?  Use unicode max if no target defined."}, {"org.antlr.misc.IntervalSet.of": "Create a set with all ints within range [a..b] (inclusive)"}]}, {"index": "620", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getANTLRCharLiteralForChar", "methodParameterType": "int#", "methodParameterName": "c#", "methodBody": "public static String getANTLRCharLiteralForChar(int c) {\n\t\tif ( c<Label.MIN_CHAR_VALUE ) {\n\t\t\tErrorManager.internalError(\"invalid char value \"+c);\n\t\t\treturn \"'<INVALID>'\";\n\t\t}\n\t\tif ( c<ANTLRLiteralCharValueEscape.length && ANTLRLiteralCharValueEscape[c]!=null ) {\n\t\t\treturn '\\''+ANTLRLiteralCharValueEscape[c]+'\\'';\n\t\t}\n\t\tif ( Character.UnicodeBlock.of((char)c)==Character.UnicodeBlock.BASIC_LATIN &&\n\t\t\t !Character.isISOControl((char)c) ) {\n\t\t\tif ( c=='\\\\' ) {\n\t\t\t\treturn \"'\\\\\\\\'\";\n\t\t\t}\n\t\t\tif ( c=='\\'') {\n\t\t\t\treturn \"'\\\\''\";\n\t\t\t}\n\t\t\treturn '\\''+Character.toString((char)c)+'\\'';\n\t\t}\n\t\t// turn on the bit above max \"\\uFFFF\" value so that we pad with zeros\n\t\t// then only take last 4 digits\n\t\tString hex = Integer.toHexString(c|0x10000).toUpperCase().substring(1,5);\n\t\tString unicodeStr = \"'\\\\u\"+hex+\"'\";\n\t\treturn unicodeStr;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#StringLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#InfixExpression#CharacterLiteral#SimpleName#SimpleName#ArrayAccess#CharacterLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#CharacterLiteral#InfixExpression#StringLiteral#ReturnStatement#Block#IfStatement#SimpleName#CharacterLiteral#InfixExpression#StringLiteral#ReturnStatement#Block#IfStatement#CharacterLiteral#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#CharacterLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(InfixExpression(CharacterLiteral)CharacterLiteral(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(CharacterLiteral)CharacterLiteral)InfixExpression)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)PrefixExpression)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(InfixExpression(CharacterLiteral)CharacterLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a string representing the escaped char for code c.  E.g., If c has value 0x100, you will get \"\\u0100\".  ASCII gets the usual char (non-hex) representation.  Control characters are spit out as unicode.  While this is specially set up for returning Java strings, it can be used by any language target that has the same syntax. :) 11/26/2005: I changed this to use double quotes, consistent with antlr.g 12/09/2005: I changed so everything is single quotes", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.ErrorManager.internalError", "java.lang.StringBuilder.append", "java.lang.Character.isISOControl", "java.lang.Character.toString", "java.lang.Integer.toHexString", "java.lang.String.toUpperCase", "java.lang.String.substring"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], [""], ["java.lang.Object"], ["char"], ["char"], ["char"], ["int"], [""], ["int", "int"]], "passed_comments": "/"}, {"index": "621", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.complement", "methodParameterType": "IntSet#", "methodParameterName": "set#", "methodBody": "public IntSet complement(IntSet set) {\n\t\t//System.out.println(\"complement \"+set.toString(this));\n\t\t//System.out.println(\"vocabulary \"+getTokenTypes().toString(this));\n\t\tIntSet c = set.complement(getTokenTypes());\n\t\t//System.out.println(\"result=\"+c.toString(this));\n\t\treturn c;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For lexer grammars, return everything in unicode not in set. For parser and tree grammars, return everything in token space from MIN_TOKEN_TYPE to last valid token type or char value.", "call_func_name": ["org.antlr.tool.Grammar.getTokenTypes", "org.antlr.misc.IntSet.complement"], "call_func_parameter": [[""], ["org.antlr.misc.IntSet"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenTypes": "Return a set of all possible token or char types for this grammar"}]}, {"index": "622", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.isValidSet", "methodParameterType": "TreeToNFAConverter#GrammarAST#", "methodParameterName": "nfabuilder#t#", "methodBody": "public boolean isValidSet(TreeToNFAConverter nfabuilder, GrammarAST t) {\n\t\tboolean valid;\n\t\ttry {\n\t\t\t//System.out.println(\"parse BLOCK as set tree: \"+t.toStringTree());\n\t\t\tint alts = nfabuilder.testBlockAsSet(t);\n\t\t\tvalid = alts > 1;\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\t// The rule did not parse as a set, return null; ignore exception\n\t\t\tvalid = false;\n\t\t}\n\t\t//System.out.println(\"valid? \"+valid);\n\t\treturn valid;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)CatchClause)TryStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given set tree like ( SET A B ), check that A and B are both valid sets themselves, else we must tree like a BLOCK", "call_func_name": ["org.antlr.grammar.v3.TreeToNFAConverter.testBlockAsSet"], "call_func_parameter": [["org.antlr.tool.GrammarAST"]], "passed_comments": "/"}, {"index": "623", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getSetFromRule", "methodParameterType": "TreeToNFAConverter#String#", "methodParameterName": "nfabuilder#ruleName#", "methodBody": "public IntSet getSetFromRule(TreeToNFAConverter nfabuilder, String ruleName)\n\t\tthrows RecognitionException\n\t{\n\t\tRule r = getRule(ruleName);\n\t\tif ( r==null ) {\n\t\t\treturn null;\n\t\t}\n\t\tIntSet elements;\n\t\t//System.out.println(\"parsed tree: \"+r.tree.toStringTree());\n\t\telements = nfabuilder.setRule(r.tree);\n\t\t//System.out.println(\"elements=\"+elements);\n\t\treturn elements;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the set equivalent (if any) of the indicated rule from this grammar.  Mostly used in the lexer to do ~T for some fragment rule T.  If the rule AST has a SET use that.  If the rule is a single char convert it to a set and return.  If rule is not a simple set (w/o actions) then return null. Rules have AST form: ^( RULE ID modifier ARG RET SCOPE block EOR )", "call_func_name": ["org.antlr.tool.Grammar.getRule", "org.antlr.grammar.v3.TreeToNFAConverter.setRule"], "call_func_parameter": [["java.lang.String"], ["org.antlr.tool.GrammarAST"]], "passed_comments": "/"}, {"index": "624", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA", "methodParameterType": "NFAState#", "methodParameterName": "decisionState#", "methodBody": "public int getNumberOfAltsForDecisionNFA(NFAState decisionState) {\n\t\tif ( decisionState==null ) {\n\t\t\treturn 0;\n\t\t}\n\t\tint n = 1;\n\t\tNFAState p = decisionState;\n\t\twhile ( p.transition[1] !=null ) {\n\t\t\tn++;\n\t\t\tp = (NFAState)p.transition[1].target;\n\t\t}\n\t\treturn n;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NumberLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NumberLiteral)NumberLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "625", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.getNFAStateForAltOfDecision", "methodParameterType": "NFAState#int#", "methodParameterName": "decisionState#alt#", "methodBody": "public NFAState getNFAStateForAltOfDecision(NFAState decisionState, int alt) {\n\t\tif ( decisionState==null || alt<=0 ) {\n\t\t\treturn null;\n\t\t}\n\t\tint n = 1;\n\t\tNFAState p = decisionState;\n\t\twhile ( p!=null ) {\n\t\t\tif ( n==alt ) {\n\t\t\t\treturn p;\n\t\t\t}\n\t\t\tn++;\n\t\t\tTransition next = p.transition[1];\n\t\t\tp = null;\n\t\t\tif ( next!=null ) {\n\t\t\t\tp = (NFAState)next.target;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#Block#IfStatement#Block#WhileStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement)Block)IfStatement)Block)WhileStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "626", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Grammar.java", "methodName": "org.antlr.tool.Grammar.computeTokenNameFromLiteral", "methodParameterType": "int#String#", "methodParameterName": "tokenType#literal#", "methodBody": "public String computeTokenNameFromLiteral(int tokenType, String literal) {\n\t\treturn AUTO_GENERATED_TOKEN_NAME_PREFIX +tokenType;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "given a token type and the text of the literal, come up with a decent token type label.  For now it's just T&lt;type&gt;.  Actually, if there is an aliased name from tokens like PLUS='+', use it.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], [""]], "passed_comments": "/"}, {"index": "627", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/LeftRecursiveRuleAnalyzer.java", "methodName": "org.antlr.tool.LeftRecursiveRuleAnalyzer.ternaryAlt", "methodParameterType": "GrammarAST#GrammarAST#int#", "methodParameterName": "altTree#rewriteTree#alt#", "methodBody": "@Override\n\tpublic void ternaryAlt(GrammarAST altTree, GrammarAST rewriteTree, int alt) {\n\t\taltTree = GrammarAST.dupTree(altTree);\n\t\trewriteTree = GrammarAST.dupTree(rewriteTree);\n\n\t\tstripSynPred(altTree);\n\t\tstripLeftRecursion(altTree);\n\n\t\tint nextPrec = nextPrecedence(alt);\n\t\tST refST = recRuleTemplates.getInstanceOf(\"recRuleRef\");\n\t\trefST.add(\"ruleName\", ruleName);\n\t\trefST.add(\"arg\", nextPrec);\n\t\taltTree = replaceLastRuleRef(altTree, refST.render());\n\n\t\tString altText = text(altTree);\n\t\taltText = altText.trim();\n\t\taltText += \"{}\"; // add empty alt to prevent pred hoisting\n\t\tST nameST = recRuleTemplates.getInstanceOf(\"recRuleName\");\n\t\tnameST.add(\"ruleName\", ruleName);\n\t\trewriteTree = replaceRuleRefs(rewriteTree, \"$\" + nameST.render());\n\t\tString rewriteText = text(rewriteTree);\n\t\tternaryAlts.put(alt, altText + (rewriteText != null ? \" \" + rewriteText : \"\"));\n\t\t//System.out.println(\"ternaryAlt \" + alt + \": \" + altText + \", rewrite=\" + rewriteText);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#StringLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NullLiteral#InfixExpression#StringLiteral#SimpleName#InfixExpression#StringLiteral#ConditionalExpression#ParenthesizedExpression#InfixExpression#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(ParenthesizedExpression(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(StringLiteral)StringLiteral)ConditionalExpression)ParenthesizedExpression)InfixExpression)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Convert e ? e : e  &rarr;  ? e : e_[nextPrec]", "call_func_name": ["org.antlr.tool.GrammarAST.dupTree", "org.antlr.tool.LeftRecursiveRuleAnalyzer.stripSynPred", "org.antlr.tool.LeftRecursiveRuleAnalyzer.stripLeftRecursion", "org.antlr.tool.LeftRecursiveRuleAnalyzer.nextPrecedence", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.stringtemplate.v4.ST.add", "java.lang.Integer.valueOf", "org.stringtemplate.v4.ST.render", "org.antlr.tool.LeftRecursiveRuleAnalyzer.replaceLastRuleRef", "org.antlr.tool.LeftRecursiveRuleAnalyzer.text", "java.lang.String.trim", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.LeftRecursiveRuleAnalyzer.replaceRuleRefs", "java.util.LinkedHashMap.put"], "call_func_parameter": [["org.antlr.tool.GrammarAST"], ["org.antlr.tool.GrammarAST"], ["org.antlr.tool.GrammarAST"], ["int"], ["java.lang.String"], ["java.lang.String", "java.lang.Object"], ["int"], [""], ["org.antlr.tool.GrammarAST", "java.lang.String"], ["org.antlr.tool.GrammarAST"], [""], [""], ["java.lang.String"], [""], ["org.antlr.tool.GrammarAST", "java.lang.String"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "628", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/DOTGenerator.java", "methodName": "org.antlr.tool.DOTGenerator.DOTGenerator", "methodParameterType": "Grammar#", "methodParameterName": "grammar#", "methodBody": "public DOTGenerator(Grammar grammar) {\n\t\tthis.grammar = grammar;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "This aspect is associated with a grammar", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "629", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/DOTGenerator.java", "methodName": "org.antlr.tool.DOTGenerator.getDOT", "methodParameterType": "State#", "methodParameterName": "startState#", "methodBody": "public String getDOT(State startState) {\n\t\tif ( startState==null ) {\n\t\t\treturn null;\n\t\t}\n\t\t// The output DOT graph for visualization\n\t\tST dot;\n\t\tmarkedStates = new HashSet<Object>();\n        if ( startState instanceof DFAState ) {\n            dot = stlib.getInstanceOf(\"dfa\");\n\t\t\tdot.add(\"startState\",\n\t\t\t\t\tUtils.integer(startState.stateNumber));\n\t\t\tdot.add(\"useBox\",\n\t\t\t\t\tTool.internalOption_ShowNFAConfigsInDFA);\n\t\t\twalkCreatingDFADOT(dot, (DFAState)startState);\n        }\n        else {\n            dot = stlib.getInstanceOf(\"nfa\");\n\t\t\tdot.add(\"startState\",\n\t\t\t\t\tUtils.integer(startState.stateNumber));\n\t\t\twalkRuleNFACreatingDOT(dot, startState);\n        }\n\t\tdot.add(\"rankdir\", rankdir);\n        return dot.render();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a String containing a DOT description that, when displayed, will show the incoming state machine visually.  All nodes reachable from startState will be included.", "call_func_name": ["java.util.HashSet.<init>", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.misc.Utils.integer", "org.stringtemplate.v4.ST.add", "java.lang.Boolean.valueOf", "org.antlr.tool.DOTGenerator.walkCreatingDFADOT", "org.antlr.tool.DOTGenerator.walkRuleNFACreatingDOT", "org.stringtemplate.v4.ST.render"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], ["java.lang.String", "java.lang.Object"], ["boolean"], ["org.stringtemplate.v4.ST", "org.antlr.analysis.DFAState"], ["org.stringtemplate.v4.ST", "org.antlr.analysis.State"], [""]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.tool.DOTGenerator.walkCreatingDFADOT": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes."}, {"org.antlr.tool.DOTGenerator.walkRuleNFACreatingDOT": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes.  We know this is an NFA for a rule so don't traverse edges to other rules and don't go past rule end state."}]}, {"index": "630", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/DOTGenerator.java", "methodName": "org.antlr.tool.DOTGenerator.walkCreatingDFADOT", "methodParameterType": "ST#DFAState#", "methodParameterName": "dot#s#", "methodBody": "protected void walkCreatingDFADOT(ST dot,\n\t\t\t\t\t\t\t\t\t  DFAState s)\n    {\n\t\tif ( markedStates.contains(Utils.integer(s.stateNumber)) ) {\n\t\t\treturn; // already visited this node\n        }\n\n\t\tmarkedStates.add(Utils.integer(s.stateNumber)); // mark this node as completed.\n\n        // first add this node\n        ST st;\n        if ( s.isAcceptState() ) {\n            st = stlib.getInstanceOf(\"stopstate\");\n        }\n        else {\n            st = stlib.getInstanceOf(\"state\");\n        }\n        st.add(\"name\", getStateLabel(s));\n        dot.add(\"states\", st);\n\n        // make a DOT edge for each transition\n\t\tfor (int i = 0; i < s.getNumberOfTransitions(); i++) {\n\t\t\tTransition edge = s.transition(i);\n\t\t\t/*\n\t\t\tSystem.out.println(\"dfa \"+s.dfa.decisionNumber+\n\t\t\t\t\" edge from s\"+s.stateNumber+\" [\"+i+\"] of \"+s.getNumberOfTransitions());\n\t\t\t*/\n\t\t\tif ( STRIP_NONREDUCED_STATES ) {\n\t\t\t\tif ( edge.target instanceof DFAState &&\n\t\t\t\t\t((DFAState)edge.target).getAcceptStateReachable()!=DFA.REACHABLE_YES )\n\t\t\t\t{\n\t\t\t\t\tcontinue; // don't generate nodes for terminal states\n\t\t\t\t}\n\t\t\t}\n\t\t\tst = stlib.getInstanceOf(\"edge\");\n\t\t\tst.add(\"label\", getEdgeLabel(edge));\n\t\t\tst.add(\"src\", getStateLabel(s));\n            st.add(\"target\", getStateLabel(edge.target));\n\t\t\tst.add(\"arrowhead\", arrowhead);\n            dot.add(\"edges\", st);\n            walkCreatingDFADOT(dot, (DFAState)edge.target); // keep walkin'\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ContinueStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(IfStatement(InfixExpression(InstanceofExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(InfixExpression(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ContinueStatement)ContinueStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes.", "call_func_name": ["org.antlr.misc.Utils.integer", "java.util.Set.contains", "java.util.Set.add", "org.antlr.analysis.DFAState.isAcceptState", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.tool.DOTGenerator.getStateLabel", "org.stringtemplate.v4.ST.add", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.tool.DOTGenerator.getEdgeLabel", "org.antlr.tool.DOTGenerator.walkCreatingDFADOT"], "call_func_parameter": [["int"], ["java.lang.Object"], ["java.lang.Object"], [""], ["java.lang.String"], ["org.antlr.analysis.State"], ["java.lang.String", "java.lang.Object"], [""], ["int"], ["org.antlr.analysis.Transition"], ["org.stringtemplate.v4.ST", "org.antlr.analysis.DFAState"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.tool.DOTGenerator.getEdgeLabel": "Fix edge strings so they print out in DOT properly; generate any gated predicates on edge too."}, {"org.antlr.tool.DOTGenerator.walkCreatingDFADOT": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes."}]}, {"index": "631", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/DOTGenerator.java", "methodName": "org.antlr.tool.DOTGenerator.walkRuleNFACreatingDOT", "methodParameterType": "ST#State#", "methodParameterName": "dot#s#", "methodBody": "protected void walkRuleNFACreatingDOT(ST dot,\n                                          State s)\n    {\n        if ( markedStates.contains(s) ) {\n            return; // already visited this node\n        }\n\n        markedStates.add(s); // mark this node as completed.\n\n        // first add this node\n        ST stateST;\n        if ( s.isAcceptState() ) {\n            stateST = stlib.getInstanceOf(\"stopstate\");\n        }\n        else {\n            stateST = stlib.getInstanceOf(\"state\");\n        }\n        stateST.add(\"name\", getStateLabel(s));\n        dot.add(\"states\", stateST);\n\n        if ( s.isAcceptState() )  {\n            return; // don't go past end of rule node to the follow states\n        }\n\n        // special case: if decision point, then line up the alt start states\n        // unless it's an end of block\n\t\tif ( ((NFAState)s).isDecisionState() ) {\n\t\t\tGrammarAST n = ((NFAState)s).associatedASTNode;\n\t\t\tif ( n!=null && n.getType()!=ANTLRParser.EOB ) {\n\t\t\t\tST rankST = stlib.getInstanceOf(\"decision-rank\");\n\t\t\t\tNFAState alt = (NFAState)s;\n\t\t\t\twhile ( alt!=null ) {\n\t\t\t\t\trankST.add(\"states\", getStateLabel(alt));\n\t\t\t\t\tif ( alt.transition[1] !=null ) {\n\t\t\t\t\t\talt = (NFAState)alt.transition[1].target;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\talt=null;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdot.add(\"decisionRanks\", rankST);\n\t\t\t}\n\t\t}\n\n        // make a DOT edge for each transition\n\t\tST edgeST;\n\t\tfor (int i = 0; i < s.getNumberOfTransitions(); i++) {\n            Transition edge = s.transition(i);\n            if ( edge instanceof RuleClosureTransition ) {\n                RuleClosureTransition rr = ((RuleClosureTransition)edge);\n                // don't jump to other rules, but display edge to follow node\n                edgeST = stlib.getInstanceOf(\"edge\");\n\t\t\t\tif ( rr.rule.grammar != grammar ) {\n\t\t\t\t\tedgeST.add(\"label\", \"<\" + rr.rule.grammar.name + \".\" + rr.rule.name + \">\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tedgeST.add(\"label\", \"<\" + rr.rule.name + \">\");\n\t\t\t\t}\n\t\t\t\tedgeST.add(\"src\", getStateLabel(s));\n\t\t\t\tedgeST.add(\"target\", getStateLabel(rr.followState));\n\t\t\t\tedgeST.add(\"arrowhead\", arrowhead);\n                dot.add(\"edges\", edgeST);\n\t\t\t\twalkRuleNFACreatingDOT(dot, rr.followState);\n                continue;\n            }\n\t\t\tif ( edge.isAction() ) {\n\t\t\t\tedgeST = stlib.getInstanceOf(\"action-edge\");\n\t\t\t}\n\t\t\telse if ( edge.isEpsilon() ) {\n\t\t\t\tedgeST = stlib.getInstanceOf(\"epsilon-edge\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedgeST = stlib.getInstanceOf(\"edge\");\n\t\t\t}\n\t\t\tedgeST.add(\"label\", getEdgeLabel(edge));\n            edgeST.add(\"src\", getStateLabel(s));\n\t\t\tedgeST.add(\"target\", getStateLabel(edge.target));\n\t\t\tedgeST.add(\"arrowhead\", arrowhead);\n            dot.add(\"edges\", edgeST);\n            walkRuleNFACreatingDOT(dot, edge.target); // keep walkin'\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#Assignment#ExpressionStatement#Block#SimpleName#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#WhileStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleName#StringLiteral#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#StringLiteral#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(InfixExpression(StringLiteral)StringLiteral(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(InfixExpression(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes.  We know this is an NFA for a rule so don't traverse edges to other rules and don't go past rule end state.", "call_func_name": ["java.util.Set.contains", "java.util.Set.add", "org.antlr.analysis.State.isAcceptState", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.tool.DOTGenerator.getStateLabel", "org.stringtemplate.v4.ST.add", "org.antlr.analysis.NFAState.isDecisionState", "org.antlr.tool.GrammarAST.getType", "org.antlr.analysis.State.getNumberOfTransitions", "org.antlr.analysis.State.transition", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.DOTGenerator.walkRuleNFACreatingDOT", "org.antlr.analysis.Transition.isAction", "org.antlr.analysis.Transition.isEpsilon", "org.antlr.tool.DOTGenerator.getEdgeLabel"], "call_func_parameter": [["java.lang.Object"], ["java.lang.Object"], [""], ["java.lang.String"], ["org.antlr.analysis.State"], ["java.lang.String", "java.lang.Object"], [""], [""], [""], ["int"], [""], ["java.lang.String"], [""], ["org.stringtemplate.v4.ST", "org.antlr.analysis.State"], [""], [""], ["org.antlr.analysis.Transition"]], "passed_comments": [{"org.antlr.tool.DOTGenerator.walkRuleNFACreatingDOT": "Do a depth-first walk of the state machine graph and fill a DOT description template.  Keep filling the states and edges attributes.  We know this is an NFA for a rule so don't traverse edges to other rules and don't go past rule end state."}, {"org.antlr.tool.DOTGenerator.getEdgeLabel": "Fix edge strings so they print out in DOT properly; generate any gated predicates on edge too."}]}, {"index": "632", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/DOTGenerator.java", "methodName": "org.antlr.tool.DOTGenerator.getEdgeLabel", "methodParameterType": "Transition#", "methodParameterName": "edge#", "methodBody": "protected String getEdgeLabel(Transition edge) {\n\t\tString label = edge.label.toString(grammar);\n\t\tlabel = Utils.replace(label,\"\\\\\", \"\\\\\\\\\");\n\t\tlabel = Utils.replace(label,\"\\\"\", \"\\\\\\\"\");\n\t\tlabel = Utils.replace(label,\"\\n\", \"\\\\\\\\n\");\n\t\tlabel = Utils.replace(label,\"\\r\", \"\");\n\t\tif ( label.equals(Label.EPSILON_STR) ) {\n            label = \"e\";\n        }\n\t\tState target = edge.target;\n\t\tif ( !edge.isSemanticPredicate() && target instanceof DFAState ) {\n\t\t\t// look for gated predicates; don't add gated to simple sempred edges\n\t\t\tSemanticContext preds =\n\t\t\t\t((DFAState)target).getGatedPredicatesInNFAConfigurations();\n\t\t\tif ( preds!=null ) {\n\t\t\t\tString predsStr;\n\t\t\t\tpredsStr = \"&&{\"+\n\t\t\t\t\tpreds.genExpr(grammar.generator,\n\t\t\t\t\t\t\t\t  grammar.generator.getTemplates(), null).render()\n\t\t\t\t\t+\"}?\";\n\t\t\t\tlabel += predsStr;\n\t\t\t}\n\t\t}\n        return label;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleType#InstanceofExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NullLiteral#MethodInvocation#SimpleName#MethodInvocation#StringLiteral#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Fix edge strings so they print out in DOT properly; generate any gated predicates on edge too.", "call_func_name": ["org.antlr.analysis.Label.toString", "org.antlr.misc.Utils.replace", "java.lang.String.equals", "org.antlr.analysis.Transition.isSemanticPredicate", "org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.antlr.codegen.CodeGenerator.getTemplates", "org.antlr.analysis.SemanticContext.genExpr", "org.stringtemplate.v4.ST.render", "java.lang.StringBuilder.toString"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["java.lang.String", "java.lang.String", "java.lang.String"], ["java.lang.Object"], [""], [""], [""], ["java.lang.String"], [""], ["org.antlr.codegen.CodeGenerator", "org.stringtemplate.v4.STGroup", "org.antlr.analysis.DFA"], [""], [""]], "passed_comments": [{"org.antlr.misc.Utils.replace": "Given a source string, src, a string to replace, replacee, and a string to replace with, replacer, return a new string w/ the replacing done. You can use replacer==null to remove replacee from the string. This should be faster than Java's String.replaceAll as that one uses regex (I only want to play with strings anyway)."}, {"org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations": "For gated productions, we need an OR'd list of all predicates for the target of an edge so we can gate the edge based upon the predicates associated with taking that path (if any). For syntactic predicates, we only want to generate predicate evaluations as it transitions to an accept state; waste to do it earlier.  So, only add gated preds derived from manually- specified syntactic predicates if this is an accept state. Also, since configurations w/o gated predicates are like true gated predicates, finding a configuration whose alt has no gated predicate implies we should evaluate the predicate to true. This means the whole edge has to be ungated. Consider: X : ('a' | {p}?=&gt; 'a') | 'a' 'b' ; Here, you 'a' gets you from s0 to s1 but you can't test p because plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't test p.  Even on the edge going to accept state for alt 1 of X, you can't test p.  You can get to the same place with and w/o the context. Therefore, it is never ok to test p in this situation.  TODO: cache this as it's called a lot; or at least set bit if &gt;1 present in state"}, {"org.antlr.analysis.SemanticContext.genExpr": "Generate an expression that will evaluate the semantic context, given a set of output templates."}]}, {"index": "633", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.trackTokenReferenceInAlt", "methodParameterType": "GrammarAST#int#", "methodParameterName": "refAST#outerAltNum#", "methodBody": "public void trackTokenReferenceInAlt(GrammarAST refAST, int outerAltNum) {\n\t\tList<GrammarAST> refs = altToTokenRefMap[outerAltNum].get(refAST.getText());\n\t\tif ( refs==null ) {\n\t\t\trefs = new ArrayList<GrammarAST>();\n\t\t\taltToTokenRefMap[outerAltNum].put(refAST.getText(), refs);\n\t\t}\n\t\trefs.add(refAST);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Track a token ID or literal like '+' and \"void\" as having been referenced somewhere within the alts (not rewrite sections) of a rule. This differs from Grammar.altReferencesTokenID(), which tracks all token IDs to check for token IDs without corresponding lexer rules.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.util.Map.get", "java.util.ArrayList.<init>", "java.util.Map.put", "java.util.List.add"], "call_func_parameter": [[""], ["java.lang.Object"], [""], ["java.lang.Object", "java.lang.Object"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "634", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getAllTokenRefsInAltsWithRewrites", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<String> getAllTokenRefsInAltsWithRewrites() {\n\t\tString output = (String)grammar.getOption(\"output\");\n\t\tSet<String> tokens = new HashSet<String>();\n\t\tif ( output==null || !output.equals(\"AST\") ) {\n\t\t\t// return nothing if not generating trees; i.e., don't do for templates\n\t\t\treturn tokens;\n\t\t}\n\t\t//System.out.println(\"blk \"+tree.findFirstType(ANTLRParser.BLOCK).toStringTree());\n\t\tfor (int i = 1; i <= numberOfAlts; i++) {\n\t\t\tif ( hasRewrite(i) ) {\n\t\t\t\tMap<String, List<GrammarAST>> m = altToTokenRefMap[i];\n\t\t\t\tfor (String tokenName : m.keySet()) {\n\t\t\t\t\t// convert token name like ID to ID, \"void\" to 31\n\t\t\t\t\tint ttype = grammar.getTokenType(tokenName);\n\t\t\t\t\tString label = grammar.generator.getTokenTypeAsTargetLabel(ttype);\n\t\t\t\t\ttokens.add(label);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn tokens;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For use with rewrite rules, we must track all tokens matched on the left-hand-side; so we need Lists.  This is a unique list of all token types for which the rule needs a list of tokens.  This is called from the rule template not directly by the code generator.", "call_func_name": ["org.antlr.tool.Grammar.getOption", "java.util.HashSet.<init>", "java.lang.String.equals", "org.antlr.tool.Rule.hasRewrite", "java.util.Map.keySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getTokenType", "org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel", "java.util.Set.add"], "call_func_parameter": [["java.lang.String"], [""], ["java.lang.Object"], ["int"], [""], [""], [""], [""], ["java.lang.String"], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel": "Get a meaningful name for a token type useful during code generation. Literals without associated names are converted to the string equivalent of their integer values. Used to generate x==ID and x==34 type comparisons etc...  Essentially we are looking for the most obvious way to refer to a token type in the generated code.  If in the lexer, return the char literal translated to the target language.  For example, ttype=10 will yield '\\n' from the getTokenDisplayName method.  That must be converted to the target languages literals.  For most C-derived languages no translation is needed."}]}, {"index": "635", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getAllRuleRefsInAltsWithRewrites", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Set<String> getAllRuleRefsInAltsWithRewrites() {\n\t\tSet<String> rules = new HashSet<String>();\n\t\tfor (int i = 1; i <= numberOfAlts; i++) {\n\t\t\tif ( hasRewrite(i) ) {\n\t\t\t\tMap<String, ?> m = altToRuleRefMap[i];\n\t\t\t\trules.addAll(m.keySet());\n\t\t\t}\n\t\t}\n\t\treturn rules;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For use with rewrite rules, we must track all rule AST results on the left-hand-side; so we need Lists.  This is a unique list of all rule results for which the rule needs a list of results.", "call_func_name": ["java.util.HashSet.<init>", "org.antlr.tool.Rule.hasRewrite", "java.util.Map.keySet", "java.util.Set.addAll"], "call_func_parameter": [[""], ["int"], [""], ["java.util.Collection"]], "passed_comments": "/"}, {"index": "636", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getAttributeScope", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "public AttributeScope getAttributeScope(String name) {\n\t\tAttributeScope scope = getLocalAttributeScope(name);\n\t\tif ( scope!=null ) {\n\t\t\treturn scope;\n\t\t}\n\t\tif ( ruleScope!=null && ruleScope.getAttribute(name)!=null ) {\n\t\t\tscope = ruleScope;\n\t\t}\n\t\treturn scope;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return the scope containing name", "call_func_name": ["org.antlr.tool.Rule.getLocalAttributeScope", "org.antlr.tool.AttributeScope.getAttribute"], "call_func_parameter": [["java.lang.String"], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.Rule.getLocalAttributeScope": "Get the arg, return value, or predefined property for this rule"}]}, {"index": "637", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getLocalAttributeScope", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "public AttributeScope getLocalAttributeScope(String name) {\n\t\tAttributeScope scope = null;\n\t\tif ( returnScope!=null && returnScope.getAttribute(name)!=null ) {\n\t\t\tscope = returnScope;\n\t\t}\n\t\telse if ( parameterScope!=null && parameterScope.getAttribute(name)!=null ) {\n\t\t\tscope = parameterScope;\n\t\t}\n\t\telse {\n\t\t\tAttributeScope rulePropertiesScope =\n\t\t\t\tRuleLabelScope.grammarTypeToRulePropertiesScope[grammar.type];\n\t\t\tif ( rulePropertiesScope.getAttribute(name)!=null ) {\n\t\t\t\tscope = rulePropertiesScope;\n\t\t\t}\n\t\t}\n\t\treturn scope;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the arg, return value, or predefined property for this rule", "call_func_name": ["org.antlr.tool.AttributeScope.getAttribute"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "638", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getElementLabel", "methodParameterType": "String#int#CodeGenerator#", "methodParameterName": "refdSymbol#outerAltNum#generator#", "methodBody": "public String getElementLabel(String refdSymbol,\n\t\t\t\t\t\t\t\t  int outerAltNum,\n\t\t\t\t\t\t\t\t  CodeGenerator generator)\n\t{\n\t\tGrammarAST uniqueRefAST;\n\t\tif ( grammar.type != Grammar.LEXER &&\n\t\t\t Character.isUpperCase(refdSymbol.charAt(0)) )\n\t\t{\n\t\t\t// symbol is a token\n\t\t\tList<GrammarAST> tokenRefs = getTokenRefsInAlt(refdSymbol, outerAltNum);\n\t\t\tuniqueRefAST = tokenRefs.get(0);\n\t\t}\n\t\telse {\n\t\t\t// symbol is a rule\n\t\t\tList<GrammarAST> ruleRefs = getRuleRefsInAlt(refdSymbol, outerAltNum);\n\t\t\tuniqueRefAST = ruleRefs.get(0);\n\t\t}\n\t\tif ( uniqueRefAST.code==null ) {\n\t\t\t// no code?  must not have gen'd yet; forward ref\n\t\t\treturn null;\n\t\t}\n\t\tString labelName;\n\t\tString existingLabelName =\n\t\t\t(String)uniqueRefAST.code.getAttribute(\"label\");\n\t\t// reuse any label or list label if it exists\n\t\tif ( existingLabelName!=null ) {\n\t\t\tlabelName = existingLabelName;\n\t\t}\n\t\telse {\n\t\t\t// else create new label\n\t\t\tlabelName = generator.createUniqueLabel(refdSymbol);\n\t\t\tCommonToken label = new CommonToken(ANTLRParser.ID, labelName);\n\t\t\tif ( grammar.type != Grammar.LEXER &&\n\t\t\t\t Character.isUpperCase(refdSymbol.charAt(0)) )\n\t\t\t{\n\t\t\t\tgrammar.defineTokenRefLabel(name, label, uniqueRefAST);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tgrammar.defineRuleRefLabel(name, label, uniqueRefAST);\n\t\t\t}\n\t\t\tuniqueRefAST.code.add(\"label\", labelName);\n\t\t}\n\t\treturn labelName;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For references to tokens rather than by label such as $ID, we need to get the existing label for the ID ref or create a new one.", "call_func_name": ["java.lang.String.charAt", "java.lang.Character.isUpperCase", "org.antlr.tool.Rule.getTokenRefsInAlt", "java.util.List.get", "org.antlr.tool.Rule.getRuleRefsInAlt", "org.stringtemplate.v4.ST.getAttribute", "org.antlr.codegen.CodeGenerator.createUniqueLabel", "org.antlr.runtime.CommonToken.<init>", "org.antlr.tool.Grammar.defineTokenRefLabel", "org.antlr.tool.Grammar.defineRuleRefLabel", "org.stringtemplate.v4.ST.add"], "call_func_parameter": [["int"], ["char"], ["java.lang.String", "int"], ["int"], ["java.lang.String", "int"], ["java.lang.String"], ["java.lang.String"], ["int", "java.lang.String"], ["java.lang.String", "org.antlr.runtime.Token", "org.antlr.tool.GrammarAST"], ["java.lang.String", "org.antlr.runtime.Token", "org.antlr.tool.GrammarAST"], ["java.lang.String", "java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.createUniqueLabel": "Create a label to track a token / rule reference's result. Technically, this is a place where I break model-view separation as I am creating a variable name that could be invalid in a target language, however, label ::= &lt;ID&gt;&lt;INT&gt; is probably ok in all languages we care about."}]}, {"index": "639", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.getHasMultipleReturnValues", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public boolean getHasMultipleReturnValues() {\n\t\treturn\n\t\t\treferencedPredefinedRuleAttributes || grammar.buildAST() ||\n\t\t\tgrammar.buildTemplate() ||\n\t\t\t(returnScope!=null && returnScope.attributes.size()>1);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If a rule has no user-defined return values and nobody references it's start/stop (predefined attributes), then there is no need to define a struct; otherwise for now we assume a struct.  A rule also has multiple return values if you are building trees or templates.", "call_func_name": ["org.antlr.tool.Grammar.buildAST", "org.antlr.tool.Grammar.buildTemplate", "java.util.LinkedHashMap.size"], "call_func_parameter": [[""], [""], [""]], "passed_comments": "/"}, {"index": "640", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.defineNamedAction", "methodParameterType": "GrammarAST#GrammarAST#GrammarAST#", "methodParameterName": "ampersandAST#nameAST#actionAST#", "methodBody": "public void defineNamedAction(GrammarAST ampersandAST,\n\t\t\t\t\t\t\t\t  GrammarAST nameAST,\n\t\t\t\t\t\t\t\t  GrammarAST actionAST)\n\t{\n\t\t//System.out.println(\"rule @\"+nameAST.getText()+\"{\"+actionAST.getText()+\"}\");\n\t\tString actionName = nameAST.getText();\n\t\tGrammarAST a = (GrammarAST)actions.get(actionName);\n\t\tif ( a!=null ) {\n\t\t\tErrorManager.grammarError(\n\t\t\t\tErrorManager.MSG_ACTION_REDEFINITION,grammar,\n\t\t\t\tnameAST.getToken(),nameAST.getText());\n\t\t}\n\t\telse {\n\t\t\tactions.put(actionName,actionAST);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Given @scope::name {action} define it for this grammar.  Later, the code generator will ask for the actions table.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.util.Map.get", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.ErrorManager.grammarError", "java.util.Map.put"], "call_func_parameter": [[""], ["java.lang.Object"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "641", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.setOption", "methodParameterType": "String#Object#Token#", "methodParameterName": "key#value#optionsStartToken#", "methodBody": "public String setOption(String key, Object value, Token optionsStartToken) {\n\t\tif ( !legalOptions.contains(key) ) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_ILLEGAL_OPTION,\n\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t  optionsStartToken,\n\t\t\t\t\t\t\t\t\t  key);\n\t\t\treturn null;\n\t\t}\n\t\tif ( options==null ) {\n\t\t\toptions = new HashMap<String, Object>();\n\t\t}\n        if ( key.equals(\"memoize\") && value.toString().equals(\"true\") ) {\n\t\t\tgrammar.composite.getRootGrammar().atLeastOneRuleMemoizes = true;\n        }\n        if ( key.equals(\"backtrack\") && value.toString().equals(\"true\") ) {\n            grammar.composite.getRootGrammar().atLeastOneBacktrackOption = true;\n        }\n\t\tif ( key.equals(\"k\") ) {\n\t\t\tgrammar.numberOfManualLookaheadOptions++;\n\t\t}\n\t\t options.put(key, value);\n\t\treturn key;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#FieldAccess#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#FieldAccess#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(PostfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Save the option key/value pair and process it; return the key or null if invalid option.", "call_func_name": ["java.util.Set.contains", "org.antlr.tool.ErrorManager.grammarError", "java.util.HashMap.<init>", "java.lang.String.equals", "java.lang.Object.toString", "org.antlr.tool.CompositeGrammar.getRootGrammar", "java.util.Map.put"], "call_func_parameter": [["java.lang.Object"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], [""], ["java.lang.Object"], [""], [""], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "642", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Rule.java", "methodName": "org.antlr.tool.Rule.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic String toString() { // used for testing\n\t\treturn \"[\"+grammar.name+\".\"+name+\",index=\"+index+\",line=\"+tree.getToken().getLine()+\"]\";\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#StringLiteral#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Used during grammar imports to see if sets of rules intersect... public int hashCode() { return name.hashCode(); }", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.tool.GrammarAST.getToken", "org.antlr.runtime.Token.getLine", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], [""], [""], [""]], "passed_comments": [{"org.antlr.runtime.Token.getLine": "The line number on which this token was matched; line=1..n"}]}, {"index": "643", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Attribute.java", "methodName": "org.antlr.tool.Attribute.extractAttribute", "methodParameterType": "String#", "methodParameterName": "decl#", "methodBody": "protected void extractAttribute(String decl) {\n\t\tif ( decl==null ) {\n\t\t\treturn;\n\t\t}\n\t\tboolean inID = false;\n\t\tint start = -1;\n\t\tint rightEdgeOfDeclarator = decl.length()-1;\n\t\tint equalsIndex = decl.indexOf('=');\n\t\tif ( equalsIndex>0 ) {\n\t\t\t// everything after the '=' is the init value\n\t\t\tthis.initValue = decl.substring(equalsIndex+1,decl.length());\n\t\t\trightEdgeOfDeclarator = equalsIndex-1;\n\t\t}\n\t\t// walk backwards looking for start of an ID\n\t\tfor (int i=rightEdgeOfDeclarator; i>=0; i--) {\n\t\t\t// if we haven't found the end yet, keep going\n\t\t\tif ( !inID && Character.isLetterOrDigit(decl.charAt(i)) ) {\n\t\t\t    inID = true;\n\t\t\t}\n\t\t\telse if ( inID &&\n\t\t\t\t      !(Character.isLetterOrDigit(decl.charAt(i))||\n\t\t\t\t       decl.charAt(i)=='_') ) {\n\t\t\t\tstart = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( start<0 && inID ) {\n\t\t\tstart = 0;\n\t\t}\n\t\tif ( start<0 ) {\n\t\t\tErrorManager.error(ErrorManager.MSG_CANNOT_FIND_ATTRIBUTE_NAME_IN_DECL,decl);\n\t\t}\n\t\t// walk forwards looking for end of an ID\n\t\tint stop=-1;\n\t\tfor (int i=start; i<=rightEdgeOfDeclarator; i++) {\n\t\t\t// if we haven't found the end yet, keep going\n\t\t\tif ( !(Character.isLetterOrDigit(decl.charAt(i))||\n\t\t\t\tdecl.charAt(i)=='_') )\n\t\t\t{\n\t\t\t\tstop = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( i==rightEdgeOfDeclarator ) {\n\t\t\t\tstop = i+1;\n\t\t\t}\n\t\t}\n\n\t\t// the name is the last ID\n\t\tthis.name = decl.substring(start,stop);\n\n\t\t// the type is the decl minus the ID (could be empty)\n\t\tthis.type = decl.substring(0,start);\n\t\tif ( stop<=rightEdgeOfDeclarator ) {\n\t\t\tthis.type += decl.substring(stop,rightEdgeOfDeclarator+1);\n\t\t}\n\t\tthis.type = type.trim();\n\t\tif ( this.type.length()==0 ) {\n\t\t\tthis.type = null;\n\t\t}\n\n\t\tthis.decl = decl;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#PrefixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NumberLiteral#InfixExpression#SimpleName#PostfixExpression#SimpleName#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#PrefixExpression#InfixExpression#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#BreakStatement#Block#IfStatement#IfStatement#Block#ForStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#InfixExpression#SimpleName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#PrefixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#PrefixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#BreakStatement#Block#IfStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#NumberLiteral#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#InfixExpression#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ThisExpression#SimpleName#FieldAccess#NullLiteral#Assignment#ExpressionStatement#Block#IfStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)PrefixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(BreakStatement)BreakStatement)Block)IfStatement)IfStatement)Block)ForStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(PrefixExpression(ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)PrefixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(BreakStatement)BreakStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(NullLiteral)NullLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "For decls like \"String foo\" or \"char", "call_func_name": ["java.lang.String.length", "java.lang.String.indexOf", "java.lang.String.substring", "java.lang.String.charAt", "java.lang.Character.isLetterOrDigit", "org.antlr.tool.ErrorManager.error", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.lang.String.trim"], "call_func_parameter": [[""], ["int"], ["int", "int"], ["int"], ["char"], ["int", "java.lang.Object"], [""], ["java.lang.String"], [""], [""]], "passed_comments": "/"}, {"index": "644", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.setLocale", "methodParameterType": "Locale#", "methodParameterName": "locale#", "methodBody": "public static void setLocale(Locale locale) {\n\t\tErrorManager.locale = locale;\n\t\tString language = locale.getLanguage();\n\t\tString fileName = \"org/antlr/tool/templates/messages/languages/\"+language+\".stg\";\n\t\ttry {\n\t\t\tmessages = new STGroupFile(fileName);\n\t\t}\n\t\tcatch (IllegalArgumentException iae) {\n\t\t\tif ( language.equals(Locale.US.getLanguage()) ) {\n\t\t\t\trawError(\"ANTLR installation corrupted; cannot find English messages file \"+fileName);\n\t\t\t\tpanic();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetLocale(Locale.US); // recurse on this rule, trying the US locale\n\t\t\t}\n\t\t}\n\n\t\tmessages.setListener(blankSTListener);\n\t\tboolean messagesOK = verifyMessages();\n\t\tif ( !messagesOK && language.equals(Locale.US.getLanguage()) ) {\n\t\t\trawError(\"ANTLR installation corrupted; English messages file \"+language+\".stg incomplete\");\n\t\t\tpanic();\n\t\t}\n\t\telse if ( !messagesOK ) {\n\t\t\tsetLocale(Locale.US); // try US to see if that will work\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#CatchClause#TryStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#InfixExpression#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#PrefixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)CatchClause)TryStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "We really only need a single locale for entire running ANTLR code in a single VM.  Only pay attention to the language, not the country so that French Canadians and French Frenchies all get the same template file, fr.stg.  Just easier this way.", "call_func_name": ["java.util.Locale.getLanguage", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.stringtemplate.v4.STGroupFile.<init>", "java.lang.String.equals", "org.antlr.tool.ErrorManager.rawError", "org.antlr.tool.ErrorManager.panic", "org.antlr.tool.ErrorManager.setLocale", "org.stringtemplate.v4.STGroup.setListener", "org.antlr.tool.ErrorManager.verifyMessages"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.Object"], ["java.lang.String"], [""], ["java.util.Locale"], ["org.stringtemplate.v4.STErrorListener"], [""]], "passed_comments": [{"org.antlr.tool.ErrorManager.rawError": "If there are errors during ErrorManager init, we have no choice but to go to System.err."}, {"org.antlr.tool.ErrorManager.panic": "I"}, {"org.antlr.tool.ErrorManager.setLocale": "We really only need a single locale for entire running ANTLR code in a single VM.  Only pay attention to the language, not the country so that French Canadians and French Frenchies all get the same template file, fr.stg.  Just easier this way."}, {"org.antlr.tool.ErrorManager.verifyMessages": "Use reflection to find list of MSG_ fields and then verify a template exists for each one from the locale's group."}]}, {"index": "645", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.setFormat", "methodParameterType": "String#", "methodParameterName": "formatName#", "methodBody": "public static void setFormat(String formatName) {\n\t\tErrorManager.formatName = formatName;\n\t\tString fileName = \"org/antlr/tool/templates/messages/formats/\"+formatName+\".stg\";\n\t\tformat = new STGroupFile(fileName);\n\t\tformat.setListener(initSTListener);\n\t\tif ( !format.isDefined(\"message\") ) { // pick random msg to load\n\t\t\tif ( formatName.equals(\"antlr\") ) {\n\t\t\t\trawError(\"no such message format file \"+fileName+\" retrying with default ANTLR format\");\n\t\t\t\tsetFormat(\"antlr\"); // recurse on this rule, trying the default message format\n\t\t\t\treturn;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetFormat(\"antlr\"); // recurse on this rule, trying the default message format\n\t\t\t}\n\t\t}\n\n\t\tformat.setListener(blankSTListener);\n\t\tboolean formatOK = verifyFormat();\n\t\tif ( !formatOK && formatName.equals(\"antlr\") ) {\n\t\t\trawError(\"ANTLR installation corrupted; ANTLR messages format file \"+formatName+\".stg incomplete\");\n\t\t\tpanic();\n\t\t}\n\t\telse if ( !formatOK ) {\n\t\t\tsetFormat(\"antlr\"); // recurse on this rule, trying the default message format\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#ReturnStatement#Block#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#PrefixExpression#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(SimpleName)SimpleName)PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "The format gets reset either from the Tool if the user supplied a command line option to that effect Otherwise we just use the default \"antlr\".", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.stringtemplate.v4.STGroupFile.<init>", "org.stringtemplate.v4.STGroup.setListener", "org.stringtemplate.v4.STGroup.isDefined", "java.lang.String.equals", "org.antlr.tool.ErrorManager.rawError", "org.antlr.tool.ErrorManager.setFormat", "org.antlr.tool.ErrorManager.verifyFormat", "org.antlr.tool.ErrorManager.panic"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["java.lang.String"], ["org.stringtemplate.v4.STErrorListener"], ["java.lang.String"], ["java.lang.Object"], ["java.lang.String"], ["java.lang.String"], [""], [""]], "passed_comments": [{"org.antlr.tool.ErrorManager.rawError": "If there are errors during ErrorManager init, we have no choice but to go to System.err."}, {"org.antlr.tool.ErrorManager.setFormat": "The format gets reset either from the Tool if the user supplied a command line option to that effect Otherwise we just use the default \"antlr\"."}, {"org.antlr.tool.ErrorManager.verifyFormat": "Verify the message format template group"}, {"org.antlr.tool.ErrorManager.panic": "I"}]}, {"index": "646", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.setErrorListener", "methodParameterType": "ANTLRErrorListener#", "methodParameterName": "listener#", "methodBody": "public static void setErrorListener(ANTLRErrorListener listener) {\n\t\tthreadToListenerMap.put(Thread.currentThread(), listener);\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "In general, you'll want all errors to go to a single spot. However, in a GUI, you might have two frames up with two different grammars.  Two threads might launch to process the grammars--you would want errors to go to different objects depending on the thread.  I store a single listener per thread.", "call_func_name": ["java.lang.Thread.currentThread", "java.util.Map.put"], "call_func_parameter": [[""], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "647", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.getMessage", "methodParameterType": "int#", "methodParameterName": "msgID#", "methodBody": "public static ST getMessage(int msgID) {\n        String msgName = idToMessageTemplateName[msgID];\n\t\treturn messages.getInstanceOf(msgName);\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a message ID, return a ST that somebody can fill with data.  We need to convert the int ID to the name of a template in the messages ST group.", "call_func_name": ["org.stringtemplate.v4.STGroup.getInstanceOf"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "648", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.getLocationFormat", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public static ST getLocationFormat() {\n\t\treturn format.getInstanceOf(\"location\");\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a ST that refers to the current format used for emitting messages.", "call_func_name": ["org.stringtemplate.v4.STGroup.getInstanceOf"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "649", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.getLastNonErrorManagerCodeLocation", "methodParameterType": "Throwable#", "methodParameterName": "e#", "methodBody": "private static StackTraceElement getLastNonErrorManagerCodeLocation(Throwable e) {\n\t\tStackTraceElement[] stack = e.getStackTrace();\n\t\tint i = 0;\n\t\tfor (; i < stack.length; i++) {\n\t\t\tStackTraceElement t = stack[i];\n\t\t\tif ( t.toString().indexOf(\"ErrorManager\")<0 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tStackTraceElement location = stack[i];\n\t\treturn location;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#NumberLiteral#InfixExpression#BreakStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(BreakStatement)BreakStatement)Block)IfStatement)Block)ForStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return first non ErrorManager code location for generating messages", "call_func_name": ["java.lang.Throwable.getStackTrace", "java.lang.StackTraceElement.toString", "java.lang.String.indexOf"], "call_func_parameter": [[""], [""], ["java.lang.String"]], "passed_comments": "/"}, {"index": "650", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.verifyMessages", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected static boolean verifyMessages() {\n\t\tboolean ok = true;\n\t\tField[] fields = ErrorManager.class.getFields();\n\t\tfor (int i = 0; i < fields.length; i++) {\n\t\t\tField f = fields[i];\n\t\t\tString fieldName = f.getName();\n\t\t\tString templateName =\n\t\t\t\tfieldName.substring(\"MSG_\".length(),fieldName.length());\n\t\t\tif ( fieldName.startsWith(\"MSG_\") ) {\n\t\t\t\tif ( !messages.isDefined(templateName) ) {\n\t\t\t\t\tSystem.err.println(\"Message \"+templateName+\" in locale \"+\n\t\t\t\t\t\t\t\t\t   locale+\" not found\");\n\t\t\t\t\tok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// check for special templates\n\t\tif (!messages.isDefined(\"warning\")) {\n\t\t\tSystem.err.println(\"Message template 'warning' not found in locale \"+ locale);\n\t\t\tok = false;\n\t\t}\n\t\tif (!messages.isDefined(\"error\")) {\n\t\t\tSystem.err.println(\"Message template 'error' not found in locale \"+ locale);\n\t\t\tok = false;\n\t\t}\n\t\treturn ok;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)ForStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Use reflection to find list of MSG_ fields and then verify a template exists for each one from the locale's group.", "call_func_name": ["java.lang.Class.getFields", "java.lang.reflect.Field.getName", "java.lang.String.length", "java.lang.String.substring", "java.lang.String.startsWith", "org.stringtemplate.v4.STGroup.isDefined", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println"], "call_func_parameter": [[""], [""], [""], ["int", "int"], ["java.lang.String"], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.Object"], [""], ["java.lang.String"]], "passed_comments": "/"}, {"index": "651", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.verifyFormat", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected static boolean verifyFormat() {\n\t\tboolean ok = true;\n\t\tif (!format.isDefined(\"location\")) {\n\t\t\tSystem.err.println(\"Format template 'location' not found in \" + formatName);\n\t\t\tok = false;\n\t\t}\n\t\tif (!format.isDefined(\"message\")) {\n\t\t\tSystem.err.println(\"Format template 'message' not found in \" + formatName);\n\t\t\tok = false;\n\t\t}\n\t\tif (!format.isDefined(\"report\")) {\n\t\t\tSystem.err.println(\"Format template 'report' not found in \" + formatName);\n\t\t\tok = false;\n\t\t}\n\t\treturn ok;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Verify the message format template group", "call_func_name": ["org.stringtemplate.v4.STGroup.isDefined", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println"], "call_func_parameter": [["java.lang.String"], [""], ["java.lang.String"], [""], ["java.lang.String"]], "passed_comments": "/"}, {"index": "652", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.rawError", "methodParameterType": "String#", "methodParameterName": "msg#", "methodBody": "static void rawError(String msg) {\n\t\tSystem.err.println(msg);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If there are errors during ErrorManager init, we have no choice but to go to System.err.", "call_func_name": ["java.io.PrintStream.println"], "call_func_parameter": [["java.lang.String"]], "passed_comments": "/"}, {"index": "653", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/ErrorManager.java", "methodName": "org.antlr.tool.ErrorManager.panic", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public static void panic() {\n\t\tTool tool = threadToToolMap.get(Thread.currentThread());\n\t\tif ( tool==null ) {\n\t\t\t// no tool registered, exit\n\t\t\tthrow new Error(\"ANTLR ErrorManager panic\");\n\t\t}\n\t\telse {\n\t\t\ttool.panic();\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "I", "call_func_name": ["java.lang.Thread.currentThread", "java.util.Map.get", "java.lang.Error.<init>", "org.antlr.Tool.panic"], "call_func_parameter": [[""], ["java.lang.Object"], ["java.lang.String"], [""]], "passed_comments": [{"org.antlr.Tool.panic": "If the tool needs to panic/exit, how do we do that?"}]}, {"index": "654", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarReport.java", "methodName": "org.antlr.tool.GrammarReport.toNotifyString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String toNotifyString() {\n\t\tStringBuilder buf = new StringBuilder();\n\t\tReportData data = getReportData(grammar);\n\t\tField[] fields = ReportData.class.getDeclaredFields();\n\t\tint i = 0;\n\t\tfor (Field f : fields) {\n\t\t\ttry {\n\t\t\t\tObject v = f.get(data);\n\t\t\t\tString s = v!=null ? v.toString() : \"null\";\n\t\t\t\tif (i>0) buf.append('\\t');\n\t\t\t\tbuf.append(s);\n\t\t\t}\n\t\t\tcatch (Exception e) {\n\t\t\t\tErrorManager.internalError(\"Can't get data\", e);\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#TypeLiteral#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#StringLiteral#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(TypeLiteral(SimpleType(SimpleName)SimpleName)SimpleType)TypeLiteral(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(TryStatement(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)EnhancedForStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a single-line stats report about this grammar suitable to send to the notify page at antlr.org", "call_func_name": ["java.lang.StringBuilder.<init>", "org.antlr.tool.GrammarReport.getReportData", "java.lang.Class.getDeclaredFields", "java.lang.reflect.Field.get", "java.lang.Object.toString", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.tool.ErrorManager.internalError", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["org.antlr.tool.Grammar"], [""], ["java.lang.Object"], [""], ["char"], ["java.lang.String"], ["java.lang.Object", "java.lang.Throwable"], [""]], "passed_comments": "/"}, {"index": "655", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarReport.java", "methodName": "org.antlr.tool.GrammarReport.toString", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n\tpublic String toString() {\n\t\treturn toString(toNotifyString());\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a stats line suitable for sending to the antlr.org site, return a human-readable version.  Return null if there is a problem with the data.", "call_func_name": ["org.antlr.tool.GrammarReport.toNotifyString", "org.antlr.tool.GrammarReport.toString"], "call_func_parameter": [[""], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.GrammarReport.toNotifyString": "Create a single-line stats report about this grammar suitable to send to the notify page at antlr.org"}]}, {"index": "656", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/AssignTokenTypesBehavior.java", "methodName": "org.antlr.tool.AssignTokenTypesBehavior.trackString", "methodParameterType": "GrammarAST#", "methodParameterName": "t#", "methodBody": "@Override\n\tprotected void trackString(GrammarAST t) {\n\t\t// if lexer, don't allow aliasing in tokens section\n\t\tif ( currentRuleName==null && grammar.type==Grammar.LEXER ) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_CANNOT_ALIAS_TOKENS_IN_LEXER,\n\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t  t.token,\n\t\t\t\t\t\t\t\t\t  t.getText());\n\t\t\treturn;\n\t\t}\n\t\t// in a plain parser grammar rule, cannot reference literals\n\t\t// (unless defined previously via tokenVocab option)\n\t\t// don't warn until we hit root grammar as may be defined there.\n\t\tif ( grammar.getGrammarIsRoot() &&\n\t\t\t grammar.type==Grammar.PARSER &&\n\t\t\t grammar.getTokenType(t.getText())== Label.INVALID )\n\t\t{\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_LITERAL_NOT_ASSOCIATED_WITH_LEXER_RULE,\n\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t  t.token,\n\t\t\t\t\t\t\t\t\t  t.getText());\n\t\t}\n\t\t// Don't record literals for lexers, they are things to match not tokens\n\t\tif ( grammar.type==Grammar.LEXER ) {\n\t\t\treturn;\n\t\t}\n\t\t// otherwise add literal to token types if referenced from parser rule\n\t\t// or in the tokens{} section\n\t\tif ( (currentRuleName==null ||\n\t\t\t  Character.isLowerCase(currentRuleName.charAt(0))) &&\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tgrammar.getTokenType(t.getText())==Label.INVALID )\n\t\t{\n\t\t\tstringLiterals.put(t.getText(), UNASSIGNED_IN_PARSER_RULE);\n\t\t}\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)InfixExpression)ParenthesizedExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Track string literals (could be in tokens{} section)", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "org.antlr.tool.ErrorManager.grammarError", "org.antlr.tool.Grammar.getGrammarIsRoot", "org.antlr.tool.Grammar.getTokenType", "java.lang.String.charAt", "java.lang.Character.isLowerCase", "java.util.Map.put"], "call_func_parameter": [[""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], [""], ["java.lang.String"], ["int"], ["char"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "657", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java", "methodName": "org.antlr.tool.NameSpaceChecker.lookForReferencesToUndefinedSymbols", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected void lookForReferencesToUndefinedSymbols() {\n\t\t// for each rule ref, ask if there is a rule definition\n\t\tfor (GrammarAST refAST : grammar.ruleRefs) {\n\t\t\tToken tok = refAST.token;\n\t\t\tString ruleName = tok.getText();\n\t\t\tRule localRule = grammar.getLocallyDefinedRule(ruleName);\n\t\t\tRule rule = grammar.getRule(ruleName);\n\t\t\tif ( localRule==null && rule!=null ) { // imported rule?\n\t\t\t\tgrammar.delegatedRuleReferences.add(rule);\n\t\t\t\trule.imported = true;\n\t\t\t}\n\t\t\tif ( rule==null && grammar.getTokenType(ruleName)!=Label.EOF ) {\n\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_UNDEFINED_RULE_REF,\n\t\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t\t  tok,\n\t\t\t\t\t\t\t\t\t\t  ruleName);\n\t\t\t}\n        }\n\t\tif ( grammar.type==Grammar.COMBINED ) {\n\t\t\t// if we're a combined grammar, we know which token IDs have no\n\t\t\t// associated lexer rule.\n\t\t\tfor (Token tok : grammar.tokenIDRefs) {\n\t\t\t\tString tokenID = tok.getText();\n\t\t\t\tif ( !grammar.composite.lexerRules.contains(tokenID) &&\n\t\t\t\t\t grammar.getTokenType(tokenID)!=Label.EOF )\n\t\t\t\t{\n\t\t\t\t\tErrorManager.grammarWarning(ErrorManager.MSG_NO_TOKEN_DEFINITION,\n\t\t\t\t\t\t\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\t\t\t\t\t\t\ttok,\n\t\t\t\t\t\t\t\t\t\t\t\ttokenID);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// check scopes and scoped rule refs\n\t\tfor (GrammarAST scopeAST : grammar.scopedRuleRefs) { // ^(DOT ID atom)\n\t\t\tGrammar scopeG = grammar.composite.getGrammar(scopeAST.getText());\n\t\t\tGrammarAST refAST = (GrammarAST)scopeAST.getChild(1);\n\t\t\tString ruleName = refAST.getText();\n\t\t\tif ( scopeG==null ) {\n\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_NO_SUCH_GRAMMAR_SCOPE,\n\t\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t\t  scopeAST.getToken(),\n\t\t\t\t\t\t\t\t\t\t  scopeAST.getText(),\n\t\t\t\t\t\t\t\t\t\t  ruleName);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRule rule = grammar.getRule(scopeG.name, ruleName);\n\t\t\t\tif ( rule==null ) {\n\t\t\t\t\tErrorManager.grammarError(ErrorManager.MSG_NO_SUCH_RULE_IN_SCOPE,\n\t\t\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t\t\t  scopeAST.getToken(),\n\t\t\t\t\t\t\t\t\t\t\t  scopeAST.getText(),\n\t\t\t\t\t\t\t\t\t\t\t  ruleName);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(PrefixExpression(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)IfStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "If ref to undefined rule, give error at first occurrence. Give error if you cannot find the scope override on a rule reference. If you ref ID in a combined grammar and don't define ID as a lexer rule it is an error.", "call_func_name": ["java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.runtime.Token.getText", "org.antlr.tool.Grammar.getLocallyDefinedRule", "org.antlr.tool.Grammar.getRule", "java.util.Set.add", "org.antlr.tool.Grammar.getTokenType", "org.antlr.tool.ErrorManager.grammarError", "java.util.Set.contains", "org.antlr.tool.ErrorManager.grammarWarning", "org.antlr.tool.GrammarAST.getText", "org.antlr.tool.CompositeGrammar.getGrammar", "org.antlr.tool.GrammarAST.getChild", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.ErrorManager.grammarError", "org.antlr.tool.Grammar.getRule"], "call_func_parameter": [[""], [""], [""], [""], ["java.lang.String"], ["java.lang.String"], ["java.lang.Object"], ["java.lang.String"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.Object"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], [""], ["java.lang.String"], ["int"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"], ["java.lang.String", "java.lang.String"]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}]}, {"index": "658", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java", "methodName": "org.antlr.tool.NameSpaceChecker.checkForRuleScopeAttributeConflict", "methodParameterType": "Rule#Attribute#", "methodParameterName": "r#attribute#", "methodBody": "public void checkForRuleScopeAttributeConflict(Rule r, Attribute attribute) {\n\t\tint msgID = 0;\n\t\tObject arg2 = null;\n\t\tString attrName = attribute.name;\n\t\tif ( r.name.equals(attrName) ) {\n\t\t\tmsgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE;\n\t\t\targ2 = r.name;\n\t\t}\n\t\telse if ( (r.returnScope!=null&&r.returnScope.getAttribute(attrName)!=null) ||\n\t\t\t\t  (r.parameterScope!=null&&r.parameterScope.getAttribute(attrName)!=null) )\n\t\t{\n\t\t\tmsgID = ErrorManager.MSG_ATTRIBUTE_CONFLICTS_WITH_RULE_ARG_RETVAL;\n\t\t\targ2 = r.name;\n\t\t}\n\t\tif ( msgID!=0 ) {\n\t\t\tErrorManager.grammarError(msgID,grammar,r.tree.getToken(),attrName,arg2);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression)ParenthesizedExpression(ParenthesizedExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Check for collision of a rule-scope dynamic attribute with: arg, return value, rule name itself.  Labels are checked elsewhere.", "call_func_name": ["java.lang.String.equals", "org.antlr.tool.AttributeScope.getAttribute", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.ErrorManager.grammarError"], "call_func_parameter": [["java.lang.Object"], ["java.lang.String"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "659", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java", "methodName": "org.antlr.tool.NameSpaceChecker.checkForLabelConflict", "methodParameterType": "Rule#Token#", "methodParameterName": "r#label#", "methodBody": "protected void checkForLabelConflict(Rule r, Token label) {\n\t\tint msgID = 0;\n\t\tObject arg2 = null;\n\t\tif ( grammar.getGlobalScope(label.getText())!=null ) {\n\t\t\tmsgID = ErrorManager.MSG_SYMBOL_CONFLICTS_WITH_GLOBAL_SCOPE;\n\t\t}\n\t\telse if ( grammar.getRule(label.getText())!=null ) {\n\t\t\tmsgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE;\n\t\t}\n\t\telse if ( grammar.getTokenType(label.getText())!=Label.INVALID ) {\n\t\t\tmsgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_TOKEN;\n\t\t}\n\t\telse if ( r.ruleScope!=null && r.ruleScope.getAttribute(label.getText())!=null ) {\n\t\t\tmsgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_SCOPE_ATTRIBUTE;\n\t\t\targ2 = r.name;\n\t\t}\n\t\telse if ( (r.returnScope!=null&&r.returnScope.getAttribute(label.getText())!=null) ||\n\t\t\t\t  (r.parameterScope!=null&&r.parameterScope.getAttribute(label.getText())!=null) )\n\t\t{\n\t\t\tmsgID = ErrorManager.MSG_LABEL_CONFLICTS_WITH_RULE_ARG_RETVAL;\n\t\t\targ2 = r.name;\n\t\t}\n\t\tif ( msgID!=0 ) {\n\t\t\tErrorManager.grammarError(msgID,grammar,label,label.getText(),arg2);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#ParenthesizedExpression#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#IfStatement#IfStatement#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression)ParenthesizedExpression(ParenthesizedExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression)ParenthesizedExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)IfStatement)IfStatement)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Make sure a label doesn't conflict with another symbol. Labels must not conflict with: rules, tokens, scope names, return values, parameters, and rule-scope dynamic attributes defined in surrounding rule.", "call_func_name": ["org.antlr.runtime.Token.getText", "org.antlr.tool.Grammar.getGlobalScope", "org.antlr.tool.Grammar.getRule", "org.antlr.tool.Grammar.getTokenType", "org.antlr.tool.AttributeScope.getAttribute", "org.antlr.tool.ErrorManager.grammarError"], "call_func_parameter": [[""], ["java.lang.String"], ["java.lang.String"], ["java.lang.String"], ["java.lang.String"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}, {"org.antlr.tool.Grammar.getGlobalScope": "Get a global scope"}]}, {"index": "660", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NameSpaceChecker.java", "methodName": "org.antlr.tool.NameSpaceChecker.checkForLabelTypeMismatch", "methodParameterType": "Rule#Token#int#", "methodParameterName": "r#label#type#", "methodBody": "public boolean checkForLabelTypeMismatch(Rule r, Token label, int type) {\n\t\tGrammar.LabelElementPair prevLabelPair =\n\t\t\tr.labelNameSpace.get(label.getText());\n\t\tif ( prevLabelPair!=null ) {\n\t\t\t// label already defined; if same type, no problem\n\t\t\tif ( prevLabelPair.type != type ) {\n\t\t\t\tString typeMismatchExpr =\n\t\t\t\t\tGrammar.LabelTypeToString[type]+\"!=\"+\n\t\t\t\t\tGrammar.LabelTypeToString[prevLabelPair.type];\n\t\t\t\tErrorManager.grammarError(\n\t\t\t\t\tErrorManager.MSG_LABEL_TYPE_CONFLICT,\n\t\t\t\t\tgrammar,\n\t\t\t\t\tlabel,\n\t\t\t\t\tlabel.getText(),\n\t\t\t\t\ttypeMismatchExpr);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#ArrayAccess#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ArrayAccess#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ArrayAccess(StringLiteral)StringLiteral(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If type of previous label differs from new label's type, that's an error.", "call_func_name": ["org.antlr.runtime.Token.getText", "java.util.Map.get", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.ErrorManager.grammarError"], "call_func_parameter": [[""], ["java.lang.Object"], [""], ["java.lang.String"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}]}, {"index": "661", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.addGrammar", "methodParameterType": "Grammar#Grammar#", "methodParameterName": "delegator#delegate#", "methodBody": "public void addGrammar(Grammar delegator, Grammar delegate) {\n\t\tif ( delegator.compositeTreeNode==null ) {\n\t\t\tdelegator.compositeTreeNode = new CompositeGrammarTree(delegator);\n\t\t}\n\t\tdelegator.compositeTreeNode.addChild(new CompositeGrammarTree(delegate));\n\n\t\t/*// find delegator in tree so we can add a child to it\n\t\tCompositeGrammarTree t = delegateGrammarTreeRoot.findNode(delegator);\n\t\tt.addChild();\n\t\t*/\n\t\t// make sure new grammar shares this composite\n\t\tdelegate.composite = this;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#ThisExpression#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ThisExpression)ThisExpression)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Add delegate grammar as child of delegator", "call_func_name": ["org.antlr.tool.CompositeGrammarTree.<init>", "org.antlr.tool.CompositeGrammarTree.addChild"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["org.antlr.tool.CompositeGrammarTree"]], "passed_comments": "/"}, {"index": "662", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getDelegator", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public Grammar getDelegator(Grammar g) {\n\t\tCompositeGrammarTree me = delegateGrammarTreeRoot.findNode(g);\n\t\tif ( me==null ) {\n\t\t\treturn null; // not found\n\t\t}\n\t\tif ( me.parent!=null ) {\n\t\t\treturn me.parent.grammar;\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get parent of this grammar", "call_func_name": ["org.antlr.tool.CompositeGrammarTree.findNode"], "call_func_parameter": [["org.antlr.tool.Grammar"]], "passed_comments": "/"}, {"index": "663", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getDelegates", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public List<Grammar> getDelegates(Grammar g) {\n\t\tCompositeGrammarTree t = delegateGrammarTreeRoot.findNode(g);\n\t\tif ( t==null ) {\n\t\t\treturn null; // no delegates\n\t\t}\n\t\tList<Grammar> grammars = t.getPostOrderedGrammarList();\n\t\tgrammars.remove(grammars.size()-1); // remove g (last one)\n\t\treturn grammars;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get list of all delegates from all grammars in the delegate subtree of g. The grammars are in delegation tree preorder.  Don't include g itself in list as it is not a delegate of itself.", "call_func_name": ["org.antlr.tool.CompositeGrammarTree.findNode", "org.antlr.tool.CompositeGrammarTree.getPostOrderedGrammarList", "java.util.List.size", "java.util.List.remove"], "call_func_parameter": [["org.antlr.tool.Grammar"], [""], [""], ["int"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree.getPostOrderedGrammarList": "Return a postorder list of grammars; root is last in list"}]}, {"index": "664", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getIndirectDelegates", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public List<Grammar> getIndirectDelegates(Grammar g) {\n\t\tList<Grammar> direct = getDirectDelegates(g);\n\t\tList<Grammar> delegates = getDelegates(g);\n\t\tif ( direct!=null ) {\n\t\t\tdelegates.removeAll(direct);\n\t\t}\n\t\treturn delegates;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get delegates below direct delegates of g", "call_func_name": ["org.antlr.tool.CompositeGrammar.getDirectDelegates", "org.antlr.tool.CompositeGrammar.getDelegates", "java.util.List.removeAll"], "call_func_parameter": [["org.antlr.tool.Grammar"], ["org.antlr.tool.Grammar"], ["java.util.Collection"]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getDelegates": "Get list of all delegates from all grammars in the delegate subtree of g. The grammars are in delegation tree preorder.  Don't include g itself in list as it is not a delegate of itself."}]}, {"index": "665", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getDelegators", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public List<Grammar> getDelegators(Grammar g) {\n\t\tif ( g==delegateGrammarTreeRoot.grammar ) {\n\t\t\treturn null;\n\t\t}\n\t\tList<Grammar> grammars = new ArrayList<Grammar>();\n\t\tCompositeGrammarTree t = delegateGrammarTreeRoot.findNode(g);\n\t\t// walk backwards to root, collecting grammars\n\t\tCompositeGrammarTree p = t.parent;\n\t\twhile ( p!=null ) {\n\t\t\tgrammars.add(0, p.grammar); // add to head so in order later\n\t\t\tp = p.parent;\n\t\t}\n\t\treturn grammars;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return list of delegate grammars from root down to g. Order is root, ..., g.parent.  (g not included).", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.CompositeGrammarTree.findNode", "java.util.List.add"], "call_func_parameter": [[""], ["org.antlr.tool.Grammar"], ["int", "java.lang.Object"]], "passed_comments": "/"}, {"index": "666", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getDelegatedRules", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public Set<? extends Rule> getDelegatedRules(Grammar g) {\n\t\tif ( g!=delegateGrammarTreeRoot.grammar ) {\n\t\t\treturn null;\n\t\t}\n\t\tSet<? extends Rule> rules = getAllImportedRules(g);\n\t\tfor (Iterator<? extends Rule> it = rules.iterator(); it.hasNext();) {\n\t\t\tRule r = it.next();\n\t\t\tRule localRule = g.getLocallyDefinedRule(r.name);\n\t\t\t// if locally defined or it's not local but synpred, don't make\n\t\t\t// a delegation method\n\t\t\tif ( localRule!=null || r.isSynPred ) {\n\t\t\t\tit.remove(); // kill overridden rules\n\t\t\t}\n\t\t}\n\t\treturn rules;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get set of rules for grammar g that need to have manual delegation methods.  This is the list of rules collected from all direct/indirect delegates minus rules overridden in grammar g. This returns null except for the delegate root because it is the only one that has to have a complete grammar rule interface.  The delegates should not be instantiated directly for use as parsers (you can create them to pass to the root parser's ctor as arguments).", "call_func_name": ["org.antlr.tool.CompositeGrammar.getAllImportedRules", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getLocallyDefinedRule", "java.util.Iterator.remove"], "call_func_parameter": [["org.antlr.tool.Grammar"], [""], [""], [""], ["java.lang.String"], [""]], "passed_comments": [{"org.antlr.tool.CompositeGrammar.getAllImportedRules": "Get all rule definitions from all direct/indirect delegate grammars of g."}]}, {"index": "667", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammar.java", "methodName": "org.antlr.tool.CompositeGrammar.getAllImportedRules", "methodParameterType": "Grammar#", "methodParameterName": "g#", "methodBody": "public Set<? extends Rule> getAllImportedRules(Grammar g) {\n\t\tSet<String> ruleNames = new HashSet<String>();\n\t\tSet<Rule> rules = new HashSet<Rule>();\n\t\tCompositeGrammarTree subtreeRoot = delegateGrammarTreeRoot.findNode(g);\n\n\t\tList<Grammar> grammars = subtreeRoot.getPreOrderedGrammarList();\n\t\t// walk all grammars preorder, priority given to grammar listed first.\n\t\tfor (int i = 0; i < grammars.size(); i++) {\n\t\t\tGrammar delegate = grammars.get(i);\n\t\t\t// for each rule in delegate, add to rules if no rule with that\n\t\t\t// name as been seen.  (can't use removeAll; wrong hashcode/equals on Rule)\n\t\t\tfor (Rule r : delegate.getRules()) {\n\t\t\t\tif ( !ruleNames.contains(r.name) ) {\n\t\t\t\t\truleNames.add(r.name); // track that we've seen this\n\t\t\t\t\trules.add(r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn rules;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get all rule definitions from all direct/indirect delegate grammars of g.", "call_func_name": ["java.util.HashSet.<init>", "org.antlr.tool.CompositeGrammarTree.findNode", "org.antlr.tool.CompositeGrammarTree.getPreOrderedGrammarList", "java.util.List.size", "java.util.List.get", "org.antlr.tool.Grammar.getRules", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.util.Set.contains", "java.util.Set.add"], "call_func_parameter": [[""], ["org.antlr.tool.Grammar"], [""], [""], ["int"], [""], [""], [""], [""], ["java.lang.Object"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree.getPreOrderedGrammarList": "Return a preorder list of grammars; root is first in list"}]}, {"index": "668", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Interpreter.java", "methodName": "org.antlr.tool.Interpreter.scan", "methodParameterType": "String#DebugEventListener#List<NFAState>#", "methodParameterName": "startRule#actions#visitedStates#", "methodBody": "public void scan(String startRule,\n\t\t\t\t\t DebugEventListener actions,\n\t\t\t\t\t List<NFAState> visitedStates)\n\t\tthrows RecognitionException\n\t{\n\t\tif ( grammar.type!=Grammar.LEXER ) {\n\t\t\treturn;\n\t\t}\n\n\t\t//System.out.println(\"scan(\"+startRule+\",'\"+in.substring(in.index(),in.size()-1)+\"')\");\n\t\t// Build NFAs/DFAs from the grammar AST if NFAs haven't been built yet\n\t\tif ( grammar.getRuleStartState(startRule)==null ) {\n\t\t\tgrammar.buildNFA();\n\t\t}\n\n\t\tif ( !grammar.allDecisionDFAHaveBeenCreated() ) {\n\t\t\t// Create the DFA predictors for each decision\n\t\t\tgrammar.createLookaheadDFAs();\n\t\t}\n\n\t\t// do the parse\n\t\tStack<NFAState> ruleInvocationStack = new Stack<NFAState>();\n\t\tNFAState start = grammar.getRuleStartState(startRule);\n\t\tNFAState stop = grammar.getRuleStopState(startRule);\n\t\tparseEngine(startRule, start, stop, input, ruleInvocationStack,\n\t\t\t\t\tactions, visitedStates);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "For a given input char stream, try to match against the NFA starting at startRule.  This is a deterministic parse even though it is using an NFA because it uses DFAs at each decision point to predict which alternative will succeed.  This is exactly what the generated parser will do. This only does lexer grammars. Return the token type associated with the final rule end state.", "call_func_name": ["org.antlr.tool.Grammar.getRuleStartState", "org.antlr.tool.Grammar.buildNFA", "org.antlr.tool.Grammar.allDecisionDFAHaveBeenCreated", "org.antlr.tool.Grammar.createLookaheadDFAs", "java.util.Stack.<init>", "org.antlr.tool.Grammar.getRuleStopState", "org.antlr.tool.Interpreter.parseEngine"], "call_func_parameter": [["java.lang.String"], [""], [""], [""], [""], ["java.lang.String"], ["java.lang.String", "org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "org.antlr.runtime.IntStream", "java.util.Stack", "org.antlr.runtime.debug.DebugEventListener", "java.util.List"]], "passed_comments": [{"org.antlr.tool.Grammar.createLookaheadDFAs": "For each decision in this grammar, compute a single DFA using the NFA states associated with the decision.  The DFA construction determines whether or not the alternatives in the decision are separable using a regular lookahead language. Store the lookahead DFAs in the AST created from the user's grammar so the code generator or whoever can easily access it. This is a separate method because you might want to create a Grammar without doing the expensive analysis."}, {"org.antlr.tool.Interpreter.parseEngine": "Fill a list of all NFA states visited during the parse"}]}, {"index": "669", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Interpreter.java", "methodName": "org.antlr.tool.Interpreter.parseEngine", "methodParameterType": "String#NFAState#NFAState#IntStream#Stack<NFAState>#DebugEventListener#List<NFAState>#", "methodParameterName": "startRule#start#stop#input#ruleInvocationStack#actions#visitedStates#", "methodBody": "protected void parseEngine(String startRule,\n\t\t\t\t\t\t\t   NFAState start,\n\t\t\t\t\t\t\t   NFAState stop,\n\t\t\t\t\t\t\t   IntStream input,\n\t\t\t\t\t\t\t   Stack<NFAState> ruleInvocationStack,\n\t\t\t\t\t\t\t   DebugEventListener actions,\n\t\t\t\t\t\t\t   List<NFAState> visitedStates)\n\t\tthrows RecognitionException\n\t{\n\t\tNFAState s = start;\n\t\tif ( actions!=null ) {\n\t\t\tactions.enterRule(s.nfa.grammar.getFileName(), start.enclosingRule.name);\n\t\t}\n\t\tint t = input.LA(1);\n\t\twhile ( s!=stop ) {\n\t\t\tif ( visitedStates!=null ) {\n\t\t\t\tvisitedStates.add(s);\n\t\t\t}\n\t\t\t/*\n\t\t\tSystem.out.println(\"parse state \"+s.stateNumber+\" input=\"+\n\t\t\t\ts.nfa.grammar.getTokenDisplayName(t));\n\t\t\t\t*/\n\t\t\t// CASE 1: decision state\n\t\t\tif ( s.getDecisionNumber()>0 && s.nfa.grammar.getNumberOfAltsForDecisionNFA(s)>1 ) {\n\t\t\t\t// decision point, must predict and jump to alt\n\t\t\t\tDFA dfa = s.nfa.grammar.getLookaheadDFA(s.getDecisionNumber());\n\t\t\t\t/*\n\t\t\t\tif ( s.nfa.grammar.type!=Grammar.LEXER ) {\n\t\t\t\t\tSystem.out.println(\"decision: \"+\n\t\t\t\t\t\t\t\t   dfa.getNFADecisionStartState().getDescription()+\n\t\t\t\t\t\t\t\t   \" input=\"+s.nfa.grammar.getTokenDisplayName(t));\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tint m = input.mark();\n\t\t\t\tint predictedAlt = predict(dfa);\n\t\t\t\tif ( predictedAlt == NFA.INVALID_ALT_NUMBER ) {\n\t\t\t\t\tString description = dfa.getNFADecisionStartState().getDescription();\n\t\t\t\t\tNoViableAltException nvae =\n\t\t\t\t\t\tnew NoViableAltException(description,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  dfa.getDecisionNumber(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t  s.stateNumber,\n\t\t\t\t\t\t\t\t\t\t\t\t\t  input);\n\t\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\t\tactions.recognitionException(nvae);\n\t\t\t\t\t}\n\t\t\t\t\tinput.consume(); // recover\n\t\t\t\t\tthrow nvae;\n\t\t\t\t}\n\t\t\t\tinput.rewind(m);\n\t\t\t\tint parseAlt =\n\t\t\t\t\ts.translateDisplayAltToWalkAlt(predictedAlt);\n\t\t\t\t/*\n\t\t\t\tif ( s.nfa.grammar.type!=Grammar.LEXER ) {\n\t\t\t\t\tSystem.out.println(\"predicted alt \"+predictedAlt+\", parseAlt \"+\n\t\t\t\t\t\t\t\t\t   parseAlt);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\tNFAState alt;\n\t\t\t\tif ( parseAlt > s.nfa.grammar.getNumberOfAltsForDecisionNFA(s) ) {\n\t\t\t\t\t// implied branch of loop etc...\n\t\t\t\t\talt = s.nfa.grammar.nfa.getState( s.endOfBlockStateNumber );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\talt = s.nfa.grammar.getNFAStateForAltOfDecision(s, parseAlt);\n\t\t\t\t}\n\t\t\t\ts = (NFAState)alt.transition[0].target;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// CASE 2: finished matching a rule\n\t\t\tif ( s.isAcceptState() ) { // end of rule node\n\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\tactions.exitRule(s.nfa.grammar.getFileName(), s.enclosingRule.name);\n\t\t\t\t}\n\t\t\t\tif ( ruleInvocationStack.empty() ) {\n\t\t\t\t\t// done parsing.  Hit the start state.\n\t\t\t\t\t//System.out.println(\"stack empty in stop state for \"+s.getEnclosingRule());\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t// pop invoking state off the stack to know where to return to\n\t\t\t\tNFAState invokingState = ruleInvocationStack.pop();\n\t\t\t\tRuleClosureTransition invokingTransition =\n\t\t\t\t\t\t(RuleClosureTransition)invokingState.transition[0];\n\t\t\t\t// move to node after state that invoked this rule\n\t\t\t\ts = invokingTransition.followState;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tTransition trans = s.transition[0];\n\t\t\tLabel label = trans.label;\n\t\t\tif ( label.isSemanticPredicate() ) {\n\t\t\t\tFailedPredicateException fpe =\n\t\t\t\t\tnew FailedPredicateException(input,\n\t\t\t\t\t\t\t\t\t\t\t\t s.enclosingRule.name,\n\t\t\t\t\t\t\t\t\t\t\t\t \"can't deal with predicates yet\");\n\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\tactions.recognitionException(fpe);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// CASE 3: epsilon transition\n\t\t\tif ( label.isEpsilon() ) {\n\t\t\t\t// CASE 3a: rule invocation state\n\t\t\t\tif ( trans instanceof RuleClosureTransition ) {\n\t\t\t\t\truleInvocationStack.push(s);\n\t\t\t\t\ts = (NFAState)trans.target;\n\t\t\t\t\t//System.out.println(\"call \"+s.enclosingRule.name+\" from \"+s.nfa.grammar.getFileName());\n\t\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\t\tactions.enterRule(s.nfa.grammar.getFileName(), s.enclosingRule.name);\n\t\t\t\t\t}\n\t\t\t\t\t// could be jumping to new grammar, make sure DFA created\n\t\t\t\t\tif ( !s.nfa.grammar.allDecisionDFAHaveBeenCreated() ) {\n\t\t\t\t\t\ts.nfa.grammar.createLookaheadDFAs();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// CASE 3b: plain old epsilon transition, just move\n\t\t\t\telse {\n\t\t\t\t\ts = (NFAState)trans.target;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// CASE 4: match label on transition\n\t\t\telse if ( label.matches(t) ) {\n\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\tif ( s.nfa.grammar.type == Grammar.PARSER ||\n\t\t\t\t\t\t s.nfa.grammar.type == Grammar.COMBINED )\n\t\t\t\t\t{\n\t\t\t\t\t\tactions.consumeToken(((TokenStream)input).LT(1));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = (NFAState)s.transition[0].target;\n\t\t\t\tinput.consume();\n\t\t\t\tt = input.LA(1);\n\t\t\t}\n\n\t\t\t// CASE 5: error condition; label is inconsistent with input\n\t\t\telse {\n\t\t\t\tif ( label.isAtom() ) {\n\t\t\t\t\tMismatchedTokenException mte =\n\t\t\t\t\t\tnew MismatchedTokenException(label.getAtom(), input);\n\t\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\t\tactions.recognitionException(mte);\n\t\t\t\t\t}\n\t\t\t\t\tinput.consume(); // recover\n\t\t\t\t\tthrow mte;\n\t\t\t\t}\n\t\t\t\telse if ( label.isSet() ) {\n\t\t\t\t\tMismatchedSetException mse =\n\t\t\t\t\t\tnew MismatchedSetException(((IntervalSet)label.getSet()).toRuntimeBitSet(),\n\t\t\t\t\t\t\t\t\t\t\t\t   input);\n\t\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\t\tactions.recognitionException(mse);\n\t\t\t\t\t}\n\t\t\t\t\tinput.consume(); // recover\n\t\t\t\t\tthrow mse;\n\t\t\t\t}\n\t\t\t\telse if ( label.isSemanticPredicate() ) {\n\t\t\t\t\tFailedPredicateException fpe =\n\t\t\t\t\t\tnew FailedPredicateException(input,\n\t\t\t\t\t\t\t\t\t\t\t\t\t s.enclosingRule.name,\n\t\t\t\t\t\t\t\t\t\t\t\t\t label.getSemanticContext().toString());\n\t\t\t\t\tif ( actions!=null ) {\n\t\t\t\t\t\tactions.recognitionException(fpe);\n\t\t\t\t\t}\n\t\t\t\t\tinput.consume(); // recover\n\t\t\t\t\tthrow fpe;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthrow new RecognitionException(input); // unknown error\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//System.out.println(\"hit stop state for \"+stop.getEnclosingRule());\n\t\tif ( actions!=null ) {\n\t\t\tactions.exitRule(s.nfa.grammar.getFileName(), stop.enclosingRule.name);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#BreakStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#SimpleName#FieldAccess#CastExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ThrowStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ThrowStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ThrowStatement#Block#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ThrowStatement#Block#IfStatement#IfStatement#IfStatement#Block#IfStatement#IfStatement#Block#WhileStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(BreakStatement)BreakStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(PrefixExpression(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement)Block)IfStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(FieldAccess(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(SimpleName)SimpleName)FieldAccess)CastExpression)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(SimpleName)SimpleName)ThrowStatement)Block(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ThrowStatement)Block)IfStatement)IfStatement)IfStatement)Block)IfStatement)IfStatement)Block)WhileStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Fill a list of all NFA states visited during the parse", "call_func_name": ["org.antlr.tool.Grammar.getFileName", "org.antlr.runtime.debug.DebugEventListener.enterRule", "org.antlr.runtime.IntStream.LA", "java.util.List.add", "org.antlr.analysis.NFAState.getDecisionNumber", "org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA", "org.antlr.tool.Grammar.getLookaheadDFA", "org.antlr.runtime.IntStream.mark", "org.antlr.tool.Interpreter.predict", "org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.analysis.NFAState.getDescription", "org.antlr.analysis.DFA.getDecisionNumber", "org.antlr.runtime.NoViableAltException.<init>", "org.antlr.runtime.debug.DebugEventListener.recognitionException", "org.antlr.runtime.IntStream.consume", "org.antlr.runtime.IntStream.rewind", "org.antlr.analysis.NFAState.translateDisplayAltToWalkAlt", "org.antlr.analysis.NFA.getState", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision", "org.antlr.analysis.NFAState.isAcceptState", "org.antlr.runtime.debug.DebugEventListener.exitRule", "java.util.Stack.empty", "java.util.Stack.pop", "org.antlr.analysis.Label.isSemanticPredicate", "org.antlr.runtime.FailedPredicateException.<init>", "org.antlr.analysis.Label.isEpsilon", "java.util.Stack.push", "org.antlr.tool.Grammar.allDecisionDFAHaveBeenCreated", "org.antlr.tool.Grammar.createLookaheadDFAs", "org.antlr.analysis.Label.matches", "org.antlr.runtime.TokenStream.LT", "org.antlr.runtime.debug.DebugEventListener.consumeToken", "org.antlr.analysis.Label.isAtom", "org.antlr.analysis.Label.getAtom", "org.antlr.runtime.MismatchedTokenException.<init>", "org.antlr.analysis.Label.isSet", "org.antlr.analysis.Label.getSet", "org.antlr.misc.IntervalSet.toRuntimeBitSet", "org.antlr.runtime.MismatchedSetException.<init>", "org.antlr.analysis.Label.getSemanticContext", "java.lang.Object.toString", "org.antlr.runtime.RecognitionException.<init>"], "call_func_parameter": [[""], ["java.lang.String", "java.lang.String"], ["int"], ["java.lang.Object"], [""], ["org.antlr.analysis.NFAState"], ["int"], [""], ["org.antlr.analysis.DFA"], [""], [""], [""], ["java.lang.String", "int", "int", "org.antlr.runtime.IntStream"], ["org.antlr.runtime.RecognitionException"], [""], ["int"], ["int"], ["int"], ["org.antlr.analysis.NFAState", "int"], [""], ["java.lang.String", "java.lang.String"], [""], [""], [""], ["org.antlr.runtime.IntStream", "java.lang.String", "java.lang.String"], [""], ["java.lang.Object"], [""], [""], ["int"], ["int"], ["org.antlr.runtime.Token"], [""], [""], ["int", "org.antlr.runtime.IntStream"], [""], [""], [""], ["org.antlr.runtime.BitSet", "org.antlr.runtime.IntStream"], [""], [""], ["org.antlr.runtime.IntStream"]], "passed_comments": [{"org.antlr.runtime.debug.DebugEventListener.enterRule": "The parser has just entered a rule.  No decision has been made about which alt is predicted.  This is fired AFTER init actions have been executed.  Attributes are defined and available etc... The grammarFileName allows composite grammars to jump around among multiple grammar files."}, {"org.antlr.runtime.IntStream.LA": "Get int at current input pointer + i ahead where i=1 is next int. Negative indexes are allowed.  LA(-1) is previous token (token just matched).  LA(-i) where i is before first token should yield -1, invalid char / EOF."}, {"org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision."}, {"org.antlr.runtime.IntStream.mark": "Tell the stream to start buffering if it hasn't already.  Return current input position, index(), or some other marker so that when passed to rewind() you get back to the same spot. rewind(mark()) should not affect the input cursor.  The Lexer track line/col info as well as input index so its markers are not pure input indexes.  Same for tree node streams."}, {"org.antlr.tool.Interpreter.predict": "Given an input stream, return the unique alternative predicted by matching the input.  Upon error, return NFA.INVALID_ALT_NUMBER The first symbol of lookahead is presumed to be primed; that is, input.lookahead(1) must point at the input symbol you want to start predicting with."}, {"org.antlr.runtime.debug.DebugEventListener.recognitionException": "A recognition exception occurred such as NoViableAltException.  I made this a generic event so that I can alter the exception hierachy later without having to alter all the debug objects. Upon error, the stack of enter rule/subrule must be properly unwound. If no viable alt occurs it is within an enter/exit decision, which also must be rewound.  Even the rewind for each mark must be unwount. In the Java target this is pretty easy using try/finally, if a bit ugly in the generated code.  The rewind is generated in DFA.predict() actually so no code needs to be generated for that.  For languages w/o this \"finally\" feature (C++?), the target implementor will have to build an event stack or something. Across a socket for remote debugging, only the RecognitionException data fields are transmitted.  The token object or whatever that caused the problem was the last object referenced by LT.  The immediately preceding LT event should hold the unexpected Token or char. Here is a sample event trace for grammar: b : C ({;}A|B) // {;} is there to prevent A|B becoming a set | D ; The sequence for this rule (with no viable alt in the subrule) for input 'c c' (there are 3 tokens) is: commence LT(1) enterRule b location 7 1 enter decision 3 LT(1) exit decision 3 enterAlt1 location 7 5 LT(1) consumeToken [c/&lt;4&gt;,1:0] location 7 7 enterSubRule 2 enter decision 2 LT(1) LT(1) recognitionException NoViableAltException 2 1 2 exit decision 2 exitSubRule 2 beginResync LT(1) consumeToken [c/&lt;4&gt;,1:1] LT(1) endResync LT(-1) exitRule b terminate"}, {"org.antlr.runtime.IntStream.rewind": "Reset the stream so that next call to index would return marker. The marker will usually be index() but it doesn't have to be.  It's just a marker to indicate what state the stream was in.  This is essentially calling release() and seek().  If there are markers created after this marker argument, this routine must unroll them like a stack.  Assume the state the stream was in when this marker was created."}, {"org.antlr.analysis.NFAState.translateDisplayAltToWalkAlt": "The DFA decision for this NFA decision state always has an exit path for loops as n+1 for n alts in the loop. That is really useful for displaying nondeterministic alts and so on, but for walking the NFA to get a sequence of edge labels or for actually parsing, we need to get the real alt number.  The real alt number for exiting a loop is always 1 as transition 0 points at the exit branch (we compute DFAs always for loops at the loopback state). For walking/parsing the loopback state: 1 2 3 display alt (for human consumption) 2 3 1 walk alt For walking the block start: 1 2 3 display alt 1 2 3 For walking the bypass state of a (...)"}, {"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}, {"org.antlr.runtime.debug.DebugEventListener.exitRule": "This is the last thing executed before leaving a rule.  It is executed even if an exception is thrown.  This is triggered after error reporting and recovery have occurred (unless the exception is not caught in this rule).  This implies an \"exitAlt\" event. The grammarFileName allows composite grammars to jump around among multiple grammar files."}, {"org.antlr.tool.Grammar.createLookaheadDFAs": "For each decision in this grammar, compute a single DFA using the NFA states associated with the decision.  The DFA construction determines whether or not the alternatives in the decision are separable using a regular lookahead language. Store the lookahead DFAs in the AST created from the user's grammar so the code generator or whoever can easily access it. This is a separate method because you might want to create a Grammar without doing the expensive analysis."}, {"org.antlr.runtime.TokenStream.LT": "Get Token at current input pointer + i ahead where i=1 is next Token. i&lt;0 indicates tokens in the past.  So -1 is previous token and -2 is two tokens ago. LT(0) is undefined.  For i&gt;=n, return Token.EOFToken. Return null for LT(0) and any index that results in an absolute address that is negative."}, {"org.antlr.runtime.debug.DebugEventListener.consumeToken": "An input token was consumed; matched by any kind of element. Trigger after the token was matched by things like match(), matchAny()."}, {"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}]}, {"index": "670", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Interpreter.java", "methodName": "org.antlr.tool.Interpreter.predict", "methodParameterType": "DFA#", "methodParameterName": "dfa#", "methodBody": "public int predict(DFA dfa) {\n\t\tDFAState s = dfa.startState;\n\t\tint c = input.LA(1);\n\t\tTransition eotTransition = null;\n\tdfaLoop:\n\t\twhile ( !s.isAcceptState() ) {\n\t\t\t/*\n\t\t\tSystem.out.println(\"DFA.predict(\"+s.getStateNumber()+\", \"+\n\t\t\t\t\tdfa.getNFA().getGrammar().getTokenName(c)+\")\");\n\t\t\t*/\n\t\t\t// for each edge of s, look for intersection with current char\n\t\t\tfor (int i=0; i<s.getNumberOfTransitions(); i++) {\n\t\t\t\tTransition t = s.transition(i);\n\t\t\t\t// special case: EOT matches any char\n\t\t\t\tif ( t.label.matches(c) ) {\n\t\t\t\t\t// take transition i\n\t\t\t\t\ts = (DFAState)t.target;\n\t\t\t\t\tinput.consume();\n\t\t\t\t\tc = input.LA(1);\n\t\t\t\t\tcontinue dfaLoop;\n\t\t\t\t}\n\t\t\t\tif ( t.label.getAtom()==Label.EOT ) {\n\t\t\t\t\teotTransition = t;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( eotTransition!=null ) {\n\t\t\t\ts = (DFAState)eotTransition.target;\n\t\t\t\tcontinue dfaLoop;\n\t\t\t}\n\t\t\t/*\n\t\t\tErrorManager.error(ErrorManager.MSG_NO_VIABLE_DFA_ALT,\n\t\t\t\t\t\t\t   s,\n\t\t\t\t\t\t\t   dfa.nfa.grammar.getTokenName(c));\n\t\t\t*/\n\t\t\treturn NFA.INVALID_ALT_NUMBER;\n\t\t}\n\t\t// woohoo!  We know which alt to predict\n\t\t// nothing emanates from a stop state; must terminate anyway\n\t\t/*\n\t\tSystem.out.println(\"DFA stop state \"+s.getStateNumber()+\" predicts \"+\n\t\t\t\ts.getUniquelyPredictedAlt());\n\t\t*/\n\t\treturn s.getUniquelyPredictedAlt();\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#SimpleName#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#WhileStatement#LabeledStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(LabeledStatement(SimpleName)SimpleName(WhileStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement(SimpleName)SimpleName)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement(ContinueStatement(SimpleName)SimpleName)ContinueStatement)Block)IfStatement(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)WhileStatement)LabeledStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given an input stream, return the unique alternative predicted by matching the input.  Upon error, return NFA.INVALID_ALT_NUMBER The first symbol of lookahead is presumed to be primed; that is, input.lookahead(1) must point at the input symbol you want to start predicting with.", "call_func_name": ["org.antlr.runtime.IntStream.LA", "org.antlr.analysis.DFAState.isAcceptState", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.analysis.Label.matches", "org.antlr.runtime.IntStream.consume", "org.antlr.analysis.Label.getAtom", "org.antlr.analysis.DFAState.getUniquelyPredictedAlt"], "call_func_parameter": [["int"], [""], [""], ["int"], ["int"], [""], [""], [""]], "passed_comments": [{"org.antlr.runtime.IntStream.LA": "Get int at current input pointer + i ahead where i=1 is next int. Negative indexes are allowed.  LA(-1) is previous token (token just matched).  LA(-i) where i is before first token should yield -1, invalid char / EOF."}, {"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.analysis.DFAState.getUniquelyPredictedAlt": "Walk each configuration and if they are all the same alt, return that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved configurations, but don't ignore resolveWithPredicate configs because this state should not be an accept state.  We need to add this to the work list and then have semantic predicate edges emanating from it."}]}, {"index": "671", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Message.java", "methodName": "org.antlr.tool.Message.getMessageTemplate", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public ST getMessageTemplate() { return new ST(msgST); }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a new template instance every time someone tries to print a Message.", "call_func_name": ["org.stringtemplate.v4.ST.<init>"], "call_func_parameter": [["org.stringtemplate.v4.ST"]], "passed_comments": "/"}, {"index": "672", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/Message.java", "methodName": "org.antlr.tool.Message.getLocationTemplate", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public ST getLocationTemplate() { return new ST(locationST); }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a new template instance for the location part of a Message. TODO: Is this really necessary? -Kay", "call_func_name": ["org.stringtemplate.v4.ST.<init>"], "call_func_parameter": [["org.stringtemplate.v4.ST"]], "passed_comments": "/"}, {"index": "673", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarSpelunker.java", "methodName": "org.antlr.tool.GrammarSpelunker.main", "methodParameterType": "String[]#", "methodParameterName": "args#", "methodBody": "public static void main(String[] args) throws IOException {\n        GrammarSpelunker g = new GrammarSpelunker(\".\", args[0]);\n        g.parse();\n        System.out.println(g.grammarModifier+\" grammar \"+g.grammarName);\n        System.out.println(\"language=\"+g.language);\n        System.out.println(\"tokenVocab=\"+g.tokenVocab);\n        System.out.println(\"imports=\"+g.importedGrammars);\n    }", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#StringLiteral#SimpleName#NumberLiteral#ArrayAccess#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#InfixExpression#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Tester; Give grammar filename as arg", "call_func_name": ["org.antlr.tool.GrammarSpelunker.<init>", "org.antlr.tool.GrammarSpelunker.parse", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.PrintStream.println", "java.lang.StringBuilder.append"], "call_func_parameter": [["java.lang.String", "java.lang.String"], [""], [""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "674", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.optimizeAlternative", "methodParameterType": "StateCluster#", "methodParameterName": "alt#", "methodBody": "public void optimizeAlternative(StateCluster alt) {\n\t\tNFAState s = alt.left;\n\t\twhile ( s!=alt.right ) {\n\t\t\t// if it's a block element, jump over it and continue\n\t\t\tif ( s.endOfBlockStateNumber!=State.INVALID_STATE_NUMBER ) {\n\t\t\t\ts = nfa.getState(s.endOfBlockStateNumber);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tTransition t = s.transition[0];\n\t\t\tif ( t instanceof RuleClosureTransition ) {\n\t\t\t\ts = ((RuleClosureTransition) t).followState;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( t.label.isEpsilon() && !t.label.isAction() && s.getNumberOfTransitions()==1 ) {\n\t\t\t\t// bypass epsilon transition and point to what the epsilon's\n\t\t\t\t// target points to unless that epsilon transition points to\n\t\t\t\t// a block or loop etc..  Also don't collapse epsilons that\n\t\t\t\t// point at the last node of the alt. Don't collapse action edges\n\t\t\t\tNFAState epsilonTarget = (NFAState)t.target;\n\t\t\t\tif ( epsilonTarget.endOfBlockStateNumber==State.INVALID_STATE_NUMBER &&\n\t\t\t\t\t epsilonTarget.transition[0] !=null )\n\t\t\t\t{\n\t\t\t\t\ts.setTransition0(epsilonTarget.transition[0]);\n\t\t\t\t\t/*\n\t\t\t\t\tSystem.out.println(\"### opt \"+s.stateNumber+\"->\"+\n\t\t\t\t\t\t\t\t\t   epsilonTarget.transition(0).target.stateNumber);\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t}\n\t\t\ts = (NFAState)t.target;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#FieldAccess#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(FieldAccess(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)FieldAccess)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(PrefixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "Optimize an alternative (list of grammar elements). Walk the chain of elements (which can be complicated loop blocks...) and throw away any epsilon transitions used to link up simple elements. This only removes 195 states from the java.g's NFA, but every little bit helps.  Perhaps I can improve in the future.", "call_func_name": ["org.antlr.analysis.NFA.getState", "org.antlr.analysis.Label.isEpsilon", "org.antlr.analysis.Label.isAction", "org.antlr.analysis.NFAState.getNumberOfTransitions", "org.antlr.analysis.NFAState.setTransition0"], "call_func_parameter": [["int"], [""], [""], [""], ["org.antlr.analysis.Transition"]], "passed_comments": [{"org.antlr.analysis.NFAState.setTransition0": "Used during optimization to reset a state to have the (single) transition another state has."}]}, {"index": "675", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Atom", "methodParameterType": "int#GrammarAST#", "methodParameterName": "label#associatedAST#", "methodBody": "public StateCluster build_Atom(int label, GrammarAST associatedAST) {\n\t\tNFAState left = newState();\n\t\tNFAState right = newState();\n\t\tleft.associatedASTNode = associatedAST;\n\t\tright.associatedASTNode = associatedAST;\n\t\ttransitionBetweenStates(left, right, label);\n\t\tStateCluster g = new StateCluster(left, right);\n\t\treturn g;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From label A build Graph o-A-&gt;o", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "676", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Set", "methodParameterType": "IntSet#GrammarAST#", "methodParameterName": "set#associatedAST#", "methodBody": "public StateCluster build_Set(IntSet set, GrammarAST associatedAST) {\n        NFAState left = newState();\n        NFAState right = newState();\n\t\tleft.associatedASTNode = associatedAST;\n\t\tright.associatedASTNode = associatedAST;\n\t\tLabel label = new Label(set);\n\t\tTransition e = new Transition(label,right);\n        left.addTransition(e);\n\t\tStateCluster g = new StateCluster(left, right);\n        return g;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From set build single edge graph o-&gt;o-set-&gt;o.  To conform to what an alt block looks like, must have extra state on left.", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.Label.<init>", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.misc.IntSet"], ["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "677", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Range", "methodParameterType": "int#int#", "methodParameterName": "a#b#", "methodBody": "public StateCluster build_Range(int a, int b) {\n        NFAState left = newState();\n        NFAState right = newState();\n\t\tLabel label = new Label(IntervalSet.of(a, b));\n\t\tTransition e = new Transition(label,right);\n        left.addTransition(e);\n        StateCluster g = new StateCluster(left, right);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Can only complement block of simple alts; can complement build_Set() result, that is.  Get set and complement, replace old with complement. public StateCluster build_AlternativeBlockComplement(StateCluster blk) { State s0 = blk.left; IntSet set = getCollapsedBlockAsSet(s0); if ( set!=null ) { // if set is available, then structure known and blk is a set set = nfa.grammar.complement(set); Label label = s0.transition(0).target.transition(0).label; label.setSet(set); } return blk; }", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.misc.IntervalSet.of", "org.antlr.analysis.Label.<init>", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["int", "int"], ["org.antlr.misc.IntSet"], ["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": [{"org.antlr.misc.IntervalSet.of": "Create a set with all ints within range [a..b] (inclusive)"}]}, {"index": "678", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_CharLiteralAtom", "methodParameterType": "GrammarAST#", "methodParameterName": "charLiteralAST#", "methodBody": "public StateCluster build_CharLiteralAtom(GrammarAST charLiteralAST) {\n        int c = Grammar.getCharValueFromGrammarCharLiteral(charLiteralAST.getText());\n\t\treturn build_Atom(c, charLiteralAST);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From char 'c' build StateCluster o-intValue(c)-&gt;o", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral", "org.antlr.tool.NFAFactory.build_Atom"], "call_func_parameter": [[""], ["java.lang.String"], ["int", "org.antlr.tool.GrammarAST"]], "passed_comments": [{"org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral": "Given a literal like (the 3 char sequence with single quotes) 'a', return the int value of 'a'. Convert escape sequences here also. ANTLR's antlr.g parser does not convert escape sequences. 11/26/2005: I changed literals to always be '...' even for strings. This routine still works though."}, {"org.antlr.tool.NFAFactory.build_Atom": "From label A build Graph o-A-&gt;o"}]}, {"index": "679", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_CharRange", "methodParameterType": "String#String#", "methodParameterName": "a#b#", "methodBody": "public StateCluster build_CharRange(String a, String b) {\n\t\tint from = Grammar.getCharValueFromGrammarCharLiteral(a);\n\t\tint to = Grammar.getCharValueFromGrammarCharLiteral(b);\n\t\treturn build_Range(from, to);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From char 'c' build StateCluster o-intValue(c)-&gt;o can include unicode spec likes '\\u0024' later.  Accepts actual unicode 16-bit now, of course, by default. TODO not supplemental char clean!", "call_func_name": ["org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral", "org.antlr.tool.NFAFactory.build_Range"], "call_func_parameter": [["java.lang.String"], ["int", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral": "Given a literal like (the 3 char sequence with single quotes) 'a', return the int value of 'a'. Convert escape sequences here also. ANTLR's antlr.g parser does not convert escape sequences. 11/26/2005: I changed literals to always be '...' even for strings. This routine still works though."}, {"org.antlr.tool.NFAFactory.build_Range": "Can only complement block of simple alts; can complement build_Set() result, that is.  Get set and complement, replace old with complement. public StateCluster build_AlternativeBlockComplement(StateCluster blk) { State s0 = blk.left; IntSet set = getCollapsedBlockAsSet(s0); if ( set!=null ) { // if set is available, then structure known and blk is a set set = nfa.grammar.complement(set); Label label = s0.transition(0).target.transition(0).label; label.setSet(set); } return blk; }"}]}, {"index": "680", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_StringLiteralAtom", "methodParameterType": "GrammarAST#", "methodParameterName": "stringLiteralAST#", "methodBody": "public StateCluster build_StringLiteralAtom(GrammarAST stringLiteralAST) {\n        if ( nfa.grammar.type==Grammar.LEXER ) {\n\t\t\tStringBuffer chars =\n\t\t\t\tGrammar.getUnescapedStringFromGrammarStringLiteral(stringLiteralAST.getText());\n            NFAState first = newState();\n            NFAState last = null;\n            NFAState prev = first;\n            for (int i=0; i<chars.length(); i++) {\n                int c = chars.charAt(i);\n                NFAState next = newState();\n                transitionBetweenStates(prev, next, c);\n                prev = last = next;\n            }\n            return  new StateCluster(first, last);\n        }\n\n        // a simple token reference in non-Lexers\n        int tokenType = nfa.grammar.getTokenType(stringLiteralAST.getText());\n\t\treturn build_Atom(tokenType, stringLiteralAST);\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#Assignment#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)Assignment)ExpressionStatement)Block)ForStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For a non-lexer, just build a simple token reference atom. For a lexer, a string is a sequence of char to match.  That is, \"fog\" is treated as 'f' 'o' 'g' not as a single transition in the DFA.  Machine== o-'f'-&gt;o-'o'-&gt;o-'g'-&gt;o and has n+1 states for n characters.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getUnescapedStringFromGrammarStringLiteral", "org.antlr.tool.NFAFactory.newState", "java.lang.StringBuffer.length", "java.lang.StringBuffer.charAt", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>", "org.antlr.tool.Grammar.getTokenType", "org.antlr.tool.NFAFactory.build_Atom"], "call_func_parameter": [[""], ["java.lang.String"], [""], [""], ["int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"], ["java.lang.String"], ["int", "org.antlr.tool.GrammarAST"]], "passed_comments": [{"org.antlr.tool.Grammar.getUnescapedStringFromGrammarStringLiteral": "ANTLR does not convert escape sequences during the parse phase because it could not know how to print String/char literals back out when printing grammars etc...  Someone in China might use the real unicode char in a literal as it will display on their screen; when printing back out, I could not know whether to display or use a unicode escape. This routine converts a string literal with possible escape sequences into a pure string of 16-bit char values.  Escapes and unicode \\u0000 specs are converted to pure chars.  return in a buffer; people may want to walk/manipulate further. The NFA construction routine must know the actual char values."}, {"org.antlr.tool.NFAFactory.build_Atom": "From label A build Graph o-A-&gt;o"}]}, {"index": "681", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_RuleRef", "methodParameterType": "Rule#NFAState#", "methodParameterName": "refDef#ruleStart#", "methodBody": "public StateCluster build_RuleRef(Rule refDef, NFAState ruleStart) {\n        //System.out.println(\"building ref to rule \"+nfa.grammar.name+\".\"+refDef.name);\n        NFAState left = newState();\n        // left.setDescription(\"ref to \"+ruleStart.getDescription());\n        NFAState right = newState();\n        // right.setDescription(\"NFAState following ref to \"+ruleStart.getDescription());\n        Transition e = new RuleClosureTransition(refDef,ruleStart,right);\n        left.addTransition(e);\n        StateCluster g = new StateCluster(left, right);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For reference to rule r, build o-e-&gt;(r)  o where (r) is the start of rule r and the trailing o is not linked to from rule ref state directly (it's done thru the transition(0) RuleClosureTransition. If the rule r is just a list of tokens, it's block will be just a set on an edge o-&gt;o-&gt;o-set-&gt;o-&gt;o-&gt;o, could inline it rather than doing the rule reference, but i'm not doing this yet as I'm not sure it would help much in the NFA&rarr;DFA construction. TODO add to codegen: collapse alt blks that are sets into single matchSet", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.RuleClosureTransition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.tool.Rule", "org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "682", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Epsilon", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public StateCluster build_Epsilon() {\n        NFAState left = newState();\n        NFAState right = newState();\n        transitionBetweenStates(left, right, Label.EPSILON);\n        StateCluster g = new StateCluster(left, right);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From an empty alternative build StateCluster o-e-&gt;o", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "683", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_SemanticPredicate", "methodParameterType": "GrammarAST#", "methodParameterName": "pred#", "methodBody": "public StateCluster build_SemanticPredicate(GrammarAST pred) {\n\t\t// don't count syn preds\n\t\tif ( !pred.getText().toUpperCase()\n\t\t\t\t.startsWith(Grammar.SYNPRED_RULE_PREFIX.toUpperCase()) )\n\t\t{\n\t\t\tnfa.grammar.numberOfSemanticPredicates++;\n\t\t}\n\t\tNFAState left = newState();\n\t\tNFAState right = newState();\n\t\tTransition e = new Transition(new PredicateLabel(pred), right);\n\t\tleft.addTransition(e);\n\t\tStateCluster g = new StateCluster(left, right);\n\t\treturn g;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#PrefixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)PrefixExpression(Block(ExpressionStatement(PostfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)PostfixExpression)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Build what amounts to an epsilon transition with a semantic predicate action.  The pred is a pointer into the AST of the SEMPRED token.", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.lang.String.toUpperCase", "java.lang.String.startsWith", "org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.PredicateLabel.<init>", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["org.antlr.tool.GrammarAST"], ["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "684", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Action", "methodParameterType": "GrammarAST#", "methodParameterName": "action#", "methodBody": "public StateCluster build_Action(GrammarAST action) {\n\t\tNFAState left = newState();\n\t\tNFAState right = newState();\n\t\tTransition e = new Transition(new ActionLabel(action), right);\n\t\tleft.addTransition(e);\n\t\treturn new StateCluster(left, right);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Build what amounts to an epsilon transition with an action. The action goes into NFA though it is ignored during analysis. It slows things down a bit, but I must ignore predicates after having seen an action (5-5-2008).", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.ActionLabel.<init>", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.tool.GrammarAST"], ["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "685", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_EOFStates", "methodParameterType": "Collection<Rule>#", "methodParameterName": "rules#", "methodBody": "public int build_EOFStates(Collection<Rule> rules) {\n\t\tint numberUnInvokedRules = 0;\n        for (Rule r : rules) {\n\t\t\tNFAState endNFAState = r.stopState;\n            // Is this rule a start symbol?  (no follow links)\n\t\t\tif ( endNFAState.transition[0] ==null ) {\n\t\t\t\t// if so, then don't let algorithm fall off the end of\n\t\t\t\t// the rule, make it hit EOF/EOT.\n\t\t\t\tbuild_EOFState(endNFAState);\n\t\t\t\t// track how many rules have been invoked by another rule\n\t\t\t\tnumberUnInvokedRules++;\n\t\t\t}\n        }\n\t\treturn numberUnInvokedRules;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "add an EOF transition to any rule end NFAState that points to nothing (i.e., for all those rules not invoked by another rule).  These are start symbols then. Return the number of grammar entry points; i.e., how many rules are not invoked by another rule (they can only be invoked from outside). These are the start rules.", "call_func_name": ["java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.NFAFactory.build_EOFState"], "call_func_parameter": [[""], [""], [""], ["org.antlr.analysis.NFAState"]], "passed_comments": [{"org.antlr.tool.NFAFactory.build_EOFState": "set up an NFA NFAState that will yield eof tokens or, in the case of a lexer grammar, an EOT token when the conversion hits the end of a rule."}]}, {"index": "686", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_EOFState", "methodParameterType": "NFAState#", "methodParameterName": "endNFAState#", "methodBody": "private void build_EOFState(NFAState endNFAState) {\n\t\tNFAState end = newState();\n        int label = Label.EOF;\n        if ( nfa.grammar.type==Grammar.LEXER ) {\n            label = Label.EOT;\n\t\t\tend.setEOTTargetState(true);\n        }\n\t\t/*\n\t\tSystem.out.println(\"build \"+nfa.grammar.getTokenDisplayName(label)+\n\t\t\t\t\t\t   \" loop on end of state \"+endNFAState.getDescription()+\n\t\t\t\t\t\t   \" to state \"+end.stateNumber);\n\t\t*/\n\t\tTransition toEnd = new Transition(label, end);\n\t\tendNFAState.addTransition(toEnd);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "set up an NFA NFAState that will yield eof tokens or, in the case of a lexer grammar, an EOT token when the conversion hits the end of a rule.", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.NFAState.setEOTTargetState", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition"], "call_func_parameter": [[""], ["boolean"], ["int", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"]], "passed_comments": "/"}, {"index": "687", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_AB", "methodParameterType": "StateCluster#StateCluster#", "methodParameterName": "A#B#", "methodBody": "public StateCluster build_AB(StateCluster A, StateCluster B) {\n        if ( A==null ) {\n            return B;\n        }\n        if ( B==null ) {\n            return A;\n        }\n\t\ttransitionBetweenStates(A.right, B.left, Label.EPSILON);\n\t\tStateCluster g = new StateCluster(A.left, B.right);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From A B build A-e-&gt;B (that is, build an epsilon arc from right of A to left of B). As a convenience, return B if A is null or return A if B is null.", "call_func_name": ["org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "688", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_AlternativeBlockFromSet", "methodParameterType": "StateCluster#", "methodParameterName": "set#", "methodBody": "public StateCluster build_AlternativeBlockFromSet(StateCluster set) {\n\t\tif ( set==null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// single alt, no decision, just return only alt state cluster\n\t\tNFAState startOfAlt = newState(); // must have this no matter what\n\t\ttransitionBetweenStates(startOfAlt, set.left, Label.EPSILON);\n\n\t\treturn new StateCluster(startOfAlt,set.right);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From a set ('a'|'b') build o-&gt;o-'a'..'b'-&gt;o-&gt;o (last NFAState is blockEndNFAState pointed to by all alts)", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "689", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_AlternativeBlock", "methodParameterType": "List<StateCluster>#", "methodParameterName": "alternativeStateClusters#", "methodBody": "public StateCluster build_AlternativeBlock(List<StateCluster> alternativeStateClusters)\n    {\n        StateCluster result;\n        if ( alternativeStateClusters==null || alternativeStateClusters.isEmpty() ) {\n            return null;\n        }\n\n\t\t// single alt case\n\t\tif ( alternativeStateClusters.size()==1 ) {\n\t\t\t// single alt, no decision, just return only alt state cluster\n\t\t\tStateCluster g = alternativeStateClusters.get(0);\n\t\t\tNFAState startOfAlt = newState(); // must have this no matter what\n\t\t\ttransitionBetweenStates(startOfAlt, g.left, Label.EPSILON);\n\n\t\t\t//System.out.println(\"### opt saved start/stop end in (...)\");\n\t\t\treturn new StateCluster(startOfAlt,g.right);\n\t\t}\n\n\t\t// even if we can collapse for lookahead purposes, we will still\n        // need to predict the alts of this subrule in case there are actions\n        // etc...  This is the decision that is pointed to from the AST node\n        // (always)\n        NFAState prevAlternative = null; // tracks prev so we can link to next alt\n        NFAState firstAlt = null;\n        NFAState blockEndNFAState = newState();\n        blockEndNFAState.setDescription(\"end block\");\n        int altNum = 1;\n        for (StateCluster g : alternativeStateClusters) {\n            // add begin NFAState for this alt connected by epsilon\n            NFAState left = newState();\n            left.setDescription(\"alt \"+altNum+\" of ()\");\n\t\t\ttransitionBetweenStates(left, g.left, Label.EPSILON);\n\t\t\ttransitionBetweenStates(g.right, blockEndNFAState, Label.EPSILON);\n\t\t\t// Are we the first alternative?\n\t\t\tif ( firstAlt==null ) {\n\t\t\t\tfirstAlt = left; // track extreme left node of StateCluster\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// if not first alternative, must link to this alt from previous\n\t\t\t\ttransitionBetweenStates(prevAlternative, left, Label.EPSILON);\n\t\t\t}\n\t\t\tprevAlternative = left;\n\t\t\taltNum++;\n\t\t}\n\n\t\t// return StateCluster pointing representing entire block\n\t\t// Points to first alt NFAState on left, block end on right\n\t\tresult = new StateCluster(firstAlt, blockEndNFAState);\n\n\t\tfirstAlt.decisionStateType = NFAState.BLOCK_START;\n\n\t\t// set EOB markers for Jean\n\t\tfirstAlt.endOfBlockStateNumber = blockEndNFAState.stateNumber;\n\n\t\treturn result;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ReturnStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)EnhancedForStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From A|B|..|Z alternative block build o-&gt;o-A-&gt;o-&gt;o (last NFAState is blockEndNFAState pointed to by all alts) |          ^ o-&gt;o-B-&gt;o--| |          | ...        | |          | o-&gt;o-Z-&gt;o--| So every alternative gets begin NFAState connected by epsilon and every alt right side points at a block end NFAState.  There is a new NFAState in the NFAState in the StateCluster for each alt plus one for the end NFAState. Special case: only one alternative: don't make a block with alt begin/end. Special case: if just a list of tokens/chars/sets, then collapse to a single edge'd o-set-&gt;o graph. Set alt number (1..n) in the left-Transition NFAState.", "call_func_name": ["java.util.List.isEmpty", "java.util.List.size", "java.util.List.get", "org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>", "org.antlr.analysis.NFAState.setDescription", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], [""], ["int"], [""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"], ["java.lang.String"], [""], [""], [""], [""], ["java.lang.String"], ["int"], [""]], "passed_comments": "/"}, {"index": "690", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Aoptional", "methodParameterType": "StateCluster#", "methodParameterName": "A#", "methodBody": "public StateCluster build_Aoptional(StateCluster A) {\n        StateCluster g;\n        int n = nfa.grammar.getNumberOfAltsForDecisionNFA(A.left);\n        if ( n==1 ) {\n            // no decision, just wrap in an optional path\n\t\t\t//NFAState decisionState = newState();\n\t\t\tNFAState decisionState = A.left; // resuse left edge\n\t\t\tdecisionState.setDescription(\"only alt of ()? block\");\n\t\t\tNFAState emptyAlt = newState();\n            emptyAlt.setDescription(\"epsilon path of ()? block\");\n            NFAState blockEndNFAState;\n\t\t\tblockEndNFAState = newState();\n\t\t\ttransitionBetweenStates(A.right, blockEndNFAState, Label.EPSILON);\n\t\t\tblockEndNFAState.setDescription(\"end ()? block\");\n            //transitionBetweenStates(decisionState, A.left, Label.EPSILON);\n            transitionBetweenStates(decisionState, emptyAlt, Label.EPSILON);\n            transitionBetweenStates(emptyAlt, blockEndNFAState, Label.EPSILON);\n\n\t\t\t// set EOB markers for Jean\n\t\t\tdecisionState.endOfBlockStateNumber = blockEndNFAState.stateNumber;\n\t\t\tblockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;\n\n            g = new StateCluster(decisionState, blockEndNFAState);\n        }\n        else {\n            // a decision block, add an empty alt\n            NFAState lastRealAlt =\n                    nfa.grammar.getNFAStateForAltOfDecision(A.left, n);\n            NFAState emptyAlt = newState();\n            emptyAlt.setDescription(\"epsilon path of ()? block\");\n            transitionBetweenStates(lastRealAlt, emptyAlt, Label.EPSILON);\n            transitionBetweenStates(emptyAlt, A.right, Label.EPSILON);\n\n\t\t\t// set EOB markers for Jean (I think this is redundant here)\n\t\t\tA.left.endOfBlockStateNumber = A.right.stateNumber;\n\t\t\tA.right.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;\n\n            g = A; // return same block, but now with optional last path\n        }\n\t\tg.left.decisionStateType = NFAState.OPTIONAL_BLOCK_START;\n\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From (A)? build either: o--A-&gt;o |     ^ o----&gt;| or, if A is a block, just add an empty alt to the end of the block", "call_func_name": ["org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA", "org.antlr.analysis.NFAState.setDescription", "org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision"], "call_func_parameter": [["org.antlr.analysis.NFAState"], ["java.lang.String"], [""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"], ["org.antlr.analysis.NFAState", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision."}, {"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}]}, {"index": "691", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Aplus", "methodParameterType": "StateCluster#", "methodParameterName": "A#", "methodBody": "public StateCluster build_Aplus(StateCluster A) {\n        NFAState left = newState();\n        NFAState blockEndNFAState = newState();\n\t\tblockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;\n\n\t\t// don't reuse A.right as loopback if it's right edge of another block\n\t\tif ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK ) {\n\t\t\t// nested A* so make another tail node to be the loop back\n\t\t\t// instead of the usual A.right which is the EOB for inner loop\n\t\t\tNFAState extraRightEdge = newState();\n\t\t\ttransitionBetweenStates(A.right, extraRightEdge, Label.EPSILON);\n\t\t\tA.right = extraRightEdge;\n\t\t}\n\n        transitionBetweenStates(A.right, blockEndNFAState, Label.EPSILON); // follow is Transition 1\n\t\t// turn A's block end into a loopback (acts like alt 2)\n\t\ttransitionBetweenStates(A.right, A.left, Label.EPSILON); // loop back Transition 2\n\t\ttransitionBetweenStates(left, A.left, Label.EPSILON);\n\t\t\n\t\tA.right.decisionStateType = NFAState.LOOPBACK;\n\t\tA.left.decisionStateType = NFAState.BLOCK_START;\n\n\t\t// set EOB markers for Jean\n\t\tA.left.endOfBlockStateNumber = A.right.stateNumber;\n\n        StateCluster g = new StateCluster(left, blockEndNFAState);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From (A)+ build |---|    (Transition 2 from A.right points at alt 1) v   |    (follow of loop is Transition 1) o-&gt;o-A-o-&gt;o Meaning that the last NFAState in A points back to A's left Transition NFAState and we add a new begin/end NFAState.  A can be single alternative or multiple. During analysis we'll call the follow link (transition 1) alt n+1 for an n-alt A block.", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "692", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Astar", "methodParameterType": "StateCluster#", "methodParameterName": "A#", "methodBody": "public StateCluster build_Astar(StateCluster A) {\n\t\tNFAState bypassDecisionState = newState();\n\t\tbypassDecisionState.setDescription(\"enter loop path of ()* block\");\n        NFAState optionalAlt = newState();\n        optionalAlt.setDescription(\"epsilon path of ()* block\");\n        NFAState blockEndNFAState = newState();\n\t\tblockEndNFAState.decisionStateType = NFAState.RIGHT_EDGE_OF_BLOCK;\n\n\t\t// don't reuse A.right as loopback if it's right edge of another block\n\t\tif ( A.right.decisionStateType == NFAState.RIGHT_EDGE_OF_BLOCK ) {\n\t\t\t// nested A* so make another tail node to be the loop back\n\t\t\t// instead of the usual A.right which is the EOB for inner loop\n\t\t\tNFAState extraRightEdge = newState();\n\t\t\ttransitionBetweenStates(A.right, extraRightEdge, Label.EPSILON);\n\t\t\tA.right = extraRightEdge;\n\t\t}\n\n\t\t// convert A's end block to loopback\n\t\tA.right.setDescription(\"()* loopback\");\n\t\t// Transition 1 to actual block of stuff\n        transitionBetweenStates(bypassDecisionState, A.left, Label.EPSILON);\n        // Transition 2 optional to bypass\n        transitionBetweenStates(bypassDecisionState, optionalAlt, Label.EPSILON);\n\t\ttransitionBetweenStates(optionalAlt, blockEndNFAState, Label.EPSILON);\n        // Transition 1 of end block exits\n        transitionBetweenStates(A.right, blockEndNFAState, Label.EPSILON);\n        // Transition 2 of end block loops\n        transitionBetweenStates(A.right, A.left, Label.EPSILON);\n\n\t\tbypassDecisionState.decisionStateType = NFAState.BYPASS;\n\t\tA.left.decisionStateType = NFAState.BLOCK_START;\n\t\tA.right.decisionStateType = NFAState.LOOPBACK;\n\n\t\t// set EOB markers for Jean\n\t\tA.left.endOfBlockStateNumber = A.right.stateNumber;\n\t\tbypassDecisionState.endOfBlockStateNumber = blockEndNFAState.stateNumber;\n\n        StateCluster g = new StateCluster(bypassDecisionState, blockEndNFAState);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From (A)", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.analysis.NFAState.setDescription", "org.antlr.tool.NFAFactory.transitionBetweenStates", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], ["java.lang.String"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState", "int"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": "/"}, {"index": "693", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_Wildcard", "methodParameterType": "GrammarAST#", "methodParameterName": "associatedAST#", "methodBody": "public StateCluster build_Wildcard(GrammarAST associatedAST) {\n        NFAState left = newState();\n        NFAState right = newState();\n        left.associatedASTNode = associatedAST;\n        right.associatedASTNode = associatedAST;\n        Label label = new Label(nfa.grammar.getTokenTypes()); // char or tokens\n        Transition e = new Transition(label,right);\n        left.addTransition(e);\n        StateCluster g = new StateCluster(left, right);\n        return g;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Build an atom with all possible values in its label", "call_func_name": ["org.antlr.tool.NFAFactory.newState", "org.antlr.tool.Grammar.getTokenTypes", "org.antlr.analysis.Label.<init>", "org.antlr.analysis.Transition.<init>", "org.antlr.analysis.NFAState.addTransition", "org.antlr.analysis.StateCluster.<init>"], "call_func_parameter": [[""], [""], ["org.antlr.misc.IntSet"], ["org.antlr.analysis.Label", "org.antlr.analysis.State"], ["org.antlr.analysis.Transition"], ["org.antlr.analysis.NFAState", "org.antlr.analysis.NFAState"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenTypes": "Return a set of all possible token or char types for this grammar"}]}, {"index": "694", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.build_WildcardTree", "methodParameterType": "GrammarAST#", "methodParameterName": "associatedAST#", "methodBody": "public StateCluster build_WildcardTree(GrammarAST associatedAST) {\n        StateCluster wildRoot = build_Wildcard(associatedAST);\n\n        StateCluster down = build_Atom(Label.DOWN, associatedAST);\n        wildRoot = build_AB(wildRoot,down); // hook in; . DOWN\n\n        // make .+\n        StateCluster wildChildren = build_Wildcard(associatedAST);\n        wildChildren = build_Aplus(wildChildren);\n        wildRoot = build_AB(wildRoot,wildChildren); // hook in; . DOWN .+\n\n        StateCluster up = build_Atom(Label.UP, associatedAST);\n        wildRoot = build_AB(wildRoot,up); // hook in; . DOWN .+ UP\n\n        // make optional . alt\n        StateCluster optionalNodeAlt = build_Wildcard(associatedAST);\n\n        List<StateCluster> alts = new ArrayList<StateCluster>();\n        alts.add(wildRoot);\n        alts.add(optionalNodeAlt);\n        StateCluster blk = build_AlternativeBlock(alts);\n\n        return blk;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Build a subrule matching ^(. .", "call_func_name": ["org.antlr.tool.NFAFactory.build_Wildcard", "org.antlr.tool.NFAFactory.build_Atom", "org.antlr.tool.NFAFactory.build_AB", "org.antlr.tool.NFAFactory.build_Aplus", "java.util.ArrayList.<init>", "java.util.List.add", "org.antlr.tool.NFAFactory.build_AlternativeBlock"], "call_func_parameter": [["org.antlr.tool.GrammarAST"], ["int", "org.antlr.tool.GrammarAST"], ["org.antlr.analysis.StateCluster", "org.antlr.analysis.StateCluster"], ["org.antlr.analysis.StateCluster"], [""], ["java.lang.Object"], ["java.util.List"]], "passed_comments": [{"org.antlr.tool.NFAFactory.build_Wildcard": "Build an atom with all possible values in its label"}, {"org.antlr.tool.NFAFactory.build_Atom": "From label A build Graph o-A-&gt;o"}, {"org.antlr.tool.NFAFactory.build_AB": "From A B build A-e-&gt;B (that is, build an epsilon arc from right of A to left of B). As a convenience, return B if A is null or return A if B is null."}, {"org.antlr.tool.NFAFactory.build_Aplus": "From (A)+ build |---|    (Transition 2 from A.right points at alt 1) v   |    (follow of loop is Transition 1) o-&gt;o-A-o-&gt;o Meaning that the last NFAState in A points back to A's left Transition NFAState and we add a new begin/end NFAState.  A can be single alternative or multiple. During analysis we'll call the follow link (transition 1) alt n+1 for an n-alt A block."}, {"org.antlr.tool.NFAFactory.build_AlternativeBlock": "From A|B|..|Z alternative block build o-&gt;o-A-&gt;o-&gt;o (last NFAState is blockEndNFAState pointed to by all alts) |          ^ o-&gt;o-B-&gt;o--| |          | ...        | |          | o-&gt;o-Z-&gt;o--| So every alternative gets begin NFAState connected by epsilon and every alt right side points at a block end NFAState.  There is a new NFAState in the NFAState in the StateCluster for each alt plus one for the end NFAState. Special case: only one alternative: don't make a block with alt begin/end. Special case: if just a list of tokens/chars/sets, then collapse to a single edge'd o-set-&gt;o graph. Set alt number (1..n) in the left-Transition NFAState."}]}, {"index": "695", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/NFAFactory.java", "methodName": "org.antlr.tool.NFAFactory.getCollapsedBlockAsSet", "methodParameterType": "State#", "methodParameterName": "blk#", "methodBody": "protected IntSet getCollapsedBlockAsSet(State blk) {\n        State s0 = blk;\n        if ( s0!=null && s0.transition(0)!=null ) {\n            State s1 = s0.transition(0).target;\n            if ( s1!=null && s1.transition(0)!=null ) {\n                Label label = s1.transition(0).label;\n                if ( label.isSet() ) {\n                    return label.getSet();\n                }\n            }\n        }\n        return null;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#Block#IfStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement)Block)IfStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a collapsed block of alts (a set of atoms), pull out the set and return it.", "call_func_name": ["org.antlr.analysis.State.transition", "org.antlr.analysis.Label.isSet", "org.antlr.analysis.Label.getSet"], "call_func_parameter": [["int"], [""], [""]], "passed_comments": "/"}, {"index": "696", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammarTree.java", "methodName": "org.antlr.tool.CompositeGrammarTree.getRule", "methodParameterType": "String#", "methodParameterName": "ruleName#", "methodBody": "public Rule getRule(String ruleName) {\n\t\tRule r = grammar.getLocallyDefinedRule(ruleName);\n\t\tfor (int i = 0; r==null && children!=null && i < children.size(); i++) {\n\t\t\tCompositeGrammarTree child = children.get(i);\n\t\t\tr = child.getRule(ruleName);\n\t\t}\n\t\treturn r;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Find a rule by looking in current grammar then down towards the delegate grammars.", "call_func_name": ["org.antlr.tool.Grammar.getLocallyDefinedRule", "java.util.List.size", "java.util.List.get", "org.antlr.tool.CompositeGrammarTree.getRule"], "call_func_parameter": [["java.lang.String"], [""], ["int"], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree.getRule": "Find a rule by looking in current grammar then down towards the delegate grammars."}]}, {"index": "697", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammarTree.java", "methodName": "org.antlr.tool.CompositeGrammarTree.getOption", "methodParameterType": "String#", "methodParameterName": "key#", "methodBody": "public Object getOption(String key) {\n\t\tif ( grammar.tool!=null && key!=null && key.equals(\"language\") &&\n\t\t\t grammar.tool.forcedLanguageOption!=null ) {\n\t\t\treturn grammar.tool.forcedLanguageOption;\n\t\t}\n\t\tObject o = grammar.getLocallyDefinedOption(key);\n\t\tif ( o!=null ) {\n\t\t\treturn o;\n\t\t}\n\t\tif ( parent!=null ) {\n\t\t\treturn parent.getOption(key);\n\t\t}\n\t\treturn null; // not found\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Find an option by looking up towards the root grammar rather than down", "call_func_name": ["java.lang.String.equals", "org.antlr.tool.Grammar.getLocallyDefinedOption", "org.antlr.tool.CompositeGrammarTree.getOption"], "call_func_parameter": [["java.lang.Object"], ["java.lang.String"], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree.getOption": "Find an option by looking up towards the root grammar rather than down"}]}, {"index": "698", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammarTree.java", "methodName": "org.antlr.tool.CompositeGrammarTree.getPostOrderedGrammarList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Grammar> getPostOrderedGrammarList() {\n\t\tList<Grammar> grammars = new ArrayList<Grammar>();\n\t\t_getPostOrderedGrammarList(grammars);\n\t\treturn grammars;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a postorder list of grammars; root is last in list", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.CompositeGrammarTree._getPostOrderedGrammarList"], "call_func_parameter": [[""], ["java.util.List"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree._getPostOrderedGrammarList": "work for getPostOrderedGrammarList"}]}, {"index": "699", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammarTree.java", "methodName": "org.antlr.tool.CompositeGrammarTree._getPostOrderedGrammarList", "methodParameterType": "List<Grammar>#", "methodParameterName": "grammars#", "methodBody": "protected void _getPostOrderedGrammarList(List<Grammar> grammars) {\n\t\tfor (int i = 0; children!=null && i < children.size(); i++) {\n\t\t\tCompositeGrammarTree child = children.get(i);\n\t\t\tchild._getPostOrderedGrammarList(grammars);\n\t\t}\n\t\tgrammars.add(this.grammar);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#ThisExpression#SimpleName#FieldAccess#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "work for getPostOrderedGrammarList", "call_func_name": ["java.util.List.size", "java.util.List.get", "org.antlr.tool.CompositeGrammarTree._getPostOrderedGrammarList", "java.util.List.add"], "call_func_parameter": [[""], ["int"], ["java.util.List"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.tool.CompositeGrammarTree._getPostOrderedGrammarList": "work for getPostOrderedGrammarList"}]}, {"index": "700", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/CompositeGrammarTree.java", "methodName": "org.antlr.tool.CompositeGrammarTree.getPreOrderedGrammarList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Grammar> getPreOrderedGrammarList() {\n\t\tList<Grammar> grammars = new ArrayList<Grammar>();\n\t\t_getPreOrderedGrammarList(grammars);\n\t\treturn grammars;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a preorder list of grammars; root is first in list", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.CompositeGrammarTree._getPreOrderedGrammarList"], "call_func_parameter": [[""], ["java.util.List"]], "passed_comments": "/"}, {"index": "701", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java", "methodName": "org.antlr.tool.BuildDependencyGenerator.getGeneratedFileList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<File> getGeneratedFileList() {\n        List<File> files = new ArrayList<File>();\n        File outputDir = tool.getOutputDirectory(grammarFileName);\n        if (outputDir.getName().equals(\".\")) {\n            outputDir = outputDir.getParentFile();\n        } else if (outputDir.getName().indexOf(' ') >= 0) { // has spaces?\n            String escSpaces = Utils.replace(outputDir.toString(),\n                    \" \",\n                    \"\\\\ \");\n            outputDir = new File(escSpaces);\n        }\n        // add generated recognizer; e.g., TParser.java\n        String recognizer =\n                generator.getRecognizerFileName(grammar.name, grammar.type);\n        files.add(new File(outputDir, recognizer));\n        // add output vocab file; e.g., T.tokens. This is always generated to\n        // the base output directory, which will be just . if there is no -o option\n        //\n        files.add(new File(tool.getOutputDirectory(), generator.getVocabFileName()));\n        // are we generating a .h file?\n        ST headerExtST = null;\n        ST extST = generator.getTemplates().getInstanceOf(\"codeFileExtension\");\n        if (generator.getTemplates().isDefined(\"headerFile\")) {\n            headerExtST = generator.getTemplates().getInstanceOf(\"headerFileExtension\");\n            String suffix = Grammar.grammarTypeToFileNameSuffix[grammar.type];\n            String fileName = grammar.name + suffix + headerExtST.render();\n            files.add(new File(outputDir, fileName));\n        }\n        if (grammar.type == Grammar.COMBINED) {\n            // add autogenerated lexer; e.g., TLexer.java TLexer.h TLexer.tokens\n            // don't add T__.g (just a temp file)\n            \n            String suffix = Grammar.grammarTypeToFileNameSuffix[Grammar.LEXER];\n            String lexer = grammar.name + suffix + extST.render();\n            files.add(new File(outputDir, lexer));\n\n            // TLexer.h\n            if (headerExtST != null) {\n                String header = grammar.name + suffix + headerExtST.render();\n                files.add(new File(outputDir, header));\n            }\n        // for combined, don't generate TLexer.tokens\n        }\n\n        // handle generated files for imported grammars\n        List<Grammar> imports =\n                grammar.composite.getDelegates(grammar.composite.getRootGrammar());\n        for (Grammar g : imports) {\n            outputDir = tool.getOutputDirectory(g.getFileName());\n            String fname = groomQualifiedFileName(outputDir.toString(), g.getRecognizerName() + extST.render());\n            files.add(new File(fname));\n        }\n\n        if (files.isEmpty()) {\n            return null;\n        }\n        return files;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#CharacterLiteral#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#StringLiteral#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From T.g return a list of File objects that name files ANTLR will emit from T.g.", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.Tool.getOutputDirectory", "java.io.File.getName", "java.lang.String.equals", "java.io.File.getParentFile", "java.lang.String.indexOf", "java.io.File.toString", "org.antlr.misc.Utils.replace", "java.io.File.<init>", "org.antlr.codegen.CodeGenerator.getRecognizerFileName", "java.io.File.<init>", "java.util.List.add", "org.antlr.Tool.getOutputDirectory", "org.antlr.codegen.CodeGenerator.getVocabFileName", "java.io.File.<init>", "org.antlr.codegen.CodeGenerator.getTemplates", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.stringtemplate.v4.STGroup.isDefined", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.stringtemplate.v4.ST.render", "java.lang.StringBuilder.toString", "org.antlr.tool.CompositeGrammar.getRootGrammar", "org.antlr.tool.CompositeGrammar.getDelegates", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getFileName", "org.antlr.tool.Grammar.getRecognizerName", "org.antlr.tool.BuildDependencyGenerator.groomQualifiedFileName", "java.util.List.isEmpty"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["java.lang.Object"], [""], ["int"], [""], ["java.lang.String", "java.lang.String", "java.lang.String"], ["java.lang.String"], ["java.lang.String", "int"], ["java.io.File", "java.lang.String"], ["java.lang.Object"], [""], [""], ["java.lang.String", "java.lang.String"], [""], ["java.lang.String"], ["java.lang.String"], [""], ["java.lang.String"], [""], [""], [""], ["org.antlr.tool.Grammar"], [""], [""], [""], [""], [""], ["java.lang.String", "java.lang.String"], [""]], "passed_comments": [{"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}, {"org.antlr.misc.Utils.replace": "Given a source string, src, a string to replace, replacee, and a string to replace with, replacer, return a new string w/ the replacing done. You can use replacer==null to remove replacee from the string. This should be faster than Java's String.replaceAll as that one uses regex (I only want to play with strings anyway)."}, {"org.antlr.codegen.CodeGenerator.getRecognizerFileName": "Generate TParser.java and TLexer.java from T.g if combined, else just use T.java as output regardless of type."}, {"org.antlr.Tool.getOutputDirectory": "Return the location where ANTLR will generate output files for a given file. This is a base directory and output files will be relative to here in some cases such as when -o option is used and input files are given relative to the input directory."}, {"org.antlr.Tool.getOutputDirectory": "Return the Path to the base output directory, where ANTLR will generate all the output files for the current language target as well as any ancillary files such as .tokens vocab files."}, {"org.antlr.codegen.CodeGenerator.getVocabFileName": "What is the name of the vocab file generated for this grammar? Returns null if no .tokens file should be generated."}, {"org.antlr.tool.CompositeGrammar.getDelegates": "Get list of all delegates from all grammars in the delegate subtree of g. The grammars are in delegation tree preorder.  Don't include g itself in list as it is not a delegate of itself."}, {"org.antlr.tool.Grammar.getRecognizerName": "Get the name of the generated recognizer; may or may not be same as grammar name. Recognizer is TParser and TLexer from T if combined, else just use T regardless of grammar type."}]}, {"index": "702", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java", "methodName": "org.antlr.tool.BuildDependencyGenerator.getDependenciesFileList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<File> getDependenciesFileList() {\n        // Find all the things other than imported grammars\n        List<File> files = getNonImportDependenciesFileList();\n\n        // Handle imported grammars\n        List<Grammar> imports =\n                grammar.composite.getDelegates(grammar.composite.getRootGrammar());\n        for (Grammar g : imports) {\n            String libdir = tool.getLibraryDirectory();\n            String fileName = groomQualifiedFileName(libdir, g.fileName);\n            files.add(new File(fileName));\n        }\n\n        if (files.isEmpty()) {\n            return null;\n        }\n        return files;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of File objects that name files ANTLR will read to process T.g; This can be .tokens files if the grammar uses the tokenVocab option as well as any imported grammar files.", "call_func_name": ["org.antlr.tool.BuildDependencyGenerator.getNonImportDependenciesFileList", "org.antlr.tool.CompositeGrammar.getRootGrammar", "org.antlr.tool.CompositeGrammar.getDelegates", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.Tool.getLibraryDirectory", "org.antlr.tool.BuildDependencyGenerator.groomQualifiedFileName", "java.io.File.<init>", "java.util.List.add", "java.util.List.isEmpty"], "call_func_parameter": [[""], [""], ["org.antlr.tool.Grammar"], [""], [""], [""], [""], ["java.lang.String", "java.lang.String"], ["java.lang.String"], ["java.lang.Object"], [""]], "passed_comments": [{"org.antlr.tool.BuildDependencyGenerator.getNonImportDependenciesFileList": "Return a list of File objects that name files ANTLR will read to process T.g; This can only be .tokens files and only if they use the tokenVocab option."}, {"org.antlr.tool.CompositeGrammar.getDelegates": "Get list of all delegates from all grammars in the delegate subtree of g. The grammars are in delegation tree preorder.  Don't include g itself in list as it is not a delegate of itself."}, {"org.antlr.Tool.getLibraryDirectory": "Return the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files."}]}, {"index": "703", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/BuildDependencyGenerator.java", "methodName": "org.antlr.tool.BuildDependencyGenerator.getNonImportDependenciesFileList", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<File> getNonImportDependenciesFileList() {\n        List<File> files = new ArrayList<File>();\n\n        // handle token vocabulary loads\n        tokenVocab = (String) grammar.getOption(\"tokenVocab\");\n        if (tokenVocab != null) {\n\n            File vocabFile = tool.getImportedVocabFile(tokenVocab);\n            files.add(vocabFile);\n        }\n\n        return files;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of File objects that name files ANTLR will read to process T.g; This can only be .tokens files and only if they use the tokenVocab option.", "call_func_name": ["java.util.ArrayList.<init>", "org.antlr.tool.Grammar.getOption", "org.antlr.Tool.getImportedVocabFile", "java.util.List.add"], "call_func_parameter": [[""], ["java.lang.String"], ["java.lang.String"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.Tool.getImportedVocabFile": "Return a File descriptor for vocab file.  Look in library or in -o output path.  antlr -o foo T.g U.g where U needs T.tokens won't work unless we look in foo too. If we do not find the file in the lib directory then must assume that the .tokens file is going to be generated as part of this build and we have defined .tokens files so that they ALWAYS are generated in the base output directory, which means the current directory for the command line tool if there was no output directory specified."}]}, {"index": "704", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarSanity.java", "methodName": "org.antlr.tool.GrammarSanity.checkAllRulesForLeftRecursion", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Set<Rule>> checkAllRulesForLeftRecursion() {\n\t\tgrammar.buildNFA(); // make sure we have NFAs\n\t\tgrammar.leftRecursiveRules = new HashSet<Rule>();\n\t\tList<Set<Rule>> listOfRecursiveCycles = new ArrayList<Set<Rule>>();\n\t\tfor (int i = 0; i < grammar.composite.ruleIndexToRuleList.size(); i++) {\n\t\t\tRule r = grammar.composite.ruleIndexToRuleList.elementAt(i);\n\t\t\tif ( r!=null ) {\n\t\t\t\tvisitedDuringRecursionCheck = new HashSet<Rule>();\n\t\t\t\tvisitedDuringRecursionCheck.add(r);\n\t\t\t\tSet<NFAState> visitedStates = new HashSet<NFAState>();\n\t\t\t\ttraceStatesLookingForLeftRecursion(r.startState,\n\t\t\t\t\t\t\t\t\t\t\t\t   visitedStates,\n\t\t\t\t\t\t\t\t\t\t\t\t   listOfRecursiveCycles);\n\t\t\t}\n\t\t}\n\t\tif ( listOfRecursiveCycles.size()>0 ) {\n\t\t\tErrorManager.leftRecursionCycles(listOfRecursiveCycles);\n\t\t}\n\t\treturn listOfRecursiveCycles;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Check all rules for infinite left recursion before analysis. Return list of troublesome rule cycles.  This method has two side-effects: it notifies the error manager that we have problems and it sets the list of recursive rules that we should ignore during analysis.", "call_func_name": ["org.antlr.tool.Grammar.buildNFA", "java.util.HashSet.<init>", "java.util.ArrayList.<init>", "java.util.Vector.size", "java.util.Vector.elementAt", "java.util.Set.add", "org.antlr.tool.GrammarSanity.traceStatesLookingForLeftRecursion", "java.util.List.size", "org.antlr.tool.ErrorManager.leftRecursionCycles"], "call_func_parameter": [[""], [""], [""], [""], ["int"], ["java.lang.Object"], ["org.antlr.analysis.NFAState", "java.util.Set", "java.util.List"], [""], ["java.util.Collection"]], "passed_comments": [{"org.antlr.tool.GrammarSanity.traceStatesLookingForLeftRecursion": "From state s, look for any transition to a rule that is currently being traced.  When tracing r, visitedDuringRecursionCheck has r initially.  If you reach an accept state, return but notify the invoking rule that it is nullable, which implies that invoking rule must look at follow transition for that invoking state. The visitedStates tracks visited states within a single rule so we can avoid epsilon-loop-induced infinite recursion here.  Keep filling the cycles in listOfRecursiveCycles and also, as a side-effect, set leftRecursiveRules."}]}, {"index": "705", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarSanity.java", "methodName": "org.antlr.tool.GrammarSanity.traceStatesLookingForLeftRecursion", "methodParameterType": "NFAState#Set<NFAState>#List<Set<Rule>>#", "methodParameterName": "s#visitedStates#listOfRecursiveCycles#", "methodBody": "protected boolean traceStatesLookingForLeftRecursion(NFAState s,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t Set<NFAState> visitedStates,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t List<Set<Rule>> listOfRecursiveCycles)\n\t{\n\t\tif ( s.isAcceptState() ) {\n\t\t\t// this rule must be nullable!\n\t\t\t// At least one epsilon edge reached accept state\n\t\t\treturn true;\n\t\t}\n\t\tif ( visitedStates.contains(s) ) {\n\t\t\t// within same rule, we've hit same state; quit looping\n\t\t\treturn false;\n\t\t}\n\t\tvisitedStates.add(s);\n\t\tboolean stateReachesAcceptState = false;\n\t\tTransition t0 = s.transition[0];\n\t\tif ( t0 instanceof RuleClosureTransition ) {\n\t\t\tRuleClosureTransition refTrans = (RuleClosureTransition)t0;\n\t\t\tRule refRuleDef = refTrans.rule;\n\t\t\t//String targetRuleName = ((NFAState)t0.target).getEnclosingRule();\n\t\t\tif ( visitedDuringRecursionCheck.contains(refRuleDef) ) {\n\t\t\t\t// record left-recursive rule, but don't go back in\n\t\t\t\tgrammar.leftRecursiveRules.add(refRuleDef);\n\t\t\t\t/*\n\t\t\t\tSystem.out.println(\"already visited \"+refRuleDef+\", calling from \"+\n\t\t\t\t\t\t\t\t   s.enclosingRule);\n\t\t\t\t\t\t\t\t   */\n\t\t\t\taddRulesToCycle(refRuleDef,\n\t\t\t\t\t\t\t\ts.enclosingRule,\n\t\t\t\t\t\t\t\tlistOfRecursiveCycles);\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// must visit if not already visited; send new visitedStates set\n\t\t\t\tvisitedDuringRecursionCheck.add(refRuleDef);\n\t\t\t\tboolean callReachedAcceptState =\n\t\t\t\t\ttraceStatesLookingForLeftRecursion((NFAState)t0.target,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   new HashSet<NFAState>(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t   listOfRecursiveCycles);\n\t\t\t\t// we're back from visiting that rule\n\t\t\t\tvisitedDuringRecursionCheck.remove(refRuleDef);\n\t\t\t\t// must keep going in this rule then\n\t\t\t\tif ( callReachedAcceptState ) {\n\t\t\t\t\tNFAState followingState =\n\t\t\t\t\t\t((RuleClosureTransition) t0).followState;\n\t\t\t\t\tstateReachesAcceptState |=\n\t\t\t\t\t\ttraceStatesLookingForLeftRecursion(followingState,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   visitedStates,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t   listOfRecursiveCycles);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if ( t0.label.isEpsilon() || t0.label.isSemanticPredicate() ) {\n\t\t\tstateReachesAcceptState |=\n\t\t\t\ttraceStatesLookingForLeftRecursion((NFAState)t0.target, visitedStates, listOfRecursiveCycles);\n\t\t}\n\t\t// else it has a labeled edge\n\n\t\t// now do the other transition if it exists\n\t\tTransition t1 = s.transition[1];\n\t\tif ( t1!=null ) {\n\t\t\tstateReachesAcceptState |=\n\t\t\t\ttraceStatesLookingForLeftRecursion((NFAState)t1.target,\n\t\t\t\t\t\t\t\t\t\t\t\t   visitedStates,\n\t\t\t\t\t\t\t\t\t\t\t\t   listOfRecursiveCycles);\n\t\t}\n\t\treturn stateReachesAcceptState;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#ParenthesizedExpression#SimpleName#FieldAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#Block#IfStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(FieldAccess(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)FieldAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)Block)IfStatement)Block(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From state s, look for any transition to a rule that is currently being traced.  When tracing r, visitedDuringRecursionCheck has r initially.  If you reach an accept state, return but notify the invoking rule that it is nullable, which implies that invoking rule must look at follow transition for that invoking state. The visitedStates tracks visited states within a single rule so we can avoid epsilon-loop-induced infinite recursion here.  Keep filling the cycles in listOfRecursiveCycles and also, as a side-effect, set leftRecursiveRules.", "call_func_name": ["org.antlr.analysis.NFAState.isAcceptState", "java.util.Set.contains", "java.util.Set.add", "org.antlr.tool.GrammarSanity.addRulesToCycle", "java.util.HashSet.<init>", "org.antlr.tool.GrammarSanity.traceStatesLookingForLeftRecursion", "java.util.Set.remove", "org.antlr.analysis.Label.isEpsilon", "org.antlr.analysis.Label.isSemanticPredicate"], "call_func_parameter": [[""], ["java.lang.Object"], ["java.lang.Object"], ["org.antlr.tool.Rule", "org.antlr.tool.Rule", "java.util.List"], [""], ["org.antlr.analysis.NFAState", "java.util.Set", "java.util.List"], ["java.lang.Object"], [""], [""]], "passed_comments": [{"org.antlr.tool.GrammarSanity.addRulesToCycle": "enclosingRuleName calls targetRuleName, find the cycle containing the target and add the caller.  Find the cycle containing the caller and add the target.  If no cycles contain either, then create a new cycle.  listOfRecursiveCycles is List&lt;Set&lt;String&gt;&gt; that holds a list of cycles (sets of rule names)."}, {"org.antlr.tool.GrammarSanity.traceStatesLookingForLeftRecursion": "From state s, look for any transition to a rule that is currently being traced.  When tracing r, visitedDuringRecursionCheck has r initially.  If you reach an accept state, return but notify the invoking rule that it is nullable, which implies that invoking rule must look at follow transition for that invoking state. The visitedStates tracks visited states within a single rule so we can avoid epsilon-loop-induced infinite recursion here.  Keep filling the cycles in listOfRecursiveCycles and also, as a side-effect, set leftRecursiveRules."}]}, {"index": "706", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarSanity.java", "methodName": "org.antlr.tool.GrammarSanity.addRulesToCycle", "methodParameterType": "Rule#Rule#List<Set<Rule>>#", "methodParameterName": "targetRule#enclosingRule#listOfRecursiveCycles#", "methodBody": "protected void addRulesToCycle(Rule targetRule,\n\t\t\t\t\t\t\t\t   Rule enclosingRule,\n\t\t\t\t\t\t\t\t   List<Set<Rule>> listOfRecursiveCycles)\n\t{\n\t\tboolean foundCycle = false;\n\t\tfor (int i = 0; i < listOfRecursiveCycles.size(); i++) {\n\t\t\tSet<Rule> rulesInCycle = listOfRecursiveCycles.get(i);\n\t\t\t// ensure both rules are in same cycle\n\t\t\tif ( rulesInCycle.contains(targetRule) ) {\n\t\t\t\trulesInCycle.add(enclosingRule);\n\t\t\t\tfoundCycle = true;\n\t\t\t}\n\t\t\tif ( rulesInCycle.contains(enclosingRule) ) {\n\t\t\t\trulesInCycle.add(targetRule);\n\t\t\t\tfoundCycle = true;\n\t\t\t}\n\t\t}\n\t\tif ( !foundCycle ) {\n\t\t\tSet<Rule> cycle = new HashSet<Rule>();\n\t\t\tcycle.add(targetRule);\n\t\t\tcycle.add(enclosingRule);\n\t\t\tlistOfRecursiveCycles.add(cycle);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "enclosingRuleName calls targetRuleName, find the cycle containing the target and add the caller.  Find the cycle containing the caller and add the target.  If no cycles contain either, then create a new cycle.  listOfRecursiveCycles is List&lt;Set&lt;String&gt;&gt; that holds a list of cycles (sets of rule names).", "call_func_name": ["java.util.List.size", "java.util.List.get", "java.util.Set.contains", "java.util.Set.add", "java.util.HashSet.<init>", "java.util.List.add"], "call_func_parameter": [[""], ["int"], ["java.lang.Object"], ["java.lang.Object"], [""], ["java.lang.Object"]], "passed_comments": "/"}, {"index": "707", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/GrammarSanity.java", "methodName": "org.antlr.tool.GrammarSanity.ensureAltIsSimpleNodeOrTree", "methodParameterType": "GrammarAST#GrammarAST#int#", "methodParameterName": "altAST#elementAST#outerAltNum#", "methodBody": "public void ensureAltIsSimpleNodeOrTree(GrammarAST altAST,\n\t\t\t\t\t\t\t\t\t\t\tGrammarAST elementAST,\n\t\t\t\t\t\t\t\t\t\t\tint outerAltNum)\n\t{\n\t\tif ( isValidSimpleElementNode(elementAST) ) {\n\t\t\tGrammarAST next = elementAST.getNextSibling();\n\t\t\tif ( !isNextNonActionElementEOA(next)) {\n\t\t\t\tErrorManager.grammarWarning(ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,\n\t\t\t\t\t\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\t\t\t\t\t\tnext.token,\n\t\t\t\t\t\t\t\t\t\t\touterAltNum);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\tswitch ( elementAST.getType() ) {\n\t\t\tcase ANTLRParser.ASSIGN :\t\t// labels ok on non-rule refs\n\t\t\tcase ANTLRParser.PLUS_ASSIGN :\n\t\t\t\tif ( isValidSimpleElementNode(elementAST.getChild(1)) ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase ANTLRParser.ACTION :\t\t// skip past actions\n\t\t\tcase ANTLRParser.SEMPRED :\n\t\t\tcase ANTLRParser.SYN_SEMPRED :\n\t\t\tcase ANTLRParser.BACKTRACK_SEMPRED :\n\t\t\tcase ANTLRParser.GATED_SEMPRED :\n\t\t\t\tensureAltIsSimpleNodeOrTree(altAST,\n\t\t\t\t\t\t\t\t\t\t\telementAST.getNextSibling(),\n\t\t\t\t\t\t\t\t\t\t\touterAltNum);\n\t\t\t\treturn;\n\t\t}\n\t\tErrorManager.grammarWarning(ErrorManager.MSG_REWRITE_FOR_MULTI_ELEMENT_ALT,\n\t\t\t\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\t\t\t\telementAST.token,\n\t\t\t\t\t\t\t\t\touterAltNum);\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ExpressionStatement#ReturnStatement#SwitchStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement(SwitchStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation(Block(ReturnStatement)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)SwitchStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Rules in tree grammar that use -&gt; rewrites and are spitting out templates via output=template and then use rewrite=true must only use -&gt; on alts that are simple nodes or trees or single rule refs that match either nodes or trees.  The altAST is the ALT node for an ALT.  Verify that its first child is simple.  Must be either ( ALT ^( A B ) &lt;end-of-alt&gt; ) or ( ALT A &lt;end-of-alt&gt; ) or other element. Ignore predicates in front and labels.", "call_func_name": ["org.antlr.tool.GrammarSanity.isValidSimpleElementNode", "org.antlr.tool.GrammarAST.getNextSibling", "org.antlr.tool.GrammarSanity.isNextNonActionElementEOA", "java.lang.Integer.valueOf", "org.antlr.tool.ErrorManager.grammarWarning", "org.antlr.tool.GrammarAST.getType", "org.antlr.tool.GrammarAST.getChild", "org.antlr.tool.GrammarSanity.ensureAltIsSimpleNodeOrTree"], "call_func_parameter": [["org.antlr.runtime.tree.Tree"], [""], ["org.antlr.tool.GrammarAST"], ["int"], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], [""], ["int"], ["org.antlr.tool.GrammarAST", "org.antlr.tool.GrammarAST", "int"]], "passed_comments": [{"org.antlr.tool.GrammarSanity.ensureAltIsSimpleNodeOrTree": "Rules in tree grammar that use -&gt; rewrites and are spitting out templates via output=template and then use rewrite=true must only use -&gt; on alts that are simple nodes or trees or single rule refs that match either nodes or trees.  The altAST is the ALT node for an ALT.  Verify that its first child is simple.  Must be either ( ALT ^( A B ) &lt;end-of-alt&gt; ) or ( ALT A &lt;end-of-alt&gt; ) or other element. Ignore predicates in front and labels."}]}, {"index": "708", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/RandomPhrase.java", "methodName": "org.antlr.tool.RandomPhrase.randomPhrase", "methodParameterType": "Grammar#List<Integer>#String#", "methodParameterName": "g#tokenTypes#startRule#", "methodBody": "protected static void randomPhrase(Grammar g, List<Integer> tokenTypes, String startRule) {\n\t\tNFAState state = g.getRuleStartState(startRule);\n\t\tNFAState stopState = g.getRuleStopState(startRule);\n\n\t\tStack<NFAState> ruleInvocationStack = new Stack<NFAState>();\n\t\twhile ( true ) {\n\t\t\tif ( state==stopState && ruleInvocationStack.isEmpty() ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( debug ) System.out.println(\"state \"+state);\n\t\t\tif ( state.getNumberOfTransitions()==0 ) {\n\t\t\t\tif ( debug ) System.out.println(\"dangling state: \"+state);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// end of rule node\n\t\t\tif ( state.isAcceptState() ) {\n\t\t\t\tNFAState invokingState = ruleInvocationStack.pop();\n\t\t\t\tif ( debug ) System.out.println(\"pop invoking state \"+invokingState);\n\t\t\t\t//System.out.println(\"leave \"+state.enclosingRule.name);\n\t\t\t\tRuleClosureTransition invokingTransition =\n\t\t\t\t\t(RuleClosureTransition)invokingState.transition[0];\n\t\t\t\t// move to node after state that invoked this rule\n\t\t\t\tstate = invokingTransition.followState;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ( state.getNumberOfTransitions()==1 ) {\n\t\t\t\t// no branching, just take this path\n\t\t\t\tTransition t0 = state.transition[0];\n\t\t\t\tif ( t0 instanceof RuleClosureTransition ) {\n\t\t\t\t\truleInvocationStack.push(state);\n\t\t\t\t\tif ( debug ) System.out.println(\"push state \"+state);\n\t\t\t\t\t//System.out.println(\"call \"+((RuleClosureTransition)t0).rule.name);\n\t\t\t\t\t//System.out.println(\"stack depth=\"+ruleInvocationStack.size());\n\t\t\t\t}\n\t\t\t\telse if ( t0.label.isSet() || t0.label.isAtom() ) {\n\t\t\t\t\ttokenTypes.add( getTokenType(t0.label) );\n\t\t\t\t}\n\t\t\t\tstate = (NFAState)t0.target;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tint decisionNumber = state.getDecisionNumber();\n\t\t\tif ( decisionNumber==0 ) {\n\t\t\t\tSystem.out.println(\"weird: no decision number but a choice node\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t// decision point, pick ith alternative randomly\n\t\t\tint n = g.getNumberOfAltsForDecisionNFA(state);\n\t\t\tint randomAlt = random.nextInt(n) + 1;\n\t\t\tif ( debug ) System.out.println(\"randomAlt=\"+randomAlt);\n\t\t\tNFAState altStartState =\n\t\t\t\tg.getNFAStateForAltOfDecision(state, randomAlt);\n\t\t\tTransition t = altStartState.transition[0];\n\t\t\tstate = (NFAState)t.target;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#BooleanLiteral#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#BreakStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#InstanceofExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#ContinueStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#ContinueStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#Assignment#ExpressionStatement#Block#WhileStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(BooleanLiteral)BooleanLiteral(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(BreakStatement)BreakStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement)Block(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ContinueStatement)ContinueStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)Assignment)ExpressionStatement)Block)WhileStatement)Block)MethodDeclaration", "methodDoc": "an experimental method to generate random phrases for a given grammar given a start rule.  Return a list of token types.", "call_func_name": ["org.antlr.tool.Grammar.getRuleStartState", "org.antlr.tool.Grammar.getRuleStopState", "java.util.Stack.<init>", "java.util.Stack.isEmpty", "org.antlr.analysis.NFAState.getNumberOfTransitions", "org.antlr.analysis.NFAState.isAcceptState", "java.util.Stack.pop", "java.util.Stack.push", "org.antlr.analysis.Label.isSet", "org.antlr.analysis.Label.isAtom", "org.antlr.tool.RandomPhrase.getTokenType", "java.util.List.add", "org.antlr.analysis.NFAState.getDecisionNumber", "java.io.PrintStream.println", "org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA", "java.util.Random.nextInt", "org.antlr.tool.Grammar.getNFAStateForAltOfDecision"], "call_func_parameter": [["java.lang.String"], ["java.lang.String"], [""], [""], [""], [""], [""], ["java.lang.Object"], [""], [""], ["org.antlr.analysis.Label"], ["java.lang.Object"], [""], ["java.lang.String"], ["org.antlr.analysis.NFAState"], ["int"], ["org.antlr.analysis.NFAState", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getNumberOfAltsForDecisionNFA": "Decisions are linked together with transition(1).  Count how many there are.  This is here rather than in NFAState because a grammar decides how NFAs are put together to form a decision."}, {"org.antlr.tool.Grammar.getNFAStateForAltOfDecision": "Get the ith alternative (1..n) from a decision; return null when an invalid alt is requested.  I must count in to find the right alternative number.  For (A|B), you get NFA structure (roughly): o-&gt;o-A-&gt;o | o-&gt;o-B-&gt;o This routine returns the leftmost state for each alt.  So alt=1, returns the upperleft most state in this structure."}]}, {"index": "709", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/tool/RandomPhrase.java", "methodName": "org.antlr.tool.RandomPhrase.main", "methodParameterType": "String[]#", "methodParameterName": "args#", "methodBody": "public static void main(String[] args) {\n\t\tif ( args.length < 2 ) {\n\t\t\tSystem.err.println(\"usage: java org.antlr.tool.RandomPhrase grammarfile startrule\");\n\t\t\treturn;\n\t\t}\n\t\tString grammarFileName = args[0];\n\t\tString startRule = args[1];\n\t\tlong seed = System.currentTimeMillis(); // use random seed unless spec.\n\t\tif ( args.length==3 ) {\n\t\t\tString seedStr = args[2];\n\t\t\tseed = Long.parseLong(seedStr);\n\t\t}\n\t\ttry {\n\t\t\trandom = new Random(seed);\n\n\t\t\tCompositeGrammar composite = new CompositeGrammar();\n\t\t\tTool tool = new Tool();\n\t\t\tGrammar parser = new Grammar(tool, grammarFileName, composite);\n\t\t\tcomposite.setDelegationRoot(parser);\n\n\t\t\tFileReader fr = new FileReader(grammarFileName);\n\t\t\tBufferedReader br = new BufferedReader(fr);\n\t\t\tparser.parseAndBuildAST(br);\n\t\t\tbr.close();\n\n\t\t\tparser.composite.assignTokenTypes();\n\t\t\tparser.composite.defineGrammarSymbols();\n\t\t\tparser.composite.createNFAs();\n\n\t\t\tList<? extends Collection<? extends Rule>> leftRecursiveRules = parser.checkAllRulesForLeftRecursion();\n\t\t\tif ( leftRecursiveRules.size()>0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( parser.getRule(startRule)==null ) {\n\t\t\t\tSystem.out.println(\"undefined start rule \"+startRule);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tString lexerGrammarText = parser.getLexerGrammar();\n\t\t\tGrammar lexer = new Grammar(tool);\n\t\t\tlexer.importTokenVocabulary(parser);\n\t\t\tlexer.fileName = grammarFileName;\n\t\t\tif ( lexerGrammarText!=null ) {\n\t\t\t\tlexer.setGrammarContent(lexerGrammarText);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSystem.err.println(\"no lexer grammar found in \"+grammarFileName);\n\t\t\t}\n\t\t\tlexer.buildNFA();\n\t\t\tleftRecursiveRules = lexer.checkAllRulesForLeftRecursion();\n\t\t\tif ( leftRecursiveRules.size()>0 ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//System.out.println(\"lexer:\\n\"+lexer);\n\n\t\t\tList<Integer> tokenTypes = new ArrayList<Integer>(100);\n\t\t\trandomPhrase(parser, tokenTypes, startRule);\n\t\t\tSystem.out.println(\"token types=\"+tokenTypes);\n\t\t\tfor (int i = 0; i < tokenTypes.size(); i++) {\n\t\t\t\tInteger ttypeI = tokenTypes.get(i);\n\t\t\t\tint ttype = ttypeI;\n\t\t\t\tString ttypeDisplayName = parser.getTokenDisplayName(ttype);\n\t\t\t\tif ( Character.isUpperCase(ttypeDisplayName.charAt(0)) ) {\n\t\t\t\t\tList<Integer> charsInToken = new ArrayList<Integer>(10);\n\t\t\t\t\trandomPhrase(lexer, charsInToken, ttypeDisplayName);\n\t\t\t\t\tSystem.out.print(\" \");\n\t\t\t\t\tfor (int j = 0; j < charsInToken.size(); j++) {\n\t\t\t\t\t\tInteger cI = charsInToken.get(j);\n\t\t\t\t\t\tSystem.out.print((char)cI.intValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse { // it's a literal\n\t\t\t\t\tString literal =\n\t\t\t\t\t\tttypeDisplayName.substring(1,ttypeDisplayName.length()-1);\n\t\t\t\t\tSystem.out.print(\" \"+literal);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tcatch (Error er) {\n\t\t\tSystem.err.println(\"Error walking \"+grammarFileName+\" rule \"+startRule+\" seed \"+seed);\n\t\t\ter.printStackTrace(System.err);\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tSystem.err.println(\"Exception walking \"+grammarFileName+\" rule \"+startRule+\" seed \"+seed);\n\t\t\te.printStackTrace(System.err);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#NumberLiteral#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#NumberLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#NumberLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#PrimitiveType#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(NumberLiteral)NumberLiteral)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(NumberLiteral)NumberLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(NumberLiteral)NumberLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation)ExpressionStatement)Block)ForStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)MethodDeclaration", "methodDoc": "Used to generate random strings", "call_func_name": ["java.io.PrintStream.println", "java.lang.System.currentTimeMillis", "java.lang.Long.parseLong", "java.util.Random.<init>", "org.antlr.tool.CompositeGrammar.<init>", "org.antlr.Tool.<init>", "org.antlr.tool.Grammar.<init>", "org.antlr.tool.CompositeGrammar.setDelegationRoot", "java.io.FileReader.<init>", "java.io.BufferedReader.<init>", "org.antlr.tool.Grammar.parseAndBuildAST", "java.io.BufferedReader.close", "org.antlr.tool.CompositeGrammar.assignTokenTypes", "org.antlr.tool.CompositeGrammar.defineGrammarSymbols", "org.antlr.tool.CompositeGrammar.createNFAs", "org.antlr.tool.Grammar.checkAllRulesForLeftRecursion", "java.util.List.size", "org.antlr.tool.Grammar.getRule", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.Grammar.getLexerGrammar", "org.antlr.tool.Grammar.<init>", "org.antlr.tool.Grammar.importTokenVocabulary", "org.antlr.tool.Grammar.setGrammarContent", "org.antlr.tool.Grammar.buildNFA", "java.util.ArrayList.<init>", "org.antlr.tool.RandomPhrase.randomPhrase", "java.lang.StringBuilder.append", "java.util.List.get", "java.lang.Integer.intValue", "org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt", "java.lang.Character.isUpperCase", "java.io.PrintStream.print", "java.io.PrintStream.print", "java.lang.String.length", "java.lang.String.substring", "java.io.PrintStream.println", "java.lang.StringBuilder.append", "java.lang.Error.printStackTrace", "java.lang.Exception.printStackTrace"], "call_func_parameter": [["java.lang.String"], [""], ["java.lang.String"], ["long"], [""], [""], ["org.antlr.Tool", "java.lang.String", "org.antlr.tool.CompositeGrammar"], ["org.antlr.tool.Grammar"], ["java.lang.String"], ["java.io.Reader"], ["java.io.Reader"], [""], [""], [""], [""], [""], [""], ["java.lang.String"], [""], ["java.lang.String"], [""], [""], ["org.antlr.Tool"], ["org.antlr.tool.Grammar"], ["java.lang.String"], [""], ["int"], ["org.antlr.tool.Grammar", "java.util.List", "java.lang.String"], ["java.lang.Object"], ["int"], [""], ["int"], ["int"], ["char"], ["java.lang.String"], ["char"], [""], ["int", "int"], [""], ["long"], ["java.io.PrintStream"], ["java.io.PrintStream"]], "passed_comments": [{"org.antlr.tool.Grammar.getLexerGrammar": "If the grammar is a combined grammar, return the text of the implicit lexer grammar."}, {"org.antlr.tool.Grammar.importTokenVocabulary": "Pull your token definitions from an existing grammar in memory. You must use Grammar() ctor then this method then setGrammarContent() to make this work.  This was useful primarily for testing and interpreting grammars until I added import grammar functionality. When you import a grammar you implicitly import its vocabulary as well and keep the same token type values. Returns the max token type found."}, {"org.antlr.tool.RandomPhrase.randomPhrase": "an experimental method to generate random phrases for a given grammar given a start rule.  Return a list of token types."}, {"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "710", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/ObjCTarget.java", "methodName": "org.antlr.codegen.ObjCTarget.getTargetStringLiteralFromANTLRStringLiteral", "methodParameterType": "CodeGenerator#String#", "methodParameterName": "generator#literal#", "methodBody": "@Override\n\tpublic String getTargetStringLiteralFromANTLRStringLiteral(CodeGenerator generator,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t   String literal)\n\t{\n\t\tliteral = Utils.replace(literal,\"\\\"\",\"\\\\\\\"\");\n\t\tStringBuilder buf = new StringBuilder(literal);\n\t\tbuf.setCharAt(0,'\"');\n\t\tbuf.setCharAt(literal.length()-1,'\"');\n\t\tbuf.insert(0,'@');\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert from an ANTLR string literal found in a grammar file to an equivalent string literal in the target language.  For Java, this is the translation 'a\\n\"' &rarr; \"a\\n\\\"\".  Expect single quotes around the incoming literal.  Just flip the quotes and replace double quotes with \\\"", "call_func_name": ["org.antlr.misc.Utils.replace", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.setCharAt", "java.lang.String.length", "java.lang.StringBuilder.insert", "java.lang.StringBuilder.toString"], "call_func_parameter": [["java.lang.String", "java.lang.String", "java.lang.String"], ["java.lang.String"], ["int", "char"], [""], ["int", "char"], [""]], "passed_comments": [{"org.antlr.misc.Utils.replace": "Given a source string, src, a string to replace, replacee, and a string to replace with, replacer, return a new string w/ the replacing done. You can use replacer==null to remove replacee from the string. This should be faster than Java's String.replaceAll as that one uses regex (I only want to play with strings anyway)."}]}, {"index": "711", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/ObjCTarget.java", "methodName": "org.antlr.codegen.ObjCTarget.getTokenTypeAsTargetLabel", "methodParameterType": "CodeGenerator#int#", "methodParameterName": "generator#ttype#", "methodBody": "@Override\n\tpublic String getTokenTypeAsTargetLabel(CodeGenerator generator, int ttype) {\n\t\tString name = generator.grammar.getTokenDisplayName(ttype);\n\t\t// If name is a literal, return the token type instead\n\t\tif ( name.charAt(0)=='\\'' ) {\n\t\t\treturn String.valueOf(ttype);\n\t\t}\n\t\treturn name;\n\t\t//return generator.grammar.name + Grammar.grammarTypeToFileNameSuffix[generator.grammar.type] + \"_\" + name;\n\t\t//return super.getTokenTypeAsTargetLabel(generator, ttype);\n\t\t//return this.getTokenTextAndTypeAsTargetLabel(generator, null, ttype);\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "If we have a label, prefix it with the recognizer's name", "call_func_name": ["org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt", "java.lang.String.valueOf"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "712", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/ObjCTarget.java", "methodName": "org.antlr.codegen.ObjCTarget.getTokenTextAndTypeAsTargetLabel", "methodParameterType": "CodeGenerator#String#int#", "methodParameterName": "generator#text#tokenType#", "methodBody": "public String getTokenTextAndTypeAsTargetLabel(CodeGenerator generator, String text, int tokenType) {\n\t\tString name = generator.grammar.getTokenDisplayName(tokenType);\n\t\t// If name is a literal, return the token type instead\n\t\tif ( name.charAt(0)=='\\'' ) {\n\t\t\treturn String.valueOf(tokenType);\n\t\t}\n\t\tString textEquivalent = text == null ? name : text;\n\t\tif (textEquivalent.charAt(0) >= '0' && textEquivalent.charAt(0) <= '9') {\n\t\t\treturn textEquivalent;\n\t\t} else {\n\t\t\treturn generator.grammar.name + Grammar.grammarTypeToFileNameSuffix[generator.grammar.type] + \"_\" + textEquivalent;\n\t\t}\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#ConditionalExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#ReturnStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#ArrayAccess#StringLiteral#SimpleName#InfixExpression#ReturnStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ConditionalExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)ConditionalExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block(Block(ReturnStatement(InfixExpression(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(ArrayAccess(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)ArrayAccess(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Target must be able to override the labels used for token types. Sometimes also depends on the token text.", "call_func_name": ["org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt", "java.lang.String.valueOf", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [["int"], ["int"], ["int"], [""], ["java.lang.String"], [""]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "713", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CppTarget.java", "methodName": "org.antlr.codegen.CppTarget.isValidActionScope", "methodParameterType": "int#String#", "methodParameterName": "grammarType#scope#", "methodBody": "@Override\n    public boolean isValidActionScope(int grammarType, String scope) {\n        switch (grammarType) {\n            case Grammar.LEXER:\n                if (scope.equals(\"lexer\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                if (scope.equals(\"namespace\")) {\n\t\t\t\t    return true;\n\t\t\t\t}\n\n                break;\n            case Grammar.PARSER:\n                if (scope.equals(\"parser\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n\t\t\t\tif (scope.equals(\"namespace\")) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n                break;\n            case Grammar.COMBINED:\n                if (scope.equals(\"parser\")) {\n                    return true;\n                }\n                if (scope.equals(\"lexer\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                if (scope.equals(\"namespace\")) {\n\t\t\t\t    return true;\n\t\t\t\t}\n\n                break;\n            case Grammar.TREE_PARSER:\n                if (scope.equals(\"treeparser\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                if (scope.equals(\"namespace\")) {\n\t\t\t\t    return true;\n\t\t\t\t}\n\t\t\t\tbreak;\n        }\n        return false;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SwitchStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SwitchStatement(SimpleName)SimpleName(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement)SwitchStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is scope in @scope::name {action} valid for this kind of grammar? Targets like C++ may want to allow new scopes like headerfile or some such.  The action names themselves are not policed at the moment so targets can add template actions w/o having to recompile ANTLR.", "call_func_name": ["java.lang.String.equals"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "714", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CppTarget.java", "methodName": "org.antlr.codegen.CppTarget.getTargetStringLiteralFromANTLRStringLiteral", "methodParameterType": "CodeGenerator#String#", "methodParameterName": "generator#literal#", "methodBody": "@Override\n    public String getTargetStringLiteralFromANTLRStringLiteral(\n            CodeGenerator generator,\n            String literal) {\n        int index;\n        String bytes;\n        StringBuffer buf = new StringBuffer();\n\n        buf.append(\"{ \");\n\n        // We need ot lose any escaped characters of the form \\x and just\n        // replace them with their actual values as well as lose the surrounding\n        // quote marks.\n        //\n        for (int i = 1; i < literal.length() - 1; i++) {\n            buf.append(\"0x\");\n\n            if (literal.charAt(i) == '\\\\') {\n                i++; // Assume that there is a next character, this will just yield\n                // invalid strings if not, which is what the input would be of course - invalid\n                switch (literal.charAt(i)) {\n                    case 'u':\n                    case 'U':\n                        buf.append(literal.substring(i + 1, i + 5));  // Already a hex string\n                        i = i + 5;                                // Move to next string/char/escape\n                        break;\n\n                    case 'n':\n                    case 'N':\n\n                        buf.append(\"0A\");\n                        break;\n\n                    case 'r':\n                    case 'R':\n\n                        buf.append(\"0D\");\n                        break;\n\n                    case 't':\n                    case 'T':\n\n                        buf.append(\"09\");\n                        break;\n\n                    case 'b':\n                    case 'B':\n\n                        buf.append(\"08\");\n                        break;\n\n                    case 'f':\n                    case 'F':\n\n                        buf.append(\"0C\");\n                        break;\n\n                    default:\n\n                        // Anything else is what it is!\n                        //\n                        buf.append(Integer.toHexString((int) literal.charAt(i)).toUpperCase());\n                        break;\n                }\n            } else {\n                buf.append(Integer.toHexString((int) literal.charAt(i)).toUpperCase());\n            }\n            buf.append(\", \");\n        }\n        buf.append(\" antlr3::ANTLR_STRING_TERMINATOR}\");\n\n        bytes = buf.toString();\n        index = strings.indexOf(bytes);\n\n        if (index == -1) {\n            strings.add(bytes);\n            index = strings.indexOf(bytes);\n        }\n\n        String strref = \"lit_\" + String.valueOf(index + 1);\n\n        return strref;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#BreakStatement#SwitchStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(SwitchStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement)SwitchStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert from an ANTLR string literal found in a grammar file to an equivalent string literal in the C target. Because we must support Unicode character sets and have chosen to have the lexer match UTF32 characters, then we must encode string matches to use 32 bit character arrays. Here then we must produce the C array and cater for the case where the lexer has been encoded with a string such as 'xyz\\n',", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.String.length", "java.lang.String.charAt", "java.lang.String.substring", "java.lang.Integer.toHexString", "java.lang.String.toUpperCase", "java.lang.StringBuffer.toString", "java.util.ArrayList.indexOf", "java.util.ArrayList.add", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.String.valueOf", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["int"], ["int", "int"], ["int"], [""], [""], ["java.lang.Object"], ["java.lang.Object"], [""], ["java.lang.String"], ["int"], [""]], "passed_comments": "/"}, {"index": "715", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CppTarget.java", "methodName": "org.antlr.codegen.CppTarget.performGrammarAnalysis", "methodParameterType": "CodeGenerator#Grammar#", "methodParameterName": "generator#grammar#", "methodBody": "@Override\n    protected void performGrammarAnalysis(CodeGenerator generator, Grammar grammar) {\n\n        // Check to see if the maximum inline DFA states is still set to\n        // the default size. If it is then whack it all the way up to the maximum that\n        // we can sensibly get away with.\n        //\n        if (CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE == CodeGenerator.MADSI_DEFAULT ) {\n\n            CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE = 65535;\n        }\n\n        // Check to see if the maximum switch size is still set to the default\n        // and bring it up much higher if it is. Modern C compilers can handle\n        // much bigger switch statements than say Java can and if anyone finds a compiler\n        // that cannot deal with such big switches, all the need do is generate the\n        // code with a reduced -Xmaxswitchcaselabels nnn\n        //\n        if  (CodeGenerator.MAX_SWITCH_CASE_LABELS == CodeGenerator.MSCL_DEFAULT) {\n\n            CodeGenerator.MAX_SWITCH_CASE_LABELS = 3000;\n        }\n\n        // Check to see if the number of transitions considered a miminum for using\n        // a switch is still at the default. Because a switch is still generally faster than\n        // an if even with small sets, and given that the optimizer will do the best thing with it\n        // anyway, then we simply want to generate a switch for any number of states.\n        //\n        if (CodeGenerator.MIN_SWITCH_ALTS == CodeGenerator.MSA_DEFAULT) {\n\n            CodeGenerator.MIN_SWITCH_ALTS = 1;\n        }\n\n        // Now we allow the superclass implementation to do whatever it feels it\n        // must do.\n        //\n        super.performGrammarAnalysis(generator, grammar);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Overrides the standard grammar analysis so we can prepare the analyser a little differently from the other targets. In particular we want to influence the way the code generator makes assumptions about switchs vs ifs, vs table driven DFAs. In general, C code should be generated that has the minimum use of tables, and tha meximum use of large switch statements. This allows the optimizers to generate very efficient code, it can reduce object code size by about 30% and give about a 20% performance improvement over not doing this. Hence, for the C target only, we change the defaults here, but only if they are still set to the defaults.", "call_func_name": ["org.antlr.codegen.Target.performGrammarAnalysis"], "call_func_parameter": [["org.antlr.codegen.CodeGenerator", "org.antlr.tool.Grammar"]], "passed_comments": "/"}, {"index": "716", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.loadTemplates", "methodParameterType": "String#", "methodParameterName": "language#", "methodBody": "public void loadTemplates(String language) {\n\t\tString langDir = classpathTemplateRootDirectoryName+\"/\"+language;\n\t\tSTGroup coreTemplates = new ToolSTGroupFile(langDir+\"/\"+language+\".stg\");\n\t\tbaseTemplates = coreTemplates;\n\n\t\t// dynamically add subgroups that act like filters to apply to\n\t\t// their supergroup.  E.g., Java:Dbg:AST:ASTParser::ASTDbg.\n\t\tString outputOption = (String)grammar.getOption(\"output\");\n\t\tif ( outputOption!=null && outputOption.equals(\"AST\") ) {\n\t\t\tif ( debug && grammar.type!=Grammar.LEXER ) {\n\t\t\t\tSTGroup dbgTemplates = new ToolSTGroupFile(langDir+\"/Dbg.stg\");\n\t\t\t\tdbgTemplates.importTemplates(coreTemplates);\n\t\t\t\tbaseTemplates = dbgTemplates;\n\t\t\t\tSTGroup astTemplates = new ToolSTGroupFile(langDir+\"/AST.stg\");\n\t\t\t\tastTemplates.importTemplates(dbgTemplates);\n\t\t\t\tSTGroup astParserTemplates;\n\t\t\t\tif ( grammar.type==Grammar.TREE_PARSER ) {\n\t\t\t\t\tastParserTemplates = new ToolSTGroupFile(langDir+\"/ASTTreeParser.stg\");\n\t\t\t\t\tastParserTemplates.importTemplates(astTemplates);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tastParserTemplates = new ToolSTGroupFile(langDir+\"/ASTParser.stg\");\n\t\t\t\t\tastParserTemplates.importTemplates(astTemplates);\n\t\t\t\t}\n\t\t\t\tSTGroup astDbgTemplates = new ToolSTGroupFile(langDir+\"/ASTDbg.stg\");\n\t\t\t\tastDbgTemplates.importTemplates(astParserTemplates);\n\t\t\t\ttemplates = astDbgTemplates;\n\t\t\t\tdbgTemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps\n\t\t\t\tastDbgTemplates.iterateAcrossValues = true;\n\t\t\t\tastParserTemplates.iterateAcrossValues = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSTGroup astTemplates = new ToolSTGroupFile(langDir+\"/AST.stg\");\n\t\t\t\tastTemplates.importTemplates(coreTemplates);\n\t\t\t\tSTGroup astParserTemplates;\n\t\t\t\tif ( grammar.type==Grammar.TREE_PARSER ) {\n\t\t\t\t\tastParserTemplates = new ToolSTGroupFile(langDir+\"/ASTTreeParser.stg\");\n\t\t\t\t\tastParserTemplates.importTemplates(astTemplates);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tastParserTemplates = new ToolSTGroupFile(langDir+\"/ASTParser.stg\");\n\t\t\t\t\tastParserTemplates.importTemplates(astTemplates);\n\t\t\t\t}\n\t\t\t\ttemplates = astParserTemplates;\n\t\t\t\tastTemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps\n\t\t\t\tastParserTemplates.iterateAcrossValues = true;\n\t\t\t}\n\t\t}\n\t\telse if ( outputOption!=null && outputOption.equals(\"template\") ) {\n\t\t\tif ( debug && grammar.type!=Grammar.LEXER ) {\n\t\t\t\tSTGroup dbgTemplates = new ToolSTGroupFile(langDir+\"/Dbg.stg\");\n\t\t\t\tdbgTemplates.importTemplates(coreTemplates);\n\t\t\t\tbaseTemplates = dbgTemplates;\n\t\t\t\tSTGroup stTemplates = new ToolSTGroupFile(langDir+\"/ST.stg\");\n\t\t\t\tstTemplates.importTemplates(dbgTemplates);\n\t\t\t\ttemplates = stTemplates;\n\t\t\t\tdbgTemplates.iterateAcrossValues = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tSTGroup stTemplates = new ToolSTGroupFile(langDir+\"/ST.stg\");\n\t\t\t\tstTemplates.importTemplates(coreTemplates);\n\t\t\t\ttemplates = stTemplates;\n\t\t\t}\n\t\t\ttemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps\n\t\t}\n\t\telse if ( debug && grammar.type!=Grammar.LEXER ) {\n\t\t\tSTGroup dbgTemplates = new ToolSTGroupFile(langDir+\"/Dbg.stg\");\n\t\t\tdbgTemplates.importTemplates(coreTemplates);\n\t\t\ttemplates = dbgTemplates;\n\t\t\tbaseTemplates = templates;\n\t\t\tbaseTemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps\n\t\t}\n\t\telse {\n\t\t\ttemplates = coreTemplates;\n\t\t\tcoreTemplates.iterateAcrossValues = true; // ST v3 compatibility with Maps\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#Block#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#QualifiedName#BooleanLiteral#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)IfStatement)Block)MethodDeclaration", "methodDoc": "load the main language.stg template group file", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.antlr.tool.ToolSTGroupFile.<init>", "org.antlr.tool.Grammar.getOption", "java.lang.String.equals", "org.stringtemplate.v4.STGroup.importTemplates"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.String"], ["java.lang.Object"], ["org.stringtemplate.v4.STGroup"]], "passed_comments": "/"}, {"index": "717", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genRecognizer", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public ST genRecognizer() {\n\t\t//System.out.println(\"### generate \"+grammar.name+\" recognizer\");\n\t\t// LOAD OUTPUT TEMPLATES\n\t\tloadTemplates(language);\n\t\tif ( templates==null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// CREATE NFA FROM GRAMMAR, CREATE DFA FROM NFA\n\t\tif ( ErrorManager.doNotAttemptAnalysis() ) {\n\t\t\treturn null;\n\t\t}\n\t\ttarget.performGrammarAnalysis(this, grammar);\n\n\n\t\t// some grammar analysis errors will not yield reliable DFA\n\t\tif ( ErrorManager.doNotAttemptCodeGen() ) {\n\t\t\treturn null;\n\t\t}\n\n\t\t// OPTIMIZE DFA\n\t\tDFAOptimizer optimizer = new DFAOptimizer(grammar);\n\t\toptimizer.optimize();\n\n\t\t// OUTPUT FILE (contains recognizerST)\n\t\toutputFileST = templates.getInstanceOf(\"outputFile\");\n\n\t\t// HEADER FILE\n\t\tif ( templates.isDefined(\"headerFile\") ) {\n\t\t\theaderFileST = templates.getInstanceOf(\"headerFile\");\n\t\t}\n\t\telse {\n\t\t\t// create a dummy to avoid null-checks all over code generator\n\t\t\theaderFileST = new ST(templates,\"xyz\");\n\t\t\theaderFileST.add(\"cyclicDFAs\", (Object)null); // it normally sees this from outputFile\n\t\t\t//headerFileST.impl.name = \"dummy-header-file\";\n\t\t}\n\n\t\tboolean filterMode = grammar.getOption(\"filter\")!=null &&\n\t\t\t\t\t\t\t  grammar.getOption(\"filter\").equals(\"true\");\n        boolean canBacktrack = grammar.getSyntacticPredicates()!=null ||\n                               grammar.composite.getRootGrammar().atLeastOneBacktrackOption ||\n                               filterMode;\n\n        // TODO: move this down further because generating the recognizer\n\t\t// alters the model with info on who uses predefined properties etc...\n\t\t// The actions here might refer to something.\n\n\t\t// The only two possible output files are available at this point.\n\t\t// Verify action scopes are ok for target and dump actions into output\n\t\t// Templates can say <actions.parser.header> for example.\n\t\tMap<String, Map<String, Object>> actions = grammar.getActions();\n\t\tverifyActionScopesOkForTarget(actions);\n\t\t// translate $x::y references\n\t\ttranslateActionAttributeReferences(actions);\n\n        ST gateST = templates.getInstanceOf(\"actionGate\");\n        if ( filterMode ) {\n            // if filtering, we need to set actions to execute at backtracking\n            // level 1 not 0.\n            gateST = templates.getInstanceOf(\"filteringActionGate\");\n        }\n        grammar.setSynPredGateIfNotAlready(gateST);\n\n        headerFileST.add(\"actions\", actions);\n\t\toutputFileST.add(\"actions\", actions);\n\n\t\theaderFileST.add(\"buildTemplate\", grammar.buildTemplate());\n\t\toutputFileST.add(\"buildTemplate\", grammar.buildTemplate());\n\t\theaderFileST.add(\"buildAST\", grammar.buildAST());\n\t\toutputFileST.add(\"buildAST\", grammar.buildAST());\n\n\t\toutputFileST.add(\"rewriteMode\", grammar.rewriteMode());\n\t\theaderFileST.add(\"rewriteMode\", grammar.rewriteMode());\n\n\t\toutputFileST.add(\"backtracking\", canBacktrack);\n\t\theaderFileST.add(\"backtracking\", canBacktrack);\n\t\t// turn on memoize attribute at grammar level so we can create ruleMemo.\n\t\t// each rule has memoize attr that hides this one, indicating whether\n\t\t// it needs to save results\n\t\tString memoize = (String)grammar.getOption(\"memoize\");\n\t\toutputFileST.add(\"memoize\",\n\t\t\t\t\t\t (grammar.atLeastOneRuleMemoizes ||\n\t\t\t\t\t\t  memoize != null && memoize.equals(\"true\") &&\n\t\t\t\t\t\t  canBacktrack));\n\t\theaderFileST.add(\"memoize\",\n\t\t\t\t\t\t (grammar.atLeastOneRuleMemoizes ||\n\t\t\t\t\t\t  memoize != null && memoize.equals(\"true\") &&\n\t\t\t\t\t\t  canBacktrack));\n\n\n\t\toutputFileST.add(\"trace\", trace);\n\t\theaderFileST.add(\"trace\", trace);\n\n\t\toutputFileST.add(\"profile\", profile);\n\t\theaderFileST.add(\"profile\", profile);\n\n\t\t// RECOGNIZER\n\t\tif ( grammar.type==Grammar.LEXER ) {\n\t\t\trecognizerST = templates.getInstanceOf(\"lexer\");\n\t\t\toutputFileST.add(\"LEXER\", true);\n\t\t\theaderFileST.add(\"LEXER\", true);\n\t\t\trecognizerST.add(\"filterMode\",\n\t\t\t\t\t\t\t filterMode);\n\t\t}\n\t\telse if ( grammar.type==Grammar.PARSER ||\n\t\t\tgrammar.type==Grammar.COMBINED )\n\t\t{\n\t\t\trecognizerST = templates.getInstanceOf(\"parser\");\n\t\t\toutputFileST.add(\"PARSER\", true);\n\t\t\theaderFileST.add(\"PARSER\", true);\n\t\t}\n\t\telse {\n\t\t\trecognizerST = templates.getInstanceOf(\"treeParser\");\n\t\t\toutputFileST.add(\"TREE_PARSER\", true);\n\t\t\theaderFileST.add(\"TREE_PARSER\", true);\n            recognizerST.add(\"filterMode\",\n\t\t\t\t\t\t\t filterMode);\n\t\t}\n\t\toutputFileST.add(\"recognizer\", recognizerST);\n\t\theaderFileST.add(\"recognizer\", recognizerST);\n\t\toutputFileST.add(\"actionScope\",\n\t\t\t\t\t\t grammar.getDefaultActionScope(grammar.type));\n\t\theaderFileST.add(\"actionScope\",\n\t\t\t\t\t\t grammar.getDefaultActionScope(grammar.type));\n\n\t\tString targetAppropriateFileNameString =\n\t\t\ttarget.getTargetStringLiteralFromString(grammar.getFileName());\n\t\toutputFileST.add(\"fileName\", targetAppropriateFileNameString);\n\t\theaderFileST.add(\"fileName\", targetAppropriateFileNameString);\n\t\toutputFileST.add(\"ANTLRVersion\", tool.VERSION);\n\t\theaderFileST.add(\"ANTLRVersion\", tool.VERSION);\n\t\toutputFileST.add(\"generatedTimestamp\", Tool.getCurrentTimeStamp());\n\t\theaderFileST.add(\"generatedTimestamp\", Tool.getCurrentTimeStamp());\n\n\t\t// GENERATE RECOGNIZER\n\t\t// Walk the AST holding the input grammar, this time generating code\n\t\t// Decisions are generated by using the precomputed DFAs\n\t\t// Fill in the various templates with data\n\t\tCodeGenTreeWalker gen = new CodeGenTreeWalker(new CommonTreeNodeStream(grammar.getGrammarTree()));\n\t\ttry {\n\t\t\tgen.grammar_(\n\t\t\t\t\t\tgrammar,\n\t\t\t\t\t\trecognizerST,\n\t\t\t\t\t\toutputFileST,\n\t\t\t\t\t\theaderFileST);\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\tErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,\n\t\t\t\t\t\t\t   re);\n\t\t}\n\n\t\tgenTokenTypeConstants(recognizerST);\n\t\tgenTokenTypeConstants(outputFileST);\n\t\tgenTokenTypeConstants(headerFileST);\n\n\t\tif ( grammar.type!=Grammar.LEXER ) {\n\t\t\tgenTokenTypeNames(recognizerST);\n\t\t\tgenTokenTypeNames(outputFileST);\n\t\t\tgenTokenTypeNames(headerFileST);\n\t\t}\n\n\t\t// Now that we know what synpreds are used, we can set into template\n\t\tSet<String> synpredNames = null;\n\t\tif ( grammar.synPredNamesUsedInDFA.size()>0 ) {\n\t\t\tsynpredNames = grammar.synPredNamesUsedInDFA;\n\t\t}\n\t\toutputFileST.add(\"synpreds\", synpredNames);\n\t\theaderFileST.add(\"synpreds\", synpredNames);\n\n\t\t// all recognizers can see Grammar object\n\t\trecognizerST.add(\"grammar\", grammar);\n\n\t\t// do not render templates to disk if errors occurred\n\t\tif ( ErrorManager.getErrorState().errors > 0 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (LAUNCH_ST_INSPECTOR) {\n\t\t\toutputFileST.inspect();\n\t\t\tif ( templates.isDefined(\"headerFile\") ) headerFileST.inspect();\n\t\t}\n\n\t\t// WRITE FILES\n\t\ttry {\n\t\t\ttarget.genRecognizerFile(tool,this,grammar,outputFileST);\n\t\t\tif ( templates.isDefined(\"headerFile\") ) {\n\t\t\t\tST extST = templates.getInstanceOf(\"headerFileExtension\");\n\t\t\t\ttarget.genRecognizerHeaderFile(tool,this,grammar,headerFileST,extST.render());\n\t\t\t}\n\t\t\t// write out the vocab interchange file; used by antlr,\n\t\t\t// does not change per target\n\t\t\tST tokenVocabSerialization = genTokenVocabOutput();\n\t\t\tString vocabFileName = getVocabFileName();\n\t\t\tif ( vocabFileName!=null ) {\n\t\t\t\twrite(tokenVocabSerialization, vocabFileName);\n\t\t\t}\n\t\t\t//System.out.println(outputFileST.getDOTForDependencyGraph(false));\n\t\t}\n\t\tcatch (IOException ioe) {\n\t\t\tErrorManager.error(ErrorManager.MSG_CANNOT_WRITE_FILE, ioe);\n\t\t}\n\t\t/*\n\t\tSystem.out.println(\"num obj.prop refs: \"+ ASTExpr.totalObjPropRefs);\n\t\tSystem.out.println(\"num reflection lookups: \"+ ASTExpr.totalReflectionLookups);\n\t\t*/\n\n\t\treturn outputFileST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#ThisExpression#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleType#NullLiteral#CastExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#FieldAccess#InfixExpression#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#InfixExpression#InfixExpression#ParenthesizedExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#InfixExpression#InfixExpression#ParenthesizedExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#FieldAccess#NumberLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#ThisExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#ThisExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(StringLiteral)StringLiteral)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(NullLiteral)NullLiteral)CastExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(FieldAccess(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess)InfixExpression(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(SimpleName)SimpleName)InfixExpression)InfixExpression)ParenthesizedExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(ParenthesizedExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(SimpleName)SimpleName)InfixExpression)InfixExpression)ParenthesizedExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(FieldAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)FieldAccess(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)IfStatement)Block)IfStatement(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given the grammar to which we are attached, walk the AST associated with that grammar to create NFAs.  Then create the DFAs for all decision points in the grammar by converting the NFAs to DFAs. Finally, walk the AST again to generate code. Either 1 or 2 files are written: recognizer: the main parser/lexer/treewalker item header file: language like C/C++ need extern definitions The target, such as JavaTarget, dictates which files get written.", "call_func_name": ["org.antlr.codegen.CodeGenerator.loadTemplates", "org.antlr.tool.ErrorManager.doNotAttemptAnalysis", "org.antlr.codegen.Target.performGrammarAnalysis", "org.antlr.tool.ErrorManager.doNotAttemptCodeGen", "org.antlr.analysis.DFAOptimizer.<init>", "org.antlr.analysis.DFAOptimizer.optimize", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.stringtemplate.v4.STGroup.isDefined", "org.stringtemplate.v4.ST.<init>", "org.stringtemplate.v4.ST.add", "org.antlr.tool.Grammar.getOption", "java.lang.Object.equals", "org.antlr.tool.Grammar.getSyntacticPredicates", "org.antlr.tool.CompositeGrammar.getRootGrammar", "org.antlr.tool.Grammar.getActions", "org.antlr.codegen.CodeGenerator.verifyActionScopesOkForTarget", "org.antlr.codegen.CodeGenerator.translateActionAttributeReferences", "org.antlr.tool.Grammar.setSynPredGateIfNotAlready", "org.antlr.tool.Grammar.buildTemplate", "java.lang.Boolean.valueOf", "org.antlr.tool.Grammar.buildAST", "org.antlr.tool.Grammar.rewriteMode", "java.lang.String.equals", "org.antlr.tool.Grammar.getDefaultActionScope", "org.antlr.tool.Grammar.getFileName", "org.antlr.codegen.Target.getTargetStringLiteralFromString", "org.antlr.Tool.getCurrentTimeStamp", "org.antlr.tool.Grammar.getGrammarTree", "org.antlr.runtime.tree.CommonTreeNodeStream.<init>", "org.antlr.grammar.v3.CodeGenTreeWalker.<init>", "org.antlr.grammar.v3.CodeGenTreeWalker.grammar_", "org.antlr.tool.ErrorManager.error", "org.antlr.codegen.CodeGenerator.genTokenTypeConstants", "org.antlr.codegen.CodeGenerator.genTokenTypeNames", "java.util.Set.size", "org.antlr.tool.ErrorManager.getErrorState", "org.stringtemplate.v4.ST.inspect", "org.antlr.codegen.Target.genRecognizerFile", "org.stringtemplate.v4.ST.render", "org.antlr.codegen.Target.genRecognizerHeaderFile", "org.antlr.codegen.CodeGenerator.genTokenVocabOutput", "org.antlr.codegen.CodeGenerator.getVocabFileName", "org.antlr.codegen.CodeGenerator.write"], "call_func_parameter": [["java.lang.String"], [""], ["org.antlr.codegen.CodeGenerator", "org.antlr.tool.Grammar"], [""], ["org.antlr.tool.Grammar"], [""], ["java.lang.String"], ["java.lang.String"], ["org.stringtemplate.v4.STGroup", "java.lang.String"], ["java.lang.String", "java.lang.Object"], ["java.lang.String"], ["java.lang.Object"], [""], [""], [""], ["java.util.Map"], ["java.util.Map"], ["org.stringtemplate.v4.ST"], [""], ["boolean"], [""], [""], ["java.lang.Object"], ["int"], [""], ["java.lang.String"], [""], [""], ["java.lang.Object"], ["org.antlr.runtime.tree.TreeNodeStream"], ["org.antlr.tool.Grammar", "org.stringtemplate.v4.ST", "org.stringtemplate.v4.ST", "org.stringtemplate.v4.ST"], ["int", "java.lang.Throwable"], ["org.stringtemplate.v4.ST"], ["org.stringtemplate.v4.ST"], [""], [""], [""], ["org.antlr.Tool", "org.antlr.codegen.CodeGenerator", "org.antlr.tool.Grammar", "org.stringtemplate.v4.ST"], [""], ["org.antlr.Tool", "org.antlr.codegen.CodeGenerator", "org.antlr.tool.Grammar", "org.stringtemplate.v4.ST", "java.lang.String"], [""], [""], ["org.stringtemplate.v4.ST", "java.lang.String"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.loadTemplates": "load the main language.stg template group file"}, {"org.antlr.codegen.CodeGenerator.verifyActionScopesOkForTarget": "Some targets will have some extra scopes like C++ may have '@headerfile:name {action}' or something.  Make sure the target likes the scopes in action table."}, {"org.antlr.codegen.CodeGenerator.translateActionAttributeReferences": "Actions may reference $x::y attributes, call translateAction on each action and replace that action in the Map."}, {"org.antlr.tool.Grammar.getDefaultActionScope": "Given a grammar type, what should be the default action scope? If I say @members in a COMBINED grammar, for example, the default scope should be \"parser\"."}, {"org.antlr.Tool.getCurrentTimeStamp": "Return a time stamp string accurate to sec: yyyy-mm-dd hh:mm:ss"}, {"org.antlr.codegen.CodeGenerator.genTokenTypeConstants": "Set attributes tokens and literals attributes in the incoming code template.  This is not the token vocab interchange file, but rather a list of token type ID needed by the recognizer."}, {"org.antlr.codegen.CodeGenerator.genTokenTypeNames": "Generate a token names table that maps token type to a printable name: either the label like INT or the literal like \"begin\"."}, {"org.antlr.codegen.CodeGenerator.genTokenVocabOutput": "Generate a token vocab file with all the token names/types.  For example: ID=7 FOR=8 'for'=8 This is independent of the target language; used by antlr internally"}, {"org.antlr.codegen.CodeGenerator.getVocabFileName": "What is the name of the vocab file generated for this grammar? Returns null if no .tokens file should be generated."}]}, {"index": "718", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.verifyActionScopesOkForTarget", "methodParameterType": "Map<String,Map<String,Object>>#", "methodParameterName": "actions#", "methodBody": "protected void verifyActionScopesOkForTarget(Map<String, Map<String, Object>> actions) {\n\t\tfor (Map.Entry<String, Map<String, Object>> entry : actions.entrySet()) {\n\t\t\tString scope = entry.getKey();\n\t\t\tif ( !target.isValidActionScope(grammar.type, scope) ) {\n\t\t\t\t// get any action from the scope to get error location\n\t\t\t\tMap<String, Object> scopeActions = entry.getValue();\n\t\t\t\tGrammarAST actionAST =\n\t\t\t\t\t(GrammarAST)scopeActions.values().iterator().next();\n\t\t\t\tErrorManager.grammarError(\n\t\t\t\t\tErrorManager.MSG_INVALID_ACTION_SCOPE,grammar,\n\t\t\t\t\tactionAST.getToken(),scope,\n\t\t\t\t\tgrammar.getGrammarTypeString());\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Some targets will have some extra scopes like C++ may have '@headerfile:name {action}' or something.  Make sure the target likes the scopes in action table.", "call_func_name": ["java.util.Map.entrySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.codegen.Target.isValidActionScope", "java.util.Map.values", "java.util.Collection.iterator", "org.antlr.tool.GrammarAST.getToken", "org.antlr.tool.Grammar.getGrammarTypeString", "org.antlr.tool.ErrorManager.grammarError"], "call_func_parameter": [[""], [""], [""], [""], ["int", "java.lang.String"], [""], [""], [""], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.Target.isValidActionScope": "Is scope in @scope::name {action} valid for this kind of grammar? Targets like C++ may want to allow new scopes like headerfile or some such.  The action names themselves are not policed at the moment so targets can add template actions w/o having to recompile ANTLR."}]}, {"index": "719", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.translateActionAttributeReferences", "methodParameterType": "Map<String,Map<String,Object>>#", "methodParameterName": "actions#", "methodBody": "protected void translateActionAttributeReferences(Map<String, Map<String, Object>> actions) {\n\t\tfor (Map.Entry<String, Map<String, Object>> entry : actions.entrySet()) {\n\t\t\tMap<String, Object> scopeActions = entry.getValue();\n\t\t\ttranslateActionAttributeReferencesForSingleScope(null,scopeActions);\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(NullLiteral)NullLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Actions may reference $x::y attributes, call translateAction on each action and replace that action in the Map.", "call_func_name": ["java.util.Map.entrySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.codegen.CodeGenerator.translateActionAttributeReferencesForSingleScope"], "call_func_parameter": [[""], [""], [""], [""], ["org.antlr.tool.Rule", "java.util.Map"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.translateActionAttributeReferencesForSingleScope": "Use for translating rule @init{...} actions that have no scope"}]}, {"index": "720", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.translateActionAttributeReferencesForSingleScope", "methodParameterType": "Rule#Map<String,Object>#", "methodParameterName": "r#scopeActions#", "methodBody": "public void translateActionAttributeReferencesForSingleScope(\n\t\tRule r,\n\t\tMap<String, Object> scopeActions)\n\t{\n\t\tString ruleName=null;\n\t\tif ( r!=null ) {\n\t\t\truleName = r.name;\n\t\t}\n\t\tfor (Map.Entry<String, Object> entry : scopeActions.entrySet()) {\n\t\t\tString name = entry.getKey();\n\t\t\tGrammarAST actionAST = (GrammarAST)entry.getValue();\n\t\t\tList<?> chunks = translateAction(ruleName,actionAST);\n\t\t\tscopeActions.put(name, chunks); // replace with translation\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)Assignment)ExpressionStatement)Block)IfStatement(EnhancedForStatement(SingleVariableDeclaration(ParameterizedType(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Use for translating rule @init{...} actions that have no scope", "call_func_name": ["java.util.Map.entrySet", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.codegen.CodeGenerator.translateAction", "java.util.Map.put"], "call_func_parameter": [[""], [""], [""], [""], ["java.lang.String", "org.antlr.tool.GrammarAST"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": "/"}, {"index": "721", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.generateLocalFOLLOW", "methodParameterType": "GrammarAST#String#String#int#", "methodParameterName": "referencedElementNode#referencedElementName#enclosingRuleName#elementIndex#", "methodBody": "public void generateLocalFOLLOW(GrammarAST referencedElementNode,\n\t\t\t\t\t\t\t\t\tString referencedElementName,\n\t\t\t\t\t\t\t\t\tString enclosingRuleName,\n\t\t\t\t\t\t\t\t\tint elementIndex)\n\t{\n\t\t/*\n\t\tSystem.out.println(\"compute FOLLOW \"+grammar.name+\".\"+referencedElementNode.toString()+\n\t\t\t\t\t\t \" for \"+referencedElementName+\"#\"+elementIndex +\" in \"+\n\t\t\t\t\t\t enclosingRuleName+\n\t\t\t\t\t\t \" line=\"+referencedElementNode.getLine());\n\t\t\t\t\t\t */\n\t\tNFAState followingNFAState = referencedElementNode.followingNFAState;\n\t\tLookaheadSet follow = null;\n\t\tif ( followingNFAState!=null ) {\n\t\t\t// compute follow for this element and, as side-effect, track\n\t\t\t// the rule LOOK sensitivity.\n\t\t\tfollow = grammar.FIRST(followingNFAState);\n\t\t}\n\n\t\tif ( follow==null ) {\n\t\t\tErrorManager.internalError(\"no follow state or cannot compute follow\");\n\t\t\tfollow = new LookaheadSet();\n\t\t}\n\t\tif ( follow.member(Label.EOF) ) {\n\t\t\t// TODO: can we just remove?  Seems needed here:\n\t\t\t// compilation_unit : global_statement* EOF\n\t\t\t// Actually i guess we resync to EOF regardless\n\t\t\tfollow.remove(Label.EOF);\n\t\t}\n\t\t//System.out.println(\" \"+follow);\n\n        List<Integer> tokenTypeList;\n        long[] words;\n\t\tif ( follow.tokenTypeSet==null ) {\n\t\t\twords = new long[1];\n            tokenTypeList = new ArrayList<Integer>();\n        }\n\t\telse {\n\t\t\tBitSet bits = BitSet.of(follow.tokenTypeSet);\n\t\t\twords = bits.toPackedArray();\n            tokenTypeList = follow.tokenTypeSet.toList();\n        }\n\t\t// use the target to convert to hex strings (typically)\n\t\tString[] wordStrings = new String[words.length];\n\t\tfor (int j = 0; j < words.length; j++) {\n\t\t\tlong w = words[j];\n\t\t\twordStrings[j] = target.getTarget64BitStringFromValue(w);\n\t\t}\n\t\trecognizerST.addAggr(\"bitsets.{name,inName,bits,tokenTypes,tokenIndex}\",\n\t\t\t\t\t\t\t referencedElementName,\n\t\t\t\t\t\t\t enclosingRuleName,\n\t\t\t\t\t\t\t wordStrings,\n\t\t\t\t\t\t\t tokenTypeList,\n\t\t\t\t\t\t\t Utils.integer(elementIndex));\n\t\toutputFileST.addAggr(\"bitsets.{name,inName,bits,tokenTypes,tokenIndex}\",\n\t\t\t\t\t\t\t referencedElementName,\n\t\t\t\t\t\t\t enclosingRuleName,\n\t\t\t\t\t\t\t wordStrings,\n\t\t\t\t\t\t\t tokenTypeList,\n\t\t\t\t\t\t\t Utils.integer(elementIndex));\n\t\theaderFileST.addAggr(\"bitsets.{name,inName,bits,tokenTypes,tokenIndex}\",\n\t\t\t\t\t\t\t referencedElementName,\n\t\t\t\t\t\t\t enclosingRuleName,\n\t\t\t\t\t\t\t wordStrings,\n\t\t\t\t\t\t\t tokenTypeList,\n\t\t\t\t\t\t\t Utils.integer(elementIndex));\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#Dimension#ArrayType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#NullLiteral#InfixExpression#SimpleName#PrimitiveType#Dimension#ArrayType#NumberLiteral#ArrayCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#QualifiedName#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#ArrayAccess#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ArrayAccess#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(NumberLiteral)NumberLiteral)ArrayCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Error recovery in ANTLR recognizers. Based upon original ideas: Algorithms + Data Structures = Programs by Niklaus Wirth and A note on error recovery in recursive descent parsers: http://portal.acm.org/citation.cfm?id=947902.947905 Later, Josef Grosch had some good ideas: Efficient and Comfortable Error Recovery in Recursive Descent Parsers: ftp://www.cocolab.com/products/cocktail/doca4.ps/ell.ps.zip Like Grosch I implemented local FOLLOW sets that are combined at run-time upon error to avoid parsing overhead.", "call_func_name": ["org.antlr.tool.Grammar.FIRST", "org.antlr.tool.ErrorManager.internalError", "org.antlr.analysis.LookaheadSet.<init>", "org.antlr.analysis.LookaheadSet.member", "org.antlr.analysis.LookaheadSet.remove", "java.util.ArrayList.<init>", "org.antlr.misc.BitSet.of", "org.antlr.misc.BitSet.toPackedArray", "org.antlr.misc.IntervalSet.toList", "org.antlr.codegen.Target.getTarget64BitStringFromValue", "org.antlr.misc.Utils.integer", "org.stringtemplate.v4.ST.addAggr"], "call_func_parameter": [["org.antlr.analysis.NFAState"], ["java.lang.Object"], [""], ["int"], ["int"], [""], ["org.antlr.misc.IntSet"], [""], [""], ["long"], ["int"], ["java.lang.String", "java.lang.Object[]"]], "passed_comments": [{"org.antlr.codegen.Target.getTarget64BitStringFromValue": "Convert long to 0xNNNNNNNNNNNNNNNN by default for spitting out with bitsets.  I.e., convert bytes to hex string."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "722", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genLookaheadDecision", "methodParameterType": "ST#DFA#", "methodParameterName": "recognizerST#dfa#", "methodBody": "public ST genLookaheadDecision(ST recognizerST,\n\t\t\t\t\t\t\t\t   DFA dfa)\n\t{\n\t\tST decisionST;\n\t\t// If we are doing inline DFA and this one is acyclic and LL(*)\n\t\t// I have to check for is-non-LL(*) because if non-LL(*) the cyclic\n\t\t// check is not done by DFA.verify(); that is, verify() avoids\n\t\t// doesStateReachAcceptState() if non-LL(*)\n\t\tif ( dfa.canInlineDecision() ) {\n\t\t\tdecisionST =\n\t\t\t\tacyclicDFAGenerator.genFixedLookaheadDecision(getTemplates(), dfa);\n\t\t}\n\t\telse {\n\t\t\t// generate any kind of DFA here (cyclic or acyclic)\n\t\t\tdfa.createStateTables(this);\n\t\t\toutputFileST.add(\"cyclicDFAs\", dfa);\n\t\t\theaderFileST.add(\"cyclicDFAs\", dfa);\n\t\t\tdecisionST = templates.getInstanceOf(\"dfaDecision\");\n\t\t\tString description = dfa.getNFADecisionStartState().getDescription();\n\t\t\tdescription = target.getTargetStringLiteralFromString(description);\n\t\t\tif ( description!=null ) {\n\t\t\t\tdecisionST.add(\"description\", description);\n\t\t\t}\n\t\t\tdecisionST.add(\"decisionNumber\",\n\t\t\t\t\t\t   Utils.integer(dfa.getDecisionNumber()));\n\t\t}\n\t\treturn decisionST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#ThisExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Generate code that computes the predicted alt given a DFA.  The recognizerST can be either the main generated recognizerTemplate for storage in the main parser file or a separate file.  It's up to the code that ultimately invokes the codegen.g grammar rule. Regardless, the output file and header file get a copy of the DFAs.", "call_func_name": ["org.antlr.analysis.DFA.canInlineDecision", "org.antlr.codegen.CodeGenerator.getTemplates", "org.antlr.codegen.ACyclicDFACodeGenerator.genFixedLookaheadDecision", "org.antlr.analysis.DFA.createStateTables", "org.stringtemplate.v4.ST.add", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.analysis.DFA.getNFADecisionStartState", "org.antlr.analysis.NFAState.getDescription", "org.antlr.codegen.Target.getTargetStringLiteralFromString", "org.antlr.analysis.DFA.getDecisionNumber", "org.antlr.misc.Utils.integer"], "call_func_parameter": [[""], [""], ["org.stringtemplate.v4.STGroup", "org.antlr.analysis.DFA"], ["org.antlr.codegen.CodeGenerator"], ["java.lang.String", "java.lang.Object"], ["java.lang.String"], [""], [""], ["java.lang.String"], [""], ["int"]], "passed_comments": [{"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "723", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.generateSpecialState", "methodParameterType": "DFAState#", "methodParameterName": "s#", "methodBody": "public ST generateSpecialState(DFAState s) {\n\t\tST stateST;\n\t\tstateST = templates.getInstanceOf(\"cyclicDFAState\");\n\t\tstateST.add(\"needErrorClause\", true);\n\t\tstateST.add(\"semPredState\",\n\t\t\t\t\ts.isResolvedWithPredicates());\n\t\tstateST.add(\"stateNumber\", s.stateNumber);\n\t\tstateST.add(\"decisionNumber\", s.dfa.decisionNumber);\n\n\t\tboolean foundGatedPred = false;\n\t\tST eotST = null;\n\t\tfor (int i = 0; i < s.getNumberOfTransitions(); i++) {\n\t\t\tTransition edge = s.transition(i);\n\t\t\tST edgeST;\n\t\t\tif ( edge.label.getAtom()==Label.EOT ) {\n\t\t\t\t// this is the default clause; has to held until last\n\t\t\t\tedgeST = templates.getInstanceOf(\"eotDFAEdge\");\n\t\t\t\tstateST.remove(\"needErrorClause\");\n\t\t\t\teotST = edgeST;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tedgeST = templates.getInstanceOf(\"cyclicDFAEdge\");\n\t\t\t\tST exprST =\n\t\t\t\t\tgenLabelExpr(templates,edge,1);\n\t\t\t\tedgeST.add(\"labelExpr\", exprST);\n\t\t\t}\n\t\t\tedgeST.add(\"edgeNumber\", Utils.integer(i + 1));\n\t\t\tedgeST.add(\"targetStateNumber\",\n\t\t\t\t\t   Utils.integer(edge.target.stateNumber));\n\t\t\t// stick in any gated predicates for any edge if not already a pred\n\t\t\tif ( !edge.label.isSemanticPredicate() ) {\n\t\t\t\tDFAState t = (DFAState)edge.target;\n\t\t\t\tSemanticContext preds =\tt.getGatedPredicatesInNFAConfigurations();\n\t\t\t\tif ( preds!=null ) {\n\t\t\t\t\tfoundGatedPred = true;\n\t\t\t\t\tST predST = preds.genExpr(this,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  getTemplates(),\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t  t.dfa);\n\t\t\t\t\tedgeST.add(\"predicates\", predST.render());\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( edge.label.getAtom()!=Label.EOT ) {\n\t\t\t\tstateST.add(\"edges\", edgeST);\n\t\t\t}\n\t\t}\n\t\tif ( foundGatedPred ) {\n\t\t\t// state has >= 1 edge with a gated pred (syn or sem)\n\t\t\t// must rewind input first, set flag.\n\t\t\tstateST.add(\"semPredState\", foundGatedPred);\n\t\t}\n\t\tif ( eotST!=null ) {\n\t\t\tstateST.add(\"edges\", eotST);\n\t\t}\n\t\treturn stateST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#BooleanLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#BooleanLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#ThisExpression#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(MethodInvocation(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "A special state is huge (too big for state tables) or has a predicated edge.  Generate a simple if-then-else.  Cannot be an accept state as they have no emanating edges.  Don't worry about switch vs if-then-else because if you get here, the state is super complicated and needs an if-then-else.  This is used by the new DFA scheme created June 2006.", "call_func_name": ["org.stringtemplate.v4.STGroup.getInstanceOf", "java.lang.Boolean.valueOf", "org.stringtemplate.v4.ST.add", "org.antlr.analysis.DFAState.isResolvedWithPredicates", "java.lang.Integer.valueOf", "org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.analysis.Label.getAtom", "org.stringtemplate.v4.ST.remove", "org.antlr.codegen.CodeGenerator.genLabelExpr", "org.antlr.misc.Utils.integer", "org.antlr.analysis.Label.isSemanticPredicate", "org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations", "org.antlr.codegen.CodeGenerator.getTemplates", "org.antlr.analysis.SemanticContext.genExpr", "org.stringtemplate.v4.ST.render"], "call_func_parameter": [["java.lang.String"], ["boolean"], ["java.lang.String", "java.lang.Object"], [""], ["int"], [""], ["int"], [""], ["java.lang.String"], ["org.stringtemplate.v4.STGroup", "org.antlr.analysis.Transition", "int"], ["int"], [""], [""], [""], ["org.antlr.codegen.CodeGenerator", "org.stringtemplate.v4.STGroup", "org.antlr.analysis.DFA"], [""]], "passed_comments": [{"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.codegen.CodeGenerator.genLabelExpr": "Generate an expression for traversing an edge."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations": "For gated productions, we need an OR'd list of all predicates for the target of an edge so we can gate the edge based upon the predicates associated with taking that path (if any). For syntactic predicates, we only want to generate predicate evaluations as it transitions to an accept state; waste to do it earlier.  So, only add gated preds derived from manually- specified syntactic predicates if this is an accept state. Also, since configurations w/o gated predicates are like true gated predicates, finding a configuration whose alt has no gated predicate implies we should evaluate the predicate to true. This means the whole edge has to be ungated. Consider: X : ('a' | {p}?=&gt; 'a') | 'a' 'b' ; Here, you 'a' gets you from s0 to s1 but you can't test p because plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't test p.  Even on the edge going to accept state for alt 1 of X, you can't test p.  You can get to the same place with and w/o the context. Therefore, it is never ok to test p in this situation.  TODO: cache this as it's called a lot; or at least set bit if &gt;1 present in state"}, {"org.antlr.analysis.SemanticContext.genExpr": "Generate an expression that will evaluate the semantic context, given a set of output templates."}]}, {"index": "724", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genLabelExpr", "methodParameterType": "STGroup#Transition#int#", "methodParameterName": "templates#edge#k#", "methodBody": "protected ST genLabelExpr(STGroup templates,\n\t\t\t\t\t\t\t\t\t\t  Transition edge,\n\t\t\t\t\t\t\t\t\t\t  int k)\n\t{\n\t\tLabel label = edge.label;\n\t\tif ( label.isSemanticPredicate() ) {\n\t\t\treturn genSemanticPredicateExpr(templates, edge);\n\t\t}\n\t\tif ( label.isSet() ) {\n\t\t\treturn genSetExpr(templates, label.getSet(), k, true);\n\t\t}\n\t\t// must be simple label\n\t\tST eST = templates.getInstanceOf(\"lookaheadTest\");\n\t\teST.add(\"atom\", getTokenTypeAsTargetLabel(label.getAtom()));\n\t\teST.add(\"atomAsInt\", Utils.integer(label.getAtom()));\n\t\teST.add(\"k\", Utils.integer(k));\n\t\treturn eST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#BooleanLiteral#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Generate an expression for traversing an edge.", "call_func_name": ["org.antlr.analysis.Label.isSemanticPredicate", "org.antlr.codegen.CodeGenerator.genSemanticPredicateExpr", "org.antlr.analysis.Label.isSet", "org.antlr.analysis.Label.getSet", "org.antlr.codegen.CodeGenerator.genSetExpr", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.analysis.Label.getAtom", "org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel", "org.stringtemplate.v4.ST.add", "org.antlr.misc.Utils.integer"], "call_func_parameter": [[""], ["org.stringtemplate.v4.STGroup", "org.antlr.analysis.Transition"], [""], [""], ["org.stringtemplate.v4.STGroup", "org.antlr.misc.IntSet", "int", "boolean"], ["java.lang.String"], [""], ["int"], ["java.lang.String", "java.lang.Object"], ["int"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.genSetExpr": "For intervals such as [3..3, 30..35], generate an expression that tests the lookahead similar to LA(1)==3 || (LA(1)&gt;=30&amp;&amp;LA(1)&lt;=35)"}, {"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel": "Get a meaningful name for a token type useful during code generation. Literals without associated names are converted to the string equivalent of their integer values. Used to generate x==ID and x==34 type comparisons etc...  Essentially we are looking for the most obvious way to refer to a token type in the generated code.  If in the lexer, return the char literal translated to the target language.  For example, ttype=10 will yield '\\n' from the getTokenDisplayName method.  That must be converted to the target languages literals.  For most C-derived languages no translation is needed."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "725", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genSetExpr", "methodParameterType": "STGroup#IntSet#int#boolean#", "methodParameterName": "templates#set#k#partOfDFA#", "methodBody": "public ST genSetExpr(STGroup templates,\n\t\t\t\t\t\t\t\t\t IntSet set,\n\t\t\t\t\t\t\t\t\t int k,\n\t\t\t\t\t\t\t\t\t boolean partOfDFA)\n\t{\n\t\tif ( !(set instanceof IntervalSet) ) {\n\t\t\tthrow new IllegalArgumentException(\"unable to generate expressions for non IntervalSet objects\");\n\t\t}\n\t\tIntervalSet iset = (IntervalSet)set;\n\t\tif ( iset.getIntervals()==null || iset.getIntervals().isEmpty() ) {\n\t\t\tST emptyST = new ST(templates, \"\");\n\t\t\temptyST.impl.name = \"empty-set-expr\";\n\t\t\treturn emptyST;\n\t\t}\n\t\tString testSTName = \"lookaheadTest\";\n\t\tString testRangeSTName = \"lookaheadRangeTest\";\n\t\tString testSetSTName = \"lookaheadSetTest\";\n\t\tString varSTName = \"lookaheadVarName\";\n\t\tif ( !partOfDFA ) {\n\t\t\ttestSTName = \"isolatedLookaheadTest\";\n\t\t\ttestRangeSTName = \"isolatedLookaheadRangeTest\";\n\t\t\ttestSetSTName = \"isolatedLookaheadSetTest\";\n\t\t\tvarSTName = \"isolatedLookaheadVarName\";\n\t\t}\n\t\tST setST = templates.getInstanceOf(\"setTest\");\n\t\t// If the SetTest template exists, separate the ranges:\n\t\t// flatten the small ones into one list and make that a range,\n\t\t// and leave the others as they are.\n\t\tif ( templates.isDefined(testSetSTName) ) {\n\t\t\t// Flatten the IntervalSet into a list of integers.\n\t\t\tST sST = templates.getInstanceOf(testSetSTName);\n\t\t\tIterator<Interval> iter = iset.getIntervals().iterator();\n\t\t\tint rangeNumber = 1;\n\t\t\twhile (iter.hasNext()) {\n\t\t\t\tInterval I = iter.next();\n\t\t\t\tint a = I.a;\n\t\t\t\tint b = I.b;\n\t\t\t\t// Not flattening the large ranges helps us avoid making a\n\t\t\t\t// set that contains 90% of Unicode when we could just use\n\t\t\t\t// a simple range like (LA(1)>=123 && LA(1)<=65535).\n\t\t\t\t// This flattens all ranges of length 4 or less.\n\t\t\t\tif (b - a < 4) {\n\t\t\t\t\tfor (int i = a; i <= b; i++) {\n\t\t\t\t\t\tsST.add(\"values\", getTokenTypeAsTargetLabel(i));\n\t\t\t\t\t\tsST.add(\"valuesAsInt\", Utils.integer(i));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tST eST = templates.getInstanceOf(testRangeSTName);\n\t\t\t\t\teST.add(\"lower\", getTokenTypeAsTargetLabel(a));\n\t\t\t\t\teST.add(\"lowerAsInt\", Utils.integer(a));\n\t\t\t\t\teST.add(\"upper\", getTokenTypeAsTargetLabel(b));\n\t\t\t\t\teST.add(\"upperAsInt\", Utils.integer(b));\n\t\t\t\t\teST.add(\"rangeNumber\", Utils.integer(rangeNumber));\n\t\t\t\t\teST.add(\"k\", Utils.integer(k));\n\t\t\t\t\tsetST.add(\"ranges\", eST);\n\t\t\t\t\trangeNumber++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsST.add(\"k\", Utils.integer(k));\n\t\t\tsetST.add(\"ranges\", sST);\n\t\t\treturn setST;\n\t\t}\n\t\tIterator<Interval> iter = iset.getIntervals().iterator();\n\t\tint rangeNumber = 1;\n\t\twhile (iter.hasNext()) {\n\t\t\tInterval I = iter.next();\n\t\t\tint a = I.a;\n\t\t\tint b = I.b;\n\t\t\tST eST;\n\t\t\tif ( a==b ) {\n\t\t\t\teST = templates.getInstanceOf(testSTName);\n\t\t\t\teST.add(\"atom\", getTokenTypeAsTargetLabel(a));\n\t\t\t\teST.add(\"atomAsInt\", Utils.integer(a));\n\t\t\t\t//eST.add(\"k\",Utils.integer(k));\n\t\t\t}\n\t\t\telse {\n\t\t\t\teST = templates.getInstanceOf(testRangeSTName);\n\t\t\t\teST.add(\"lower\", getTokenTypeAsTargetLabel(a));\n\t\t\t\teST.add(\"lowerAsInt\", Utils.integer(a));\n\t\t\t\teST.add(\"upper\", getTokenTypeAsTargetLabel(b));\n\t\t\t\teST.add(\"upperAsInt\", Utils.integer(b));\n\t\t\t\teST.add(\"rangeNumber\", Utils.integer(rangeNumber));\n\t\t\t}\n\t\t\teST.add(\"k\", Utils.integer(k));\n\t\t\tsetST.add(\"ranges\", eST);\n\t\t\trangeNumber++;\n\t\t}\n\t\treturn setST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#InstanceofExpression#ParenthesizedExpression#PrefixExpression#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#Assignment#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#PrefixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#SimpleName#StringLiteral#Assignment#ExpressionStatement#SimpleName#StringLiteral#Assignment#ExpressionStatement#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#NumberLiteral#InfixExpression#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#WhileStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(ParenthesizedExpression(InstanceofExpression(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType)InstanceofExpression)ParenthesizedExpression)PrefixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(StringLiteral)StringLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(NumberLiteral)NumberLiteral)InfixExpression(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)WhileStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For intervals such as [3..3, 30..35], generate an expression that tests the lookahead similar to LA(1)==3 || (LA(1)&gt;=30&amp;&amp;LA(1)&lt;=35)", "call_func_name": ["java.lang.IllegalArgumentException.<init>", "org.antlr.misc.IntervalSet.getIntervals", "java.util.List.isEmpty", "org.stringtemplate.v4.ST.<init>", "org.stringtemplate.v4.STGroup.getInstanceOf", "org.stringtemplate.v4.STGroup.isDefined", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel", "org.stringtemplate.v4.ST.add", "org.antlr.misc.Utils.integer"], "call_func_parameter": [["java.lang.String"], [""], [""], ["org.stringtemplate.v4.STGroup", "java.lang.String"], ["java.lang.String"], ["java.lang.String"], [""], [""], [""], ["int"], ["java.lang.String", "java.lang.Object"], ["int"]], "passed_comments": [{"org.antlr.misc.IntervalSet.getIntervals": "Return a list of Interval objects."}, {"org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel": "Get a meaningful name for a token type useful during code generation. Literals without associated names are converted to the string equivalent of their integer values. Used to generate x==ID and x==34 type comparisons etc...  Essentially we are looking for the most obvious way to refer to a token type in the generated code.  If in the lexer, return the char literal translated to the target language.  For example, ttype=10 will yield '\\n' from the getTokenDisplayName method.  That must be converted to the target languages literals.  For most C-derived languages no translation is needed."}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "726", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genTokenTypeConstants", "methodParameterType": "ST#", "methodParameterName": "code#", "methodBody": "protected void genTokenTypeConstants(ST code) {\n\t\t// make constants for the token types\n\t\tfor (String tokenID : grammar.getTokenIDs()) {\n\t\t\tint tokenType = grammar.getTokenType(tokenID);\n\t\t\tif ( tokenType==Label.EOF ||\n\t\t\t\t tokenType>=Label.MIN_TOKEN_TYPE )\n\t\t\t{\n\t\t\t\t// don't do FAUX labels 'cept EOF\n\t\t\t\tcode.addAggr(\"tokens.{name,type}\", tokenID, Utils.integer(tokenType));\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "Set attributes tokens and literals attributes in the incoming code template.  This is not the token vocab interchange file, but rather a list of token type ID needed by the recognizer.", "call_func_name": ["org.antlr.tool.Grammar.getTokenIDs", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getTokenType", "org.antlr.misc.Utils.integer", "org.stringtemplate.v4.ST.addAggr"], "call_func_parameter": [[""], [""], [""], [""], ["java.lang.String"], ["int"], ["java.lang.String", "java.lang.Object[]"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenIDs": "Get the list of tokens that are IDs like BLOCK and LPAREN"}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}]}, {"index": "727", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genTokenTypeNames", "methodParameterType": "ST#", "methodParameterName": "code#", "methodBody": "protected void genTokenTypeNames(ST code) {\n\t\tfor (int t=Label.MIN_TOKEN_TYPE; t<=grammar.getMaxTokenType(); t++) {\n\t\t\tString tokenName = grammar.getTokenDisplayName(t);\n\t\t\tif ( tokenName!=null ) {\n\t\t\t\ttokenName=target.getTargetStringLiteralFromString(tokenName, true);\n\t\t\t\tcode.add(\"tokenNames\", tokenName);\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Generate a token names table that maps token type to a printable name: either the label like INT or the literal like \"begin\".", "call_func_name": ["org.antlr.tool.Grammar.getMaxTokenType", "org.antlr.tool.Grammar.getTokenDisplayName", "org.antlr.codegen.Target.getTargetStringLiteralFromString", "org.stringtemplate.v4.ST.add"], "call_func_parameter": [[""], ["int"], ["java.lang.String", "boolean"], ["java.lang.String", "java.lang.Object"]], "passed_comments": [{"org.antlr.tool.Grammar.getMaxTokenType": "How many token types have been allocated so far?"}, {"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}, {"org.antlr.codegen.Target.getTargetStringLiteralFromString": "Given a random string of Java unicode chars, return a new string with optionally appropriate quote characters for target language and possibly with some escaped characters.  For example, if the incoming string has actual newline characters, the output of this method would convert them to the two char sequence \\n for Java, C, C++, ...  The new string has double-quotes around it as well.  Example String in memory: a\"[newlinechar]b'c[carriagereturnchar]d[tab]e\\f would be converted to the valid Java s: \"a\\\"\\nb'c\\rd\\te\\\\f\" or a\\\"\\nb'c\\rd\\te\\\\f depending on the quoted arg."}]}, {"index": "728", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel", "methodParameterType": "int#", "methodParameterName": "ttype#", "methodBody": "public String getTokenTypeAsTargetLabel(int ttype) {\n\t\tif ( grammar.type==Grammar.LEXER ) {\n\t\t\tString name = grammar.getTokenDisplayName(ttype);\n\t\t\treturn target.getTargetCharLiteralFromANTLRCharLiteral(this,name);\n\t\t}\n\t\treturn target.getTokenTypeAsTargetLabel(this,ttype);\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#ThisExpression#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#ThisExpression#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get a meaningful name for a token type useful during code generation. Literals without associated names are converted to the string equivalent of their integer values. Used to generate x==ID and x==34 type comparisons etc...  Essentially we are looking for the most obvious way to refer to a token type in the generated code.  If in the lexer, return the char literal translated to the target language.  For example, ttype=10 will yield '\\n' from the getTokenDisplayName method.  That must be converted to the target languages literals.  For most C-derived languages no translation is needed.", "call_func_name": ["org.antlr.tool.Grammar.getTokenDisplayName", "org.antlr.codegen.Target.getTargetCharLiteralFromANTLRCharLiteral", "org.antlr.codegen.Target.getTokenTypeAsTargetLabel"], "call_func_parameter": [["int"], ["org.antlr.codegen.CodeGenerator", "java.lang.String"], ["org.antlr.codegen.CodeGenerator", "int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}, {"org.antlr.codegen.Target.getTargetCharLiteralFromANTLRCharLiteral": "Convert from an ANTLR char literal found in a grammar file to an equivalent char literal in the target language.  For most languages, this means leaving 'x' as 'x'.  Actually, we need to escape ' ' so that it doesn't get converted to \\n by the compiler.  Convert the literal to the char value and then to an appropriate target char literal. Expect single quotes around the incoming literal."}, {"org.antlr.codegen.Target.getTokenTypeAsTargetLabel": "Target must be able to override the labels used for token types"}]}, {"index": "729", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.genTokenVocabOutput", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected ST genTokenVocabOutput() {\n\t\tST vocabFileST = new ST(vocabFilePattern);\n\t\tvocabFileST.add(\"literals\",(Object)null); // \"define\" literals arg\n\t\tvocabFileST.add(\"tokens\",(Object)null);\n\t\tvocabFileST.impl.name = \"vocab-file\";\n\t\t// make constants for the token names\n\t\tfor (String tokenID : grammar.getTokenIDs()) {\n\t\t\tint tokenType = grammar.getTokenType(tokenID);\n\t\t\tif ( tokenType>=Label.MIN_TOKEN_TYPE ) {\n\t\t\t\tvocabFileST.addAggr(\"tokens.{name,type}\", tokenID, Utils.integer(tokenType));\n\t\t\t}\n\t\t}\n\n\t\t// now dump the strings\n\t\tfor (String literal : grammar.getStringLiterals()) {\n\t\t\tint tokenType = grammar.getTokenType(literal);\n\t\t\tif ( tokenType>=Label.MIN_TOKEN_TYPE ) {\n\t\t\t\tvocabFileST.addAggr(\"tokens.{name,type}\", literal, Utils.integer(tokenType));\n\t\t\t}\n\t\t}\n\n\t\treturn vocabFileST;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleType#NullLiteral#CastExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleType#NullLiteral#CastExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#StringLiteral#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(NullLiteral)NullLiteral)CastExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(NullLiteral)NullLiteral)CastExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName(StringLiteral)StringLiteral)Assignment)ExpressionStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Generate a token vocab file with all the token names/types.  For example: ID=7 FOR=8 'for'=8 This is independent of the target language; used by antlr internally", "call_func_name": ["org.stringtemplate.v4.ST.<init>", "org.stringtemplate.v4.ST.add", "org.antlr.tool.Grammar.getTokenIDs", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.Grammar.getTokenType", "org.antlr.misc.Utils.integer", "org.stringtemplate.v4.ST.addAggr", "org.antlr.tool.Grammar.getStringLiterals"], "call_func_parameter": [["java.lang.String"], ["java.lang.String", "java.lang.Object"], [""], [""], [""], [""], ["java.lang.String"], ["int"], ["java.lang.String", "java.lang.Object[]"], [""]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenIDs": "Get the list of tokens that are IDs like BLOCK and LPAREN"}, {"org.antlr.misc.Utils.integer": "Integer objects are immutable so share all Integers with the same value up to some max size.  Use an array as a perfect hash. Return shared object for 0..INTEGER_POOL_MAX_VALUE or a new Integer object with x in it."}, {"org.antlr.tool.Grammar.getStringLiterals": "Get the list of ANTLR String literals"}]}, {"index": "730", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.translateArgAction", "methodParameterType": "String#GrammarAST#", "methodParameterName": "ruleName#actionTree#", "methodBody": "public List<ST> translateArgAction(String ruleName,\n\t\t\t\t\t\t\t\t\t\t   GrammarAST actionTree)\n\t{\n\t\tString actionText = actionTree.token.getText();\n\t\tList<String> args = getListOfArgumentsFromAction(actionText,',');\n\t\tList<ST> translatedArgs = new ArrayList<ST>();\n\t\tfor (String arg : args) {\n\t\t\tif ( arg!=null ) {\n\t\t\t\tToken actionToken =\n\t\t\t\t\tnew CommonToken(ANTLRParser.ACTION,arg);\n\t\t\t\tActionTranslator translator =\n\t\t\t\t\tnew ActionTranslator(this,ruleName,\n\t\t\t\t\t\t\t\t\t\t\t  actionToken,\n\t\t\t\t\t\t\t\t\t\t\t  actionTree.outerAltNum);\n\t\t\t\tList<Object> chunks = translator.translateToChunks();\n\t\t\t\tchunks = target.postProcessAction(chunks, actionToken);\n\t\t\t\tST catST = new ST(templates, \"<chunks>\");\n\t\t\t\tcatST.add(\"chunks\", chunks);\n\t\t\t\ttranslatedArgs.add(catST);\n\t\t\t}\n\t\t}\n\t\tif ( translatedArgs.isEmpty() ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn translatedArgs;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ThisExpression#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ThisExpression)ThisExpression(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(StringLiteral)StringLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Translate an action like [3,\"foo\",a[3]] and return a List of the translated actions.  Because actions are themselves translated to a list of chunks, must cat together into a ST&gt;.  Don't translate to strings early as we need to eval templates in context.", "call_func_name": ["org.antlr.runtime.Token.getText", "org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction", "java.util.ArrayList.<init>", "java.util.List.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.runtime.CommonToken.<init>", "org.antlr.grammar.v3.ActionTranslator.<init>", "org.antlr.grammar.v3.ActionTranslator.translateToChunks", "org.antlr.codegen.Target.postProcessAction", "org.stringtemplate.v4.ST.<init>", "org.stringtemplate.v4.ST.add", "java.util.List.add", "java.util.List.isEmpty"], "call_func_parameter": [[""], ["java.lang.String", "int"], [""], [""], [""], [""], ["int", "java.lang.String"], ["org.antlr.codegen.CodeGenerator", "java.lang.String", "org.antlr.runtime.Token", "int"], [""], ["java.util.List", "org.antlr.runtime.Token"], ["org.stringtemplate.v4.STGroup", "java.lang.String"], ["java.lang.String", "java.lang.Object"], ["java.lang.Object"], [""]], "passed_comments": [{"org.antlr.runtime.Token.getText": "Get the text of the token"}, {"org.antlr.grammar.v3.ActionTranslator.translateToChunks": "Return a list of strings and ST objects that represent the translated action."}, {"org.antlr.codegen.Target.postProcessAction": "Give target a chance to do some postprocessing on actions. Python for example will have to fix the indention."}]}, {"index": "731", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction", "methodParameterType": "String#int#int#int#List<String>#", "methodParameterName": "actionText#start#targetChar#separatorChar#args#", "methodBody": "public static int getListOfArgumentsFromAction(String actionText,\n\t\t\t\t\t\t\t\t\t\t\t\t   int start,\n\t\t\t\t\t\t\t\t\t\t\t\t   int targetChar,\n\t\t\t\t\t\t\t\t\t\t\t\t   int separatorChar,\n\t\t\t\t\t\t\t\t\t\t\t\t   List<String> args)\n\t{\n\t\tif ( actionText==null ) {\n\t\t\treturn -1;\n\t\t}\n\t\tactionText = actionText.replaceAll(\"//.*\\n\", \"\");\n\t\tint n = actionText.length();\n\t\t//System.out.println(\"actionText@\"+start+\"->\"+(char)targetChar+\"=\"+actionText.substring(start,n));\n\t\tint p = start;\n\t\tint last = p;\n\t\twhile ( p<n && actionText.charAt(p)!=targetChar ) {\n\t\t\tint c = actionText.charAt(p);\n\t\t\tswitch ( c ) {\n\t\t\t\tcase '\\'' :\n\t\t\t\t\tp++;\n\t\t\t\t\twhile ( p<n && actionText.charAt(p)!='\\'' ) {\n\t\t\t\t\t\tif ( actionText.charAt(p)=='\\\\' && (p+1)<n &&\n\t\t\t\t\t\t\t actionText.charAt(p+1)=='\\'' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++; // skip escaped quote\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '\"' :\n\t\t\t\t\tp++;\n\t\t\t\t\twhile ( p<n && actionText.charAt(p)!='\\\"' ) {\n\t\t\t\t\t\tif ( actionText.charAt(p)=='\\\\' && (p+1)<n &&\n\t\t\t\t\t\t\t actionText.charAt(p+1)=='\\\"' )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tp++; // skip escaped quote\n\t\t\t\t\t\t}\n\t\t\t\t\t\tp++;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '(' :\n\t\t\t\t\tp = getListOfArgumentsFromAction(actionText,p+1,')',separatorChar,args);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '{' :\n\t\t\t\t\tp = getListOfArgumentsFromAction(actionText,p+1,'}',separatorChar,args);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '<' :\n\t\t\t\t\tif ( actionText.indexOf('>',p+1)>=p ) {\n\t\t\t\t\t\t// do we see a matching '>' ahead?  if so, hope it's a generic\n\t\t\t\t\t\t// and not less followed by expr with greater than\n\t\t\t\t\t\tp = getListOfArgumentsFromAction(actionText,p+1,'>',separatorChar,args);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tp++; // treat as normal char\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase '[' :\n\t\t\t\t\tp = getListOfArgumentsFromAction(actionText,p+1,']',separatorChar,args);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tif ( c==separatorChar && targetChar==-1 ) {\n\t\t\t\t\t\tString arg = actionText.substring(last, p);\n\t\t\t\t\t\t//System.out.println(\"arg=\"+arg);\n\t\t\t\t\t\targs.add(arg.trim());\n\t\t\t\t\t\tlast = p+1;\n\t\t\t\t\t}\n\t\t\t\t\tp++;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif ( targetChar==-1 && p<=n ) {\n\t\t\tString arg = actionText.substring(last, p).trim();\n\t\t\t//System.out.println(\"arg=\"+arg);\n\t\t\tif ( arg.length()>0 ) {\n\t\t\t\targs.add(arg.trim());\n\t\t\t}\n\t\t}\n\t\tp++;\n\t\treturn p;\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NumberLiteral#PrefixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#StringLiteral#StringLiteral#MethodInvocation#Assignment#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#InfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#CharacterLiteral#SwitchCase#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#PostfixExpression#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#CharacterLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#WhileStatement#SimpleName#PostfixExpression#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#CharacterLiteral#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#CharacterLiteral#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#SimpleName#SimpleName#CharacterLiteral#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#CharacterLiteral#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#BreakStatement#CharacterLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#CharacterLiteral#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#BreakStatement#SwitchCase#SimpleName#SimpleName#InfixExpression#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#BreakStatement#SwitchStatement#Block#WhileStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(SwitchStatement(SimpleName)SimpleName(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(WhileStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(SimpleName)SimpleName)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)WhileStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(CharacterLiteral)CharacterLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(CharacterLiteral)CharacterLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(CharacterLiteral)CharacterLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(CharacterLiteral)CharacterLiteral(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase)SwitchCase(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(BreakStatement)BreakStatement)SwitchStatement)Block)WhileStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given an arg action like [x, (", "call_func_name": ["java.lang.String.replaceAll", "java.lang.String.length", "java.lang.String.charAt", "org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction", "java.lang.String.indexOf", "java.lang.String.substring", "java.lang.String.trim", "java.util.List.add"], "call_func_parameter": [["java.lang.String", "java.lang.String"], [""], ["int"], ["java.lang.String", "int", "int", "int", "java.util.List"], ["int", "int"], ["int", "int"], [""], ["java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.getListOfArgumentsFromAction": "Given an arg action like [x, ("}]}, {"index": "732", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.translateTemplateConstructor", "methodParameterType": "String#int#Token#String#", "methodParameterName": "ruleName#outerAltNum#actionToken#templateActionText#", "methodBody": "public ST translateTemplateConstructor(String ruleName,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   int outerAltNum,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   Token actionToken,\n\t\t\t\t\t\t\t\t\t\t\t\t\t   String templateActionText)\n\t{\n\t\t// first, parse with antlr.g\n\t\t//System.out.println(\"translate template: \"+templateActionText);\n\t\tANTLRLexer lexer = new ANTLRLexer(new ANTLRStringStream(templateActionText));\n\t\tlexer.setFileName(grammar.getFileName());\n\t\tANTLRParser parser = ANTLRParser.createParser(new CommonTokenStream(lexer));\n\t\tparser.setFileName(grammar.getFileName());\n\t\tANTLRParser.rewrite_template_return parseResult = null;\n\t\ttry {\n\t\t\tparseResult = parser.rewrite_template();\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\tErrorManager.grammarError(ErrorManager.MSG_INVALID_TEMPLATE_ACTION,\n\t\t\t\t\t\t\t\t\t\t  grammar,\n\t\t\t\t\t\t\t\t\t\t  actionToken,\n\t\t\t\t\t\t\t\t\t\t  templateActionText);\n\t\t}\n\t\tcatch (Exception tse) {\n\t\t\tErrorManager.internalError(\"can't parse template action\",tse);\n\t\t}\n\t\tGrammarAST rewriteTree = parseResult.getTree();\n\n\t\t// then translate via codegen.g\n\t\tCodeGenTreeWalker gen = new CodeGenTreeWalker(new CommonTreeNodeStream(rewriteTree));\n\t\tgen.init(grammar);\n\t\tgen.setCurrentRuleName(ruleName);\n\t\tgen.setOuterAltNum(outerAltNum);\n\t\tST st = null;\n\t\ttry {\n\t\t\tst = gen.rewrite_template();\n\t\t}\n\t\tcatch (RecognitionException re) {\n\t\t\tErrorManager.error(ErrorManager.MSG_BAD_AST_STRUCTURE,\n\t\t\t\t\t\t\t   re);\n\t\t}\n\t\treturn st;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#NullLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(NullLiteral)NullLiteral)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a template constructor action like %foo(a={...}) in an action, translate it to the appropriate template constructor from the templateLib. This translates a", "call_func_name": ["org.antlr.runtime.ANTLRStringStream.<init>", "org.antlr.grammar.v3.ANTLRLexer.<init>", "org.antlr.tool.Grammar.getFileName", "org.antlr.grammar.v3.ANTLRLexer.setFileName", "org.antlr.runtime.CommonTokenStream.<init>", "org.antlr.grammar.v3.ANTLRParser.createParser", "org.antlr.grammar.v3.ANTLRParser.setFileName", "org.antlr.grammar.v3.ANTLRParser.rewrite_template", "org.antlr.tool.ErrorManager.grammarError", "org.antlr.tool.ErrorManager.internalError", "org.antlr.runtime.tree.CommonTreeNodeStream.<init>", "org.antlr.grammar.v3.CodeGenTreeWalker.<init>", "org.antlr.grammar.v3.CodeGenTreeWalker.init", "org.antlr.grammar.v3.CodeGenTreeWalker.setCurrentRuleName", "org.antlr.grammar.v3.CodeGenTreeWalker.setOuterAltNum", "org.antlr.grammar.v3.CodeGenTreeWalker.rewrite_template", "org.antlr.tool.ErrorManager.error"], "call_func_parameter": [["java.lang.String"], ["org.antlr.runtime.CharStream"], [""], ["java.lang.String"], ["org.antlr.runtime.TokenSource"], ["org.antlr.runtime.TokenStream"], ["java.lang.String"], [""], ["int", "org.antlr.tool.Grammar", "org.antlr.runtime.Token", "java.lang.Object"], ["java.lang.Object", "java.lang.Throwable"], ["java.lang.Object"], ["org.antlr.runtime.tree.TreeNodeStream"], ["org.antlr.tool.Grammar"], ["java.lang.String"], ["int"], [""], ["int", "java.lang.Throwable"]], "passed_comments": "/"}, {"index": "733", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.getRecognizerFileName", "methodParameterType": "String#int#", "methodParameterName": "name#type#", "methodBody": "public String getRecognizerFileName(String name, int type) {\n\t\tST extST = templates.getInstanceOf(\"codeFileExtension\");\n\t\tString recognizerName = grammar.getRecognizerName();\n\t\treturn recognizerName+extST.render();\n\t\t/*\n\t\tString suffix = \"\";\n\t\tif ( type==Grammar.COMBINED ||\n\t\t\t (type==Grammar.LEXER && !grammar.implicitLexer) )\n\t\t{\n\t\t\tsuffix = Grammar.grammarTypeToFileNameSuffix[type];\n\t\t}\n\t\treturn name+suffix+extST.toString();\n\t\t*/\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Generate TParser.java and TLexer.java from T.g if combined, else just use T.java as output regardless of type.", "call_func_name": ["org.stringtemplate.v4.STGroup.getInstanceOf", "org.antlr.tool.Grammar.getRecognizerName", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.stringtemplate.v4.ST.render", "java.lang.StringBuilder.toString"], "call_func_parameter": [["java.lang.String"], [""], [""], ["java.lang.String"], [""], [""]], "passed_comments": [{"org.antlr.tool.Grammar.getRecognizerName": "Get the name of the generated recognizer; may or may not be same as grammar name. Recognizer is TParser and TLexer from T if combined, else just use T regardless of grammar type."}]}, {"index": "734", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.getVocabFileName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getVocabFileName() {\n\t\tif ( grammar.isBuiltFromString() ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn grammar.name+VOCAB_FILE_EXTENSION;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "What is the name of the vocab file generated for this grammar? Returns null if no .tokens file should be generated.", "call_func_name": ["org.antlr.tool.Grammar.isBuiltFromString", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "735", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.canGenerateSwitch", "methodParameterType": "DFAState#", "methodParameterName": "s#", "methodBody": "protected boolean canGenerateSwitch(DFAState s) {\n\t\tif ( !GENERATE_SWITCHES_WHEN_POSSIBLE ) {\n\t\t\treturn false;\n\t\t}\n\t\tint size = 0;\n\t\tfor (int i = 0; i < s.getNumberOfTransitions(); i++) {\n\t\t\tTransition edge = s.transition(i);\n\t\t\tif ( edge.label.isSemanticPredicate() ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// can't do a switch if the edges are going to require predicates\n\t\t\tif ( edge.label.getAtom()==Label.EOT ) {\n\t\t\t\tint EOTPredicts = ((DFAState)edge.target).getUniquelyPredictedAlt();\n\t\t\t\tif ( EOTPredicts==NFA.INVALID_ALT_NUMBER ) {\n\t\t\t\t\t// EOT target has to be a predicate then; no unique alt\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// if target is a state with gated preds, we need to use preds on\n\t\t\t// this edge then to reach it.\n\t\t\tif ( ((DFAState)edge.target).getGatedPredicatesInNFAConfigurations()!=null ) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tsize += edge.label.getSet().size();\n\t\t}\n\t\tif ( s.getNumberOfTransitions()<MIN_SWITCH_ALTS ||\n\t\t\t size>MAX_SWITCH_CASE_LABELS ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#PrefixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#QualifiedName#CastExpression#ParenthesizedExpression#SimpleName#MethodInvocation#NullLiteral#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#SimpleName#SimpleName#InfixExpression#InfixExpression#BooleanLiteral#ReturnStatement#Block#IfStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(PrefixExpression(SimpleName)SimpleName)PrefixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(ParenthesizedExpression(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)CastExpression)ParenthesizedExpression(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)ForStatement(IfStatement(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "You can generate a switch rather than if-then-else for a DFA state if there are no semantic predicates and the number of edge label values is small enough; e.g., don't generate a switch for a state containing an edge label such as 20..52330 (the resulting byte codes would overflow the method 65k limit probably).", "call_func_name": ["org.antlr.analysis.DFAState.getNumberOfTransitions", "org.antlr.analysis.DFAState.transition", "org.antlr.analysis.Label.isSemanticPredicate", "org.antlr.analysis.Label.getAtom", "org.antlr.analysis.DFAState.getUniquelyPredictedAlt", "org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations", "org.antlr.analysis.Label.getSet", "org.antlr.misc.IntSet.size"], "call_func_parameter": [[""], ["int"], [""], [""], [""], [""], [""], [""]], "passed_comments": [{"org.antlr.analysis.Label.getAtom": "return the single atom label or INVALID if not a single atom"}, {"org.antlr.analysis.DFAState.getUniquelyPredictedAlt": "Walk each configuration and if they are all the same alt, return that alt else return NFA.INVALID_ALT_NUMBER.  Ignore resolved configurations, but don't ignore resolveWithPredicate configs because this state should not be an accept state.  We need to add this to the work list and then have semantic predicate edges emanating from it."}, {"org.antlr.analysis.DFAState.getGatedPredicatesInNFAConfigurations": "For gated productions, we need an OR'd list of all predicates for the target of an edge so we can gate the edge based upon the predicates associated with taking that path (if any). For syntactic predicates, we only want to generate predicate evaluations as it transitions to an accept state; waste to do it earlier.  So, only add gated preds derived from manually- specified syntactic predicates if this is an accept state. Also, since configurations w/o gated predicates are like true gated predicates, finding a configuration whose alt has no gated predicate implies we should evaluate the predicate to true. This means the whole edge has to be ungated. Consider: X : ('a' | {p}?=&gt; 'a') | 'a' 'b' ; Here, you 'a' gets you from s0 to s1 but you can't test p because plain 'a' is ok.  It's also ok for starting alt 2.  Hence, you can't test p.  Even on the edge going to accept state for alt 1 of X, you can't test p.  You can get to the same place with and w/o the context. Therefore, it is never ok to test p in this situation.  TODO: cache this as it's called a lot; or at least set bit if &gt;1 present in state"}, {"org.antlr.misc.IntSet.size": "Return the size of this set (not the underlying implementation's allocated memory size, for example)."}]}, {"index": "736", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CodeGenerator.java", "methodName": "org.antlr.codegen.CodeGenerator.createUniqueLabel", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "public String createUniqueLabel(String name) {\n\t\treturn new StringBuffer()\n\t\t\t.append(name).append(uniqueLabelNumber++).toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#ClassInstanceCreation#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#PostfixExpression#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(MethodInvocation(MethodInvocation(MethodInvocation(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(PostfixExpression(SimpleName)SimpleName)PostfixExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a label to track a token / rule reference's result. Technically, this is a place where I break model-view separation as I am creating a variable name that could be invalid in a target language, however, label ::= &lt;ID&gt;&lt;INT&gt; is probably ok in all languages we care about.", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.StringBuffer.append", "java.lang.StringBuffer.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], [""]], "passed_comments": "/"}, {"index": "737", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.isValidActionScope", "methodParameterType": "int#String#", "methodParameterName": "grammarType#scope#", "methodBody": "public boolean isValidActionScope(int grammarType, String scope) {\n\t\tswitch (grammarType) {\n\t\t\tcase Grammar.LEXER :\n\t\t\t\tif ( scope.equals(\"lexer\") ) {return true;}\n\t\t\t\tbreak;\n\t\t\tcase Grammar.PARSER :\n\t\t\t\tif ( scope.equals(\"parser\") ) {return true;}\n\t\t\t\tbreak;\n\t\t\tcase Grammar.COMBINED :\n\t\t\t\tif ( scope.equals(\"parser\") ) {return true;}\n\t\t\t\tif ( scope.equals(\"lexer\") ) {return true;}\n\t\t\t\tbreak;\n\t\t\tcase Grammar.TREE_PARSER :\n\t\t\t\tif ( scope.equals(\"treeparser\") ) {return true;}\n\t\t\t\tbreak;\n\t\t}\n\t\treturn false;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SwitchStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SwitchStatement(SimpleName)SimpleName(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement)SwitchStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is scope in @scope::name {action} valid for this kind of grammar? Targets like C++ may want to allow new scopes like headerfile or some such.  The action names themselves are not policed at the moment so targets can add template actions w/o having to recompile ANTLR.", "call_func_name": ["java.lang.String.equals"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "738", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getTokenTypeAsTargetLabel", "methodParameterType": "CodeGenerator#int#", "methodParameterName": "generator#ttype#", "methodBody": "public String getTokenTypeAsTargetLabel(CodeGenerator generator, int ttype) {\n\t\tString name = generator.grammar.getTokenDisplayName(ttype);\n\t\t// If name is a literal, return the token type instead\n\t\tif ( name.charAt(0)=='\\'' ) {\n\t\t\treturn String.valueOf(ttype);\n\t\t}\n\t\treturn name;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Target must be able to override the labels used for token types", "call_func_name": ["org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt", "java.lang.String.valueOf"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "739", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getTargetCharLiteralFromANTLRCharLiteral", "methodParameterType": "CodeGenerator#String#", "methodParameterName": "generator#literal#", "methodBody": "public String getTargetCharLiteralFromANTLRCharLiteral(\n\t\tCodeGenerator generator,\n\t\tString literal)\n\t{\n\t\tStringBuilder buf = new StringBuilder();\n\t\tbuf.append('\\'');\n\t\tint c = Grammar.getCharValueFromGrammarCharLiteral(literal);\n\t\tif ( c<Label.MIN_CHAR_VALUE ) {\n\t\t\treturn \"'\\u0000'\";\n\t\t}\n\t\tif ( c<targetCharValueEscape.length &&\n\t\t\t targetCharValueEscape[c]!=null )\n\t\t{\n\t\t\tbuf.append(targetCharValueEscape[c]);\n\t\t}\n\t\telse if ( Character.UnicodeBlock.of((char)c)==\n\t\t\t\t  Character.UnicodeBlock.BASIC_LATIN &&\n\t\t\t\t  !Character.isISOControl((char)c) )\n\t\t{\n\t\t\t// normal char\n\t\t\tbuf.append((char)c);\n\t\t}\n\t\telse {\n\t\t\t// must be something unprintable...use \\\\uXXXX\n\t\t\t// turn on the bit above max \"\\\\uFFFF\" value so that we pad with zeros\n\t\t\t// then only take last 4 digits\n\t\t\tString hex = Integer.toHexString(c|0x10000).toUpperCase().substring(1,5);\n\t\t\tbuf.append(\"\\\\u\");\n\t\t\tbuf.append(hex);\n\t\t}\n\n\t\tbuf.append('\\'');\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#StringLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#QualifiedName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#SimpleName#SimpleName#QualifiedName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#IfStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)ExpressionStatement)Block(IfStatement(InfixExpression(InfixExpression(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation(QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)QualifiedName)InfixExpression(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement)Block(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert from an ANTLR char literal found in a grammar file to an equivalent char literal in the target language.  For most languages, this means leaving 'x' as 'x'.  Actually, we need to escape ' ' so that it doesn't get converted to \\n by the compiler.  Convert the literal to the char value and then to an appropriate target char literal. Expect single quotes around the incoming literal.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral", "java.lang.StringBuilder.append", "java.lang.Character.isISOControl", "java.lang.Integer.toHexString", "java.lang.String.toUpperCase", "java.lang.String.substring", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["char"], ["java.lang.String"], ["java.lang.String"], ["char"], ["int"], [""], ["int", "int"], [""]], "passed_comments": [{"org.antlr.tool.Grammar.getCharValueFromGrammarCharLiteral": "Given a literal like (the 3 char sequence with single quotes) 'a', return the int value of 'a'. Convert escape sequences here also. ANTLR's antlr.g parser does not convert escape sequences. 11/26/2005: I changed literals to always be '...' even for strings. This routine still works though."}]}, {"index": "740", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getTargetStringLiteralFromANTLRStringLiteral", "methodParameterType": "CodeGenerator#String#", "methodParameterName": "generator#literal#", "methodBody": "public String getTargetStringLiteralFromANTLRStringLiteral(\n\t\tCodeGenerator generator,\n\t\tString literal)\n\t{\n        StringBuilder sb = new StringBuilder();\n        StringBuilder is = new StringBuilder(literal);\n        \n        // Opening quote\n        //\n        sb.append('\"');\n        \n        for (int i = 1; i < is.length() -1; i++) {\n            if  (is.charAt(i) == '\\\\') {\n                // Anything escaped is what it is! We assume that\n                // people know how to escape characters correctly. However\n                // we catch anything that does not need an escape in Java (which\n                // is what the default implementation is dealing with and remove \n                // the escape. The C target does this for instance.\n                //\n                switch (is.charAt(i+1)) {\n                    // Pass through any escapes that Java also needs\n                    //\n                    case    '\"':\n                    case    'n':\n                    case    'r':\n                    case    't':\n                    case    'b':\n                    case    'f':\n                    case    '\\\\':\n                    case    'u':    // Assume unnnn\n                        sb.append('\\\\');    // Pass the escape through\n                        break;\n                    default:\n                        // Remove the escape by virtue of not adding it here\n                        // Thus \\' becomes ' and so on\n                        //\n                        break;\n                }\n                \n                // Go past the \\ character\n                //\n                i++;\n            } else {\n                // Chracters that don't need \\ in ANTLR 'strings' but do in Java\n                //\n                if (is.charAt(i) == '\"') {\n                    // We need to escape \" in Java\n                    //\n                    sb.append('\\\\');\n                }\n            }\n            // Add in the next character, which may have been escaped\n            //\n            sb.append(is.charAt(i));   \n        }\n        \n        // Append closing \" and return\n        //\n        sb.append('\"');\n        \n\t\treturn sb.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#BreakStatement#SwitchCase#BreakStatement#SwitchStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(SwitchStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase)SwitchCase(BreakStatement)BreakStatement)SwitchStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert from an ANTLR string literal found in a grammar file to an equivalent string literal in the target language.  For Java, this is the translation 'a\\n\"' &rarr; \"a\\n\\\"\".  Expect single quotes around the incoming literal.  Just flip the quotes and replace double quotes with \\\" Note that we have decided to allow poeple to use '\\\"' without penalty, so we must build the target string in a loop as Utils.replae cannot handle both \\\" and \" without a lot of messing around.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.length", "java.lang.StringBuilder.charAt", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["java.lang.String"], ["char"], [""], ["int"], [""]], "passed_comments": "/"}, {"index": "741", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getTargetStringLiteralFromString", "methodParameterType": "String#boolean#", "methodParameterName": "s#quoted#", "methodBody": "public String getTargetStringLiteralFromString(String s, boolean quoted) {\n\t\tif ( s==null ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tStringBuilder buf = new StringBuilder();\n\t\tif ( quoted ) {\n\t\t\tbuf.append('\"');\n\t\t}\n\t\tfor (int i=0; i<s.length(); i++) {\n\t\t\tint c = s.charAt(i);\n\t\t\tif ( c!='\\'' && // don't escape single quotes in strings for java\n\t\t\t\t c<targetCharValueEscape.length &&\n\t\t\t\t targetCharValueEscape[c]!=null )\n\t\t\t{\n\t\t\t\tbuf.append(targetCharValueEscape[c]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuf.append((char)c);\n\t\t\t}\n\t\t}\n\t\tif ( quoted ) {\n\t\t\tbuf.append('\"');\n\t\t}\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#ArrayAccess#NullLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleName#PrimitiveType#SimpleName#CastExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess(NullLiteral)NullLiteral)InfixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(SimpleName)SimpleName)CastExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)ForStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Given a random string of Java unicode chars, return a new string with optionally appropriate quote characters for target language and possibly with some escaped characters.  For example, if the incoming string has actual newline characters, the output of this method would convert them to the two char sequence \\n for Java, C, C++, ...  The new string has double-quotes around it as well.  Example String in memory: a\"[newlinechar]b'c[carriagereturnchar]d[tab]e\\f would be converted to the valid Java s: \"a\\\"\\nb'c\\rd\\te\\\\f\" or a\\\"\\nb'c\\rd\\te\\\\f depending on the quoted arg.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.String.length", "java.lang.String.charAt", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [[""], ["char"], [""], ["int"], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "742", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getTarget64BitStringFromValue", "methodParameterType": "long#", "methodParameterName": "word#", "methodBody": "public String getTarget64BitStringFromValue(long word) {\n\t\tint numHexDigits = 8*2;\n\t\tStringBuilder buf = new StringBuilder(numHexDigits+2);\n\t\tbuf.append(\"0x\");\n\t\tString digits = Long.toHexString(word);\n\t\tdigits = digits.toUpperCase();\n\t\tint padding = numHexDigits - digits.length();\n\t\t// pad left with zeros\n\t\tfor (int i=1; i<=padding; i++) {\n\t\t\tbuf.append('0');\n\t\t}\n\t\tbuf.append(digits);\n\t\treturn buf.toString();\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#NumberLiteral#NumberLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#NumberLiteral#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert long to 0xNNNNNNNNNNNNNNNN by default for spitting out with bitsets.  I.e., convert bytes to hex string.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.Long.toHexString", "java.lang.String.toUpperCase", "java.lang.String.length", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [["int"], ["java.lang.String"], ["long"], [""], [""], ["char"], [""]], "passed_comments": "/"}, {"index": "743", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.getMaxCharValue", "methodParameterType": "CodeGenerator#", "methodParameterName": "generator#", "methodBody": "public int getMaxCharValue(CodeGenerator generator) {\n\t\treturn Label.MAX_CHAR_VALUE;\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Some targets only support ASCII or 8-bit chars/strings.  For example, C++ will probably want to return 0xFF here.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "744", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Target.java", "methodName": "org.antlr.codegen.Target.postProcessAction", "methodParameterType": "List<Object>#Token#", "methodParameterName": "chunks#actionToken#", "methodBody": "public List<Object> postProcessAction(List<Object> chunks, Token actionToken) {\n\t\treturn chunks;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Give target a chance to do some postprocessing on actions. Python for example will have to fix the indention.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "745", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CTarget.java", "methodName": "org.antlr.codegen.CTarget.isValidActionScope", "methodParameterType": "int#String#", "methodParameterName": "grammarType#scope#", "methodBody": "@Override\n    public boolean isValidActionScope(int grammarType, String scope) {\n        switch (grammarType) {\n            case Grammar.LEXER:\n                if (scope.equals(\"lexer\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                break;\n            case Grammar.PARSER:\n                if (scope.equals(\"parser\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                break;\n            case Grammar.COMBINED:\n                if (scope.equals(\"parser\")) {\n                    return true;\n                }\n                if (scope.equals(\"lexer\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                break;\n            case Grammar.TREE_PARSER:\n                if (scope.equals(\"treeparser\")) {\n                    return true;\n                }\n                if (scope.equals(\"header\")) {\n                    return true;\n                }\n                if (scope.equals(\"includes\")) {\n                    return true;\n                }\n                if (scope.equals(\"preincludes\")) {\n                    return true;\n                }\n                if (scope.equals(\"overrides\")) {\n                    return true;\n                }\n                break;\n        }\n        return false;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SimpleName#SimpleName#QualifiedName#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#BooleanLiteral#ReturnStatement#Block#IfStatement#BreakStatement#SwitchStatement#BooleanLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(SwitchStatement(SimpleName)SimpleName(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement(SwitchCase(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SwitchCase(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)IfStatement(BreakStatement)BreakStatement)SwitchStatement(ReturnStatement(BooleanLiteral)BooleanLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Is scope in @scope::name {action} valid for this kind of grammar? Targets like C++ may want to allow new scopes like headerfile or some such.  The action names themselves are not policed at the moment so targets can add template actions w/o having to recompile ANTLR.", "call_func_name": ["java.lang.String.equals"], "call_func_parameter": [["java.lang.Object"]], "passed_comments": "/"}, {"index": "746", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CTarget.java", "methodName": "org.antlr.codegen.CTarget.getTargetStringLiteralFromANTLRStringLiteral", "methodParameterType": "CodeGenerator#String#", "methodParameterName": "generator#literal#", "methodBody": "@Override\n    public String getTargetStringLiteralFromANTLRStringLiteral(\n            CodeGenerator generator,\n            String literal) {\n        int index;\n        String bytes;\n        StringBuilder buf = new StringBuilder();\n\n        buf.append(\"{ \");\n\n        // We need ot lose any escaped characters of the form \\x and just\n        // replace them with their actual values as well as lose the surrounding\n        // quote marks.\n        //\n        for (int i = 1; i < literal.length() - 1; i++) {\n            buf.append(\"0x\");\n\n            if (literal.charAt(i) == '\\\\') {\n                i++; // Assume that there is a next character, this will just yield\n                // invalid strings if not, which is what the input would be of course - invalid\n                switch (literal.charAt(i)) {\n                    case 'u':\n                    case 'U':\n                        buf.append(literal.substring(i + 1, i + 5));  // Already a hex string\n                        i = i + 5;                                // Move to next string/char/escape\n                        break;\n\n                    case 'n':\n                    case 'N':\n\n                        buf.append(\"0A\");\n                        break;\n\n                    case 'r':\n                    case 'R':\n\n                        buf.append(\"0D\");\n                        break;\n\n                    case 't':\n                    case 'T':\n\n                        buf.append(\"09\");\n                        break;\n\n                    case 'b':\n                    case 'B':\n\n                        buf.append(\"08\");\n                        break;\n\n                    case 'f':\n                    case 'F':\n\n                        buf.append(\"0C\");\n                        break;\n\n                    default:\n\n                        // Anything else is what it is!\n                        //\n                        buf.append(Integer.toHexString((int) literal.charAt(i)).toUpperCase());\n                        break;\n                }\n            } else {\n                buf.append(Integer.toHexString((int) literal.charAt(i)).toUpperCase());\n            }\n            buf.append(\", \");\n        }\n        buf.append(\" ANTLR3_STRING_TERMINATOR}\");\n\n        bytes = buf.toString();\n        index = strings.indexOf(bytes);\n\n        if (index == -1) {\n            strings.add(bytes);\n            index = strings.indexOf(bytes);\n        }\n\n        String strref = \"lit_\" + String.valueOf(index + 1);\n\n        return strref;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#PostfixExpression#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#NumberLiteral#InfixExpression#Assignment#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#CharacterLiteral#SwitchCase#CharacterLiteral#SwitchCase#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#BreakStatement#SwitchCase#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#BreakStatement#SwitchStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#CastExpression#MethodInvocation#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#ForStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#NumberLiteral#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement(SwitchStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)Assignment)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(SwitchCase(CharacterLiteral)CharacterLiteral)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement(SwitchCase)SwitchCase(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(BreakStatement)BreakStatement)SwitchStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)CastExpression)MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)ForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(PrefixExpression(NumberLiteral)NumberLiteral)PrefixExpression)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert from an ANTLR string literal found in a grammar file to an equivalent string literal in the C target. Because we must support Unicode character sets and have chosen to have the lexer match UTF32 characters, then we must encode string matches to use 32 bit character arrays. Here then we must produce the C array and cater for the case where the lexer has been encoded with a string such as 'xyz\\n',", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.String.length", "java.lang.String.charAt", "java.lang.String.substring", "java.lang.Integer.toHexString", "java.lang.String.toUpperCase", "java.lang.StringBuilder.toString", "java.util.List.indexOf", "java.util.List.add", "java.lang.String.valueOf"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["int"], ["int", "int"], ["int"], [""], [""], ["java.lang.Object"], ["java.lang.Object"], ["int"]], "passed_comments": "/"}, {"index": "747", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/CTarget.java", "methodName": "org.antlr.codegen.CTarget.performGrammarAnalysis", "methodParameterType": "CodeGenerator#Grammar#", "methodParameterName": "generator#grammar#", "methodBody": "@Override\n    protected void performGrammarAnalysis(CodeGenerator generator, Grammar grammar) {\n\n        // Check to see if the maximum inline DFA states is still set to\n        // the default size. If it is then whack it all the way up to the maximum that\n        // we can sensibly get away with.\n        //\n        if (CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE == CodeGenerator.MADSI_DEFAULT ) {\n\n            CodeGenerator.MAX_ACYCLIC_DFA_STATES_INLINE = 65535;\n        }\n\n        // Check to see if the maximum switch size is still set to the default\n        // and bring it up much higher if it is. Modern C compilers can handle\n        // much bigger switch statements than say Java can and if anyone finds a compiler\n        // that cannot deal with such big switches, all the need do is generate the\n        // code with a reduced -Xmaxswitchcaselabels nnn\n        //\n        if  (CodeGenerator.MAX_SWITCH_CASE_LABELS == CodeGenerator.MSCL_DEFAULT) {\n\n            CodeGenerator.MAX_SWITCH_CASE_LABELS = 3000;\n        }\n\n        // Check to see if the number of transitions considered a miminum for using\n        // a switch is still at the default. Because a switch is still generally faster than\n        // an if even with small sets, and given that the optimizer will do the best thing with it\n        // anyway, then we simply want to generate a switch for any number of states.\n        //\n        if (CodeGenerator.MIN_SWITCH_ALTS == CodeGenerator.MSA_DEFAULT) {\n\n            CodeGenerator.MIN_SWITCH_ALTS = 1;\n        }\n\n        // Now we allow the superclass implementation to do whatever it feels it\n        // must do.\n        //\n        super.performGrammarAnalysis(generator, grammar);\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#QualifiedName#NumberLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SuperMethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(SuperMethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)SuperMethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Overrides the standard grammar analysis so we can prepare the analyser a little differently from the other targets. In particular we want to influence the way the code generator makes assumptions about switchs vs ifs, vs table driven DFAs. In general, C code should be generated that has the minimum use of tables, and tha meximum use of large switch statements. This allows the optimizers to generate very efficient code, it can reduce object code size by about 30% and give about a 20% performance improvement over not doing this. Hence, for the C target only, we change the defaults here, but only if they are still set to the defaults.", "call_func_name": ["org.antlr.codegen.Target.performGrammarAnalysis"], "call_func_parameter": [["org.antlr.codegen.CodeGenerator", "org.antlr.tool.Grammar"]], "passed_comments": "/"}, {"index": "748", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/PythonTarget.java", "methodName": "org.antlr.codegen.PythonTarget.getTokenTypeAsTargetLabel", "methodParameterType": "CodeGenerator#int#", "methodParameterName": "generator#ttype#", "methodBody": "@Override\n    public String getTokenTypeAsTargetLabel(CodeGenerator generator,\n\t\t\t\t\t    int ttype) {\n\t// use ints for predefined types;\n\t// <invalid> <EOR> <DOWN> <UP>\n\tif ( ttype >= 0 && ttype <= 3 ) {\n\t    return String.valueOf(ttype);\n\t}\n\n\tString name = generator.grammar.getTokenDisplayName(ttype);\n\n\t// If name is a literal, return the token type instead\n\tif ( name.charAt(0)=='\\'' ) {\n\t    return String.valueOf(ttype);\n\t}\n\n\treturn name;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Target must be able to override the labels used for token types", "call_func_name": ["java.lang.String.valueOf", "org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "749", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/JavaScriptTarget.java", "methodName": "org.antlr.codegen.JavaScriptTarget.encodeIntAsCharEscape", "methodParameterType": "int#", "methodParameterName": "v#", "methodBody": "@Override\n    public String encodeIntAsCharEscape(int v) {\n        String hex = Integer.toHexString(v|0x10000).substring(1,5);\n        return \"\\\\u\"+hex;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#StringLiteral#SimpleName#InfixExpression#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert an int to a JavaScript Unicode character literal. The current JavaScript spec (ECMA-262) doesn't provide for octal notation in String literals, although some implementations support it. This method overrides the parent class so that characters will always be encoded as Unicode literals (e.g. \\u0011).", "call_func_name": ["java.lang.Integer.toHexString", "java.lang.String.substring", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [["int"], ["int", "int"], [""], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "750", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/JavaScriptTarget.java", "methodName": "org.antlr.codegen.JavaScriptTarget.getTarget64BitStringFromValue", "methodParameterType": "long#", "methodParameterName": "word#", "methodBody": "@Override\n    public String getTarget64BitStringFromValue(long word) {\n        StringBuffer buf = new StringBuffer(22); // enough for the two \"0x\", \",\" and \" \"\n        buf.append(\"0x\");\n        writeHexWithPadding(buf, Integer.toHexString((int)(word & 0x00000000ffffffffL)));\n        buf.append(\", 0x\");\n        writeHexWithPadding(buf, Integer.toHexString((int)(word >> 32)));\n\n        return buf.toString();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#NumberLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(NumberLiteral)NumberLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert long to two 32-bit numbers separted by a comma. JavaScript does not support 64-bit numbers, so we need to break the number into two 32-bit literals to give to the Bit.  A number like 0xHHHHHHHHLLLLLLLL is broken into the following string: \"0xLLLLLLLL, 0xHHHHHHHH\" Note that the low order bits are first, followed by the high order bits. This is to match how the BitSet constructor works, where the bits are passed in in 32-bit chunks with low-order bits coming first. Note: stole the following two methods from the ActionScript target.", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.Integer.toHexString", "org.antlr.codegen.JavaScriptTarget.writeHexWithPadding", "java.lang.StringBuffer.toString"], "call_func_parameter": [["int"], ["java.lang.String"], ["int"], ["java.lang.StringBuffer", "java.lang.String"], [""]], "passed_comments": "/"}, {"index": "751", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java", "methodName": "org.antlr.codegen.ActionScriptTarget.encodeIntAsCharEscape", "methodParameterType": "int#", "methodParameterName": "v#", "methodBody": "@Override\n    public String encodeIntAsCharEscape(int v) {\n        // encode as hex\n        if ( v<=255 ) {\n\t\t\treturn \"\\\\x\"+ Integer.toHexString(v|0x100).substring(1,3);\n\t\t}\n        if (v <= 0x7fff) {\n            String hex = Integer.toHexString(v|0x10000).substring(1,5);\n\t\t    return \"\\\\u\"+hex;\n        }\n        if (v > 0xffff) {\n            System.err.println(\"Warning: character literal out of range for ActionScript target \" + v);\n            return \"\";\n        }\n        StringBuilder buf = new StringBuilder(\"\\\\u80\");\n        buf.append(Integer.toHexString((v >> 8) | 0x100).substring(1, 3)); // high - order bits\n        buf.append(\"\\\\x\");\n        buf.append(Integer.toHexString((v & 0xff) | 0x100).substring(1, 3)); // low -order bits\n        return buf.toString();\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#StringLiteral#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#StringLiteral#SimpleName#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#StringLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#NumberLiteral#InfixExpression#MethodInvocation#SimpleName#NumberLiteral#NumberLiteral#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)InfixExpression)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ReturnStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral(NumberLiteral)NumberLiteral)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "ActionScript doesn't support Unicode String literals that are considered \"illegal\" or are in the surrogate pair ranges.  For example \"/uffff\" will not encode properly nor will \"/ud800\".  To keep things as compact as possible we use the following encoding if the int is below 255, we encode as hex literal If the int is between 255 and 0x7fff we use a single unicode literal with the value If the int is above 0x7fff, we use a unicode literal of 0x80hh, where hh is the high-order bits followed by \\xll where ll is the lower order bits of a 16-bit number. Ideally this should be improved at a future date.  The most optimal way to encode this may be a compressed AMF encoding that is embedded using an Embed tag in ActionScript.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.Integer.toHexString", "java.lang.String.substring", "java.lang.StringBuilder.toString", "java.lang.StringBuilder.append", "java.io.PrintStream.println", "java.lang.StringBuilder.<init>"], "call_func_parameter": [[""], ["java.lang.String"], ["int"], ["int", "int"], [""], ["int"], ["java.lang.String"], ["java.lang.String"]], "passed_comments": "/"}, {"index": "752", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/ActionScriptTarget.java", "methodName": "org.antlr.codegen.ActionScriptTarget.getTarget64BitStringFromValue", "methodParameterType": "long#", "methodParameterName": "word#", "methodBody": "@Override\n\tpublic String getTarget64BitStringFromValue(long word) {\n\t\tStringBuffer buf = new StringBuffer(22); // enough for the two \"0x\", \",\" and \" \"\n\t\tbuf.append(\"0x\");\n        writeHexWithPadding(buf, Integer.toHexString((int)(word & 0x00000000ffffffffL)));\n        buf.append(\", 0x\");\n        writeHexWithPadding(buf, Integer.toHexString((int)(word >> 32)));\n\n        return buf.toString();\n\t}", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#NumberLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#PrimitiveType#SimpleName#NumberLiteral#InfixExpression#ParenthesizedExpression#CastExpression#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(NumberLiteral)NumberLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CastExpression(PrimitiveType)PrimitiveType(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)ParenthesizedExpression)CastExpression)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert long to two 32-bit numbers separted by a comma. ActionScript does not support 64-bit numbers, so we need to break the number into two 32-bit literals to give to the Bit.  A number like 0xHHHHHHHHLLLLLLLL is broken into the following string: \"0xLLLLLLLL, 0xHHHHHHHH\" Note that the low order bits are first, followed by the high order bits. This is to match how the BitSet constructor works, where the bits are passed in in 32-bit chunks with low-order bits coming first.", "call_func_name": ["java.lang.StringBuffer.<init>", "java.lang.StringBuffer.append", "java.lang.Integer.toHexString", "org.antlr.codegen.ActionScriptTarget.writeHexWithPadding", "java.lang.StringBuffer.toString"], "call_func_parameter": [["int"], ["java.lang.String"], ["int"], ["java.lang.StringBuffer", "java.lang.String"], [""]], "passed_comments": "/"}, {"index": "753", "file": "/root/repos/repos29/antlr3/tool/src/main/java/org/antlr/codegen/Python3Target.java", "methodName": "org.antlr.codegen.Python3Target.getTokenTypeAsTargetLabel", "methodParameterType": "CodeGenerator#int#", "methodParameterName": "generator#ttype#", "methodBody": "@Override\n    public String getTokenTypeAsTargetLabel(CodeGenerator generator,\n\t\t\t\t\t    int ttype) {\n\t// use ints for predefined types;\n\t// <invalid> <EOR> <DOWN> <UP>\n\tif ( ttype >= 0 && ttype <= 3 ) {\n\t    return String.valueOf(ttype);\n\t}\n\n\tString name = generator.grammar.getTokenDisplayName(ttype);\n\n\t// If name is a literal, return the token type instead\n\tif ( name.charAt(0)=='\\'' ) {\n\t    return String.valueOf(ttype);\n\t}\n\n\treturn name;\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#NumberLiteral#InfixExpression#SimpleName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#NumberLiteral#MethodInvocation#CharacterLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(CharacterLiteral)CharacterLiteral)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Target must be able to override the labels used for token types", "call_func_name": ["java.lang.String.valueOf", "org.antlr.tool.Grammar.getTokenDisplayName", "java.lang.String.charAt"], "call_func_parameter": [["int"], ["int"], ["int"]], "passed_comments": [{"org.antlr.tool.Grammar.getTokenDisplayName": "Given a token type, get a meaningful name for it such as the ID or string literal.  If this is a lexer and the ttype is in the char vocabulary, compute an ANTLR-valid (possibly escaped) char literal."}]}, {"index": "754", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/ActionTranslator.java", "methodName": "org.antlr.grammar.v3.ActionTranslator.translateToChunks", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public List<Object> translateToChunks() {\n\t\t// System.out.println(\"###\\naction=\"+action);\n\t\tToken t;\n\t\tdo {\n\t\t\tt = nextToken();\n\t\t} while ( t.getType()!= Token.EOF );\n\t\treturn chunks;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#DoStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(DoStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)DoStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a list of strings and ST objects that represent the translated action.", "call_func_name": ["org.antlr.grammar.v3.ActionTranslator.nextToken", "org.antlr.runtime.Token.getType"], "call_func_parameter": [[""], [""]], "passed_comments": "/"}, {"index": "755", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/ActionTranslator.java", "methodName": "org.antlr.grammar.v3.ActionTranslator.getRuleLabelAttribute", "methodParameterType": "String#String#", "methodParameterName": "ruleName#attrName#", "methodBody": "public Attribute getRuleLabelAttribute(String ruleName, String attrName) {\n\t\tRule r = grammar.getRule(ruleName);\n\t\tAttributeScope scope = r.getLocalAttributeScope(attrName);\n\t\tif ( scope!=null && !scope.isParameterScope ) {\n\t\t\treturn scope.getAttribute(attrName);\n\t\t}\n\t\treturn null;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#PrefixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#IfStatement#NullLiteral#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression)InfixExpression(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)IfStatement(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)MethodDeclaration", "methodDoc": "For $rulelabel.name, return the Attribute found for name.  It will be a predefined property or a return value.", "call_func_name": ["org.antlr.tool.Grammar.getRule", "org.antlr.tool.Rule.getLocalAttributeScope", "org.antlr.tool.AttributeScope.getAttribute"], "call_func_parameter": [["java.lang.String"], ["java.lang.String"], ["java.lang.String"]], "passed_comments": [{"org.antlr.tool.Rule.getLocalAttributeScope": "Get the arg, return value, or predefined property for this rule"}]}, {"index": "756", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/ANTLRParser.java", "methodName": "org.antlr.grammar.v3.ANTLRParser.createBlockFromDupAlt", "methodParameterType": "GrammarAST#", "methodParameterName": "alt#", "methodBody": "protected GrammarAST createBlockFromDupAlt(GrammarAST alt) {\n\t    /*\n\t     * ^(BLOCK[\"BLOCK\"] {GrammarAST.dupTreeNoActions(alt)} EOB[\"<end-of-block>\"])\n\t     */\n\t    GrammarAST nalt = GrammarAST.dupTreeNoActions(alt, null);\n\n\t    GrammarAST block = (GrammarAST)adaptor.create(BLOCK, alt.getToken(), \"BLOCK\");\n\t    adaptor.addChild( block, nalt );\n\t    adaptor.addChild( block, adaptor.create( EOB, \"<end-of-block>\" ) );\n\n\t    return block;\n\t}", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)MethodInvocation)ExpressionStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Create a copy of the alt and make it into a BLOCK; all actions, labels, tree operators, rewrites are removed.", "call_func_name": ["org.antlr.tool.GrammarAST.dupTreeNoActions", "org.antlr.tool.GrammarAST.getToken", "org.antlr.runtime.tree.TreeAdaptor.create", "org.antlr.runtime.tree.TreeAdaptor.addChild", "org.antlr.runtime.tree.TreeAdaptor.create"], "call_func_parameter": [["org.antlr.tool.GrammarAST", "org.antlr.tool.GrammarAST"], [""], ["int", "org.antlr.runtime.Token", "java.lang.String"], ["java.lang.Object", "java.lang.Object"], ["int", "java.lang.String"]], "passed_comments": [{"org.antlr.tool.GrammarAST.dupTreeNoActions": "Duplicate a tree, assuming this is a root node of a tree-- duplicate that node and what's below; ignore siblings of root node."}, {"org.antlr.runtime.tree.TreeAdaptor.create": "Same as create(tokenType,fromToken) except set the text too. This is invoked from an imaginary node ref on right side of a rewrite rule as IMAG[$tokenLabel, \"IMAG\"]. This should invoke createToken(Token)."}, {"org.antlr.runtime.tree.TreeAdaptor.addChild": "Add a child to the tree t.  If child is a flat tree (a list), make all in list children of t.  Warning: if t has no children, but child does and child isNil then you can decide it is ok to move children to t via t.children = child.children; i.e., without copying the array.  Just make sure that this is consistent with have the user will build ASTs.  Do nothing if t or child is null."}, {"org.antlr.runtime.tree.TreeAdaptor.create": "Create a new node derived from a token, with a new token type. This is invoked from an imaginary node ref on right side of a rewrite rule as IMAG[\"IMAG\"]. This should invoke createToken(int,String)."}]}, {"index": "757", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/ANTLRParser.java", "methodName": "org.antlr.grammar.v3.ANTLRParser.prefixWithSynPred", "methodParameterType": "GrammarAST#", "methodParameterName": "alt#", "methodBody": "protected void prefixWithSynPred( GrammarAST alt ) {\n\t    // if they want backtracking and it's not a lexer rule in combined grammar\n\t    String autoBacktrack = (String)grammar.getBlockOption( currentBlockAST, \"backtrack\" );\n\t    if ( autoBacktrack == null )\n\t    {\n\t        autoBacktrack = (String)grammar.getOption( \"backtrack\" );\n\t    }\n\t    if ( autoBacktrack != null && autoBacktrack.equals( \"true\" ) &&\n\t         !( grammarType == Grammar.COMBINED &&\n\t         Rule.getRuleType(currentRuleName) == Grammar.LEXER) &&\n\t         alt.getChild( 0 ).getType() != SYN_SEMPRED )\n\t    {\n\t        // duplicate alt and make a synpred block around that dup'd alt\n\t        GrammarAST synpredBlockAST = createBlockFromDupAlt( alt );\n\n\t        // Create a BACKTRACK_SEMPRED node as if user had typed this in\n\t        // Effectively we replace (xxx)=>xxx with {synpredxxx}? xxx\n\t        GrammarAST synpredAST = createSynSemPredFromBlock( synpredBlockAST,\n\t                                                          BACKTRACK_SEMPRED );\n\n\t        // insert BACKTRACK_SEMPRED as first element of alt\n\t        //synpredAST.getLastSibling().setNextSibling( alt.getFirstChild() );\n\t        //synpredAST.addChild( alt.getFirstChild() );\n\t        //alt.setFirstChild( synpredAST );\n\t        GrammarAST[] children = alt.getChildrenAsArray();\n\t        adaptor.setChild( alt, 0, synpredAST );\n\t        for ( int i = 0; i < children.length; i++ )\n\t        {\n\t            if ( i < children.length - 1 )\n\t                adaptor.setChild( alt, i + 1, children[i] );\n\t            else\n\t                adaptor.addChild( alt, children[i] );\n\t        }\n\t    }\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#MethodInvocation#CastExpression#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#InfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#ParenthesizedExpression#PrefixExpression#InfixExpression#SimpleName#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#SimpleName#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#QualifiedName#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#SimpleName#NumberLiteral#InfixExpression#SimpleName#SimpleName#ArrayAccess#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#ArrayAccess#MethodInvocation#ExpressionStatement#IfStatement#Block#ForStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(CastExpression(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)CastExpression)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)InfixExpression(PrefixExpression(ParenthesizedExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression)ParenthesizedExpression)PrefixExpression)InfixExpression(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(NumberLiteral)NumberLiteral)InfixExpression(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(ArrayAccess(SimpleName)SimpleName(SimpleName)SimpleName)ArrayAccess)MethodInvocation)ExpressionStatement)IfStatement)Block)ForStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Rewrite alt to have a synpred as first element; (xxx)=&gt;xxx but only if they didn't specify one manually.", "call_func_name": ["org.antlr.tool.Grammar.getBlockOption", "org.antlr.tool.Grammar.getOption", "java.lang.String.equals", "org.antlr.tool.Rule.getRuleType", "org.antlr.tool.GrammarAST.getChild", "org.antlr.runtime.tree.Tree.getType", "org.antlr.grammar.v3.ANTLRParser.createBlockFromDupAlt", "org.antlr.grammar.v3.ANTLRParser.createSynSemPredFromBlock", "org.antlr.tool.GrammarAST.getChildrenAsArray", "org.antlr.runtime.tree.TreeAdaptor.setChild", "org.antlr.runtime.tree.TreeAdaptor.addChild"], "call_func_parameter": [["org.antlr.tool.GrammarAST", "java.lang.String"], ["java.lang.String"], ["java.lang.Object"], ["java.lang.String"], ["int"], [""], ["org.antlr.tool.GrammarAST"], ["org.antlr.tool.GrammarAST", "int"], [""], ["java.lang.Object", "int", "java.lang.Object"], ["java.lang.Object", "java.lang.Object"]], "passed_comments": [{"org.antlr.runtime.tree.Tree.getType": "Return a token type; needed for tree parsing"}, {"org.antlr.grammar.v3.ANTLRParser.createBlockFromDupAlt": "Create a copy of the alt and make it into a BLOCK; all actions, labels, tree operators, rewrites are removed."}, {"org.antlr.runtime.tree.TreeAdaptor.setChild": "Set ith child (0..n-1) to t; t must be non-null and non-nil node"}, {"org.antlr.runtime.tree.TreeAdaptor.addChild": "Add a child to the tree t.  If child is a flat tree (a list), make all in list children of t.  Warning: if t has no children, but child does and child isNil then you can decide it is ok to move children to t via t.children = child.children; i.e., without copying the array.  Just make sure that this is consistent with have the user will build ASTs.  Do nothing if t or child is null."}]}, {"index": "758", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.java", "methodName": "org.antlr.grammar.v3.CodeGenTreeWalker.getSTSuffix", "methodParameterType": "GrammarAST#GrammarAST#String#", "methodParameterName": "elementAST#ast_suffix#label#", "methodBody": "protected final String getSTSuffix(GrammarAST elementAST, GrammarAST ast_suffix, String label) {\n\t    if ( grammar.type == Grammar.LEXER )\n\t    {\n\t        return \"\";\n\t    }\n\t    // handle list label stuff; make element use \"Track\"\n\n\t    String operatorPart = \"\";\n\t    String rewritePart = \"\";\n\t    String listLabelPart = \"\";\n\t    Rule ruleDescr = grammar.getRule( currentRuleName );\n\t    if ( ast_suffix != null && !ruleDescr.isSynPred )\n\t    {\n\t        if ( ast_suffix.getType() == ANTLRParser.ROOT )\n\t        {\n\t            operatorPart = \"RuleRoot\";\n\t        }\n\t        else if ( ast_suffix.getType() == ANTLRParser.BANG )\n\t        {\n\t            operatorPart = \"Bang\";\n\t        }\n\t    }\n\t    if ( currentAltHasASTRewrite && elementAST.getType() != WILDCARD )\n\t    {\n\t        rewritePart = \"Track\";\n\t    }\n\t    if ( isListLabel( label ) )\n\t    {\n\t        listLabelPart = \"AndListLabel\";\n\t    }\n\t    String STsuffix = operatorPart + rewritePart + listLabelPart;\n\t    //JSystem.@out.println(\"suffix = \"+STsuffix);\n\n\t    return STsuffix;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#StringLiteral#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#StringLiteral#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#PrefixExpression#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#IfStatement#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#InfixExpression#InfixExpression#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(StringLiteral)StringLiteral)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(PrefixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)PrefixExpression)InfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block)IfStatement)IfStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block)IfStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(StringLiteral)StringLiteral)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Return a non-empty template name suffix if the token is to be tracked, added to a tree, or both.", "call_func_name": ["org.antlr.tool.Grammar.getRule", "org.antlr.tool.GrammarAST.getType", "org.antlr.grammar.v3.CodeGenTreeWalker.isListLabel", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString"], "call_func_parameter": [["java.lang.String"], [""], ["java.lang.String"], [""], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "759", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/CodeGenTreeWalker.java", "methodName": "org.antlr.grammar.v3.CodeGenTreeWalker.getTokenTypesAsTargetLabels", "methodParameterType": "Collection<GrammarAST>#", "methodParameterName": "refs#", "methodBody": "protected final List<String> getTokenTypesAsTargetLabels(Collection<GrammarAST> refs)\n\t{\n\t    if ( refs == null || refs.size() == 0 )\n\t        return null;\n\n\t    List<String> labels = new ArrayList<String>( refs.size() );\n\t    for ( GrammarAST t : refs )\n\t    {\n\t        String label;\n\t        if ( t.getType() == ANTLRParser.RULE_REF || t.getType() == ANTLRParser.TOKEN_REF || t.getType() == ANTLRParser.LABEL)\n\t        {\n\t            label = t.getText();\n\t        }\n\t        else\n\t        {\n\t            // must be char or String literal\n\t            label = generator.getTokenTypeAsTargetLabel(grammar.getTokenType(t.getText()));\n\t        }\n\t        labels.add( label );\n\t    }\n\t    return labels;\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#MethodInvocation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName(SingleVariableDeclaration(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)MethodInvocation)Assignment)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Convert rewrite AST lists to target labels list", "call_func_name": ["java.util.Collection.size", "java.util.ArrayList.<init>", "java.util.Collection.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.antlr.tool.GrammarAST.getType", "org.antlr.tool.GrammarAST.getText", "org.antlr.tool.Grammar.getTokenType", "org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel", "java.util.List.add"], "call_func_parameter": [[""], ["int"], [""], [""], [""], [""], [""], ["java.lang.String"], ["int"], ["java.lang.Object"]], "passed_comments": [{"org.antlr.codegen.CodeGenerator.getTokenTypeAsTargetLabel": "Get a meaningful name for a token type useful during code generation. Literals without associated names are converted to the string equivalent of their integer values. Used to generate x==ID and x==34 type comparisons etc...  Essentially we are looking for the most obvious way to refer to a token type in the generated code.  If in the lexer, return the char literal translated to the target language.  For example, ttype=10 will yield '\\n' from the getTokenDisplayName method.  That must be converted to the target languages literals.  For most C-derived languages no translation is needed."}]}, {"index": "760", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/DefineGrammarItemsWalker.java", "methodName": "org.antlr.grammar.v3.DefineGrammarItemsWalker.trimGrammar", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "protected final void trimGrammar() {\n\t    if ( grammar.type != Grammar.COMBINED ) {\n\t        return;\n\t    }\n\t    // form is (header ... ) ( grammar ID (scope ...) ... ( rule ... ) ( rule ... ) ... )\n\t    GrammarAST p = root;\n\t    // find the grammar spec\n\t    while ( !p.getText().equals( \"grammar\" ) ) {\n\t        p = p.getNextSibling();\n\t    }\n\t    for ( int i = 0; i < p.getChildCount(); i++ ) {\n\t        if ( p.getChild( i ).getType() != RULE )\n\t            continue;\n\n\t        String ruleName = p.getChild(i).getChild(0).getText();\n\t        //Console.Out.WriteLine( \"rule \" + ruleName + \" prev=\" + prev.getText() );\n\t        if (Rule.getRuleType(ruleName) == Grammar.LEXER) {\n\t            // remove lexer rule\n\t            p.deleteChild( i );\n\t            i--;\n\t        }\n\t    }\n\t    //Console.Out.WriteLine( \"root after removal is: \" + root.ToStringList() );\n\t}", "AST": "Javadoc#Modifier#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#WhileStatement#PrimitiveType#SimpleName#NumberLiteral#VariableDeclarationFragment#VariableDeclarationExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#PostfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#InfixExpression#ContinueStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#NumberLiteral#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#PostfixExpression#ExpressionStatement#Block#IfStatement#Block#ForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(IfStatement(InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ReturnStatement)ReturnStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(PrefixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)PrefixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block)WhileStatement(ForStatement(VariableDeclarationExpression(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(NumberLiteral)NumberLiteral)VariableDeclarationFragment)VariableDeclarationExpression(InfixExpression(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(PostfixExpression(SimpleName)SimpleName)PostfixExpression(Block(IfStatement(InfixExpression(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)InfixExpression(ContinueStatement)ContinueStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(PostfixExpression(SimpleName)SimpleName)PostfixExpression)ExpressionStatement)Block)IfStatement)Block)ForStatement)Block)MethodDeclaration", "methodDoc": "Remove any lexer rules from a COMBINED; already passed to lexer", "call_func_name": ["org.antlr.tool.GrammarAST.getText", "java.lang.String.equals", "org.antlr.tool.GrammarAST.getNextSibling", "org.antlr.tool.GrammarAST.getChildCount", "org.antlr.tool.GrammarAST.getChild", "org.antlr.runtime.tree.Tree.getType", "org.antlr.runtime.tree.Tree.getChild", "org.antlr.runtime.tree.Tree.getText", "org.antlr.tool.Rule.getRuleType", "org.antlr.tool.GrammarAST.deleteChild"], "call_func_parameter": [[""], ["java.lang.Object"], [""], [""], ["int"], [""], ["int"], [""], ["java.lang.String"], ["int"]], "passed_comments": [{"org.antlr.runtime.tree.Tree.getType": "Return a token type; needed for tree parsing"}]}, {"index": "761", "file": "/root/repos/repos29/antlr3/tool/target/generated-sources/antlr3/org/antlr/grammar/v3/ANTLRTreePrinter.java", "methodName": "org.antlr.grammar.v3.ANTLRTreePrinter.normalize", "methodParameterType": "String#", "methodParameterName": "g#", "methodBody": "public static String normalize(String g) {\n\t    StringTokenizer st = new StringTokenizer(g, \" \", false);\n\t    StringBuffer buf = new StringBuffer();\n\t    while ( st.hasMoreTokens() ) {\n\t        String w = st.nextToken();\n\t        buf.append(w);\n\t        buf.append(\" \");\n\t    }\n\t    return buf.toString().trim();\n\t}", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#StringLiteral#BooleanLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#WhileStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(StringLiteral)StringLiteral(BooleanLiteral)BooleanLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(WhileStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)WhileStatement(ReturnStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Normalize a grammar print out by removing all double spaces and trailing/beginning stuff.  FOr example, convert ( A  |  B  |  C ) to ( A | B | C )", "call_func_name": ["java.util.StringTokenizer.<init>", "java.lang.StringBuffer.<init>", "java.util.StringTokenizer.hasMoreTokens", "java.util.StringTokenizer.nextToken", "java.lang.StringBuffer.append", "java.lang.StringBuffer.toString", "java.lang.String.trim"], "call_func_parameter": [["java.lang.String", "java.lang.String", "boolean"], [""], [""], [""], ["java.lang.String"], [""], [""]], "passed_comments": "/"}, {"index": "762", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/gUnitExecutor.java", "methodName": "org.antlr.gunit.gUnitExecutor.checkForValidInput", "methodParameterType": "CommonTokenStream#PrintStream#", "methodParameterName": "tokens#ps2#", "methodBody": "protected void checkForValidInput(CommonTokenStream tokens, PrintStream ps2) {\n\t\tif ( tokens.index() != tokens.size() - 1 ) {\n\t\t\t//At this point we need to check for redundant EOF tokens\n\t\t\t//which might have been added by the Parser:\n\t\t\tList<? extends Token> endingTokens = tokens.getTokens(tokens.index(), tokens.size() -1);\n\t\t\tfor (Token endToken : endingTokens) {\n\t\t\t\tif (! \"<EOF>\".equals(endToken.getText())) {\n\t\t\t\t\t//writing to ps2 will mark the test as failed:\n\t\t\t\t\tps2.print( \"Invalid input\" );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#PrefixExpression#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#ReturnStatement#Block#IfStatement#Block#EnhancedForStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)InfixExpression(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType(SimpleType(SimpleName)SimpleName)SimpleType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(PrefixExpression(MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ReturnStatement)ReturnStatement)Block)IfStatement)Block)EnhancedForStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Verify the input has been properly consumed", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "763", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/RuleListController.java", "methodName": "org.antlr.gunit.swingui.RuleListController.initComponents", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "private void initComponents() {\n\n        scroll.setViewportBorder(BorderFactory.createEtchedBorder());\n        scroll.setBorder(BorderFactory.createTitledBorder(\n                BorderFactory.createEmptyBorder(), \"Rules\"));\n        scroll.setOpaque(false);\n\n        list.setOpaque(false);\n        list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);\n        list.setLayoutOrientation(JList.VERTICAL);\n        list.setCellRenderer(new RuleListItemRenderer());\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#StringLiteral#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Initialize view.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "764", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuiteFactory.java", "methodName": "org.antlr.gunit.swingui.model.TestSuiteFactory.createTestSuite", "methodParameterType": "File#", "methodParameterName": "grammarFile#", "methodBody": "public static TestSuite createTestSuite(File grammarFile) {\n        if(grammarFile != null && grammarFile.exists() && grammarFile.isFile()) {\n\n            final String fileName = grammarFile.getName();\n            final String grammarName = fileName.substring(0, fileName.lastIndexOf('.'));\n            final String grammarDir = grammarFile.getParent();\n            final File testFile = new File(grammarDir + File.separator + grammarName + TEST_SUITE_EXT);\n\n            final TestSuite result = new TestSuite(grammarName, testFile);\n            result.rules = loadRulesFromGrammar(grammarFile);\n\n            if(saveTestSuite(result)) {\n                return result;\n            } else {\n                throw new RuntimeException(\"Can't save test suite file.\");\n            }\n        } else {\n            throw new RuntimeException(\"Invalid grammar file.\");\n        }\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#MethodInvocation#InfixExpression#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#ReturnStatement#Block#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Block#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(InfixExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(Block(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement)Block(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Factory method: create a testsuite from ANTLR grammar.  Save the test suite file in the same directory of the grammar file.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "765", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuiteFactory.java", "methodName": "org.antlr.gunit.swingui.model.TestSuiteFactory.getScript", "methodParameterType": "TestSuite#", "methodParameterName": "testSuite#", "methodBody": "public static String getScript(TestSuite testSuite) {\n        if(testSuite == null) return null;\n        StringTemplate gUnitScript = templates.getInstanceOf(\"gUnitFile\");\n        gUnitScript.setAttribute(\"testSuite\", testSuite);\n\n        return gUnitScript.toString();\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#NullLiteral#InfixExpression#NullLiteral#ReturnStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the text script from the testSuite.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "766", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuiteFactory.java", "methodName": "org.antlr.gunit.swingui.model.TestSuiteFactory.loadTestSuite", "methodParameterType": "File#", "methodParameterName": "file#", "methodBody": "public static TestSuite loadTestSuite(File file) {\n        if ( file.getName().endsWith(GRAMMAR_EXT) ) {\n            throw new RuntimeException(file.getName()+\" is a grammar file not a gunit file\");\n        }\n        // check grammar file\n        final File grammarFile = getGrammarFile(file);\n        if(grammarFile == null)\n            throw new RuntimeException(\"Can't find grammar file associated with gunit file: \"+file.getAbsoluteFile());\n\n        TestSuite result = new TestSuite(\"\", file);\n\n        // read in test suite\n        try {\n            final Reader reader = new BufferedReader(new FileReader(file));\n            final StGUnitLexer lexer = new StGUnitLexer(new ANTLRReaderStream(reader));\n            final CommonTokenStream tokens = new CommonTokenStream(lexer);\n            final StGUnitParser parser = new StGUnitParser(tokens);\n            final TestSuiteAdapter adapter = new TestSuiteAdapter(result);\n            parser.adapter = adapter;\n            parser.gUnitDef();\n            result.setTokens(tokens);\n            reader.close();\n        } catch (Exception ex) {\n            throw new RuntimeException(\"Error reading test suite file.\\n\" + ex.getMessage());\n        }\n\n        // load un-tested rules from grammar\n        final List<Rule> completeRuleList = loadRulesFromGrammar(grammarFile);\n        for(Rule rule: completeRuleList) {\n            if(!result.hasRule(rule)) {\n                result.addRule(rule);\n                //System.out.println(\"Add rule:\" + rule);\n            }\n        }\n\n        return result;\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#ClassInstanceCreation#ThrowStatement#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#StringLiteral#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#QualifiedName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#CatchClause#TryStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#EnhancedForStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ClassInstanceCreation)ThrowStatement)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName(SimpleName)SimpleName)Assignment)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)CatchClause)TryStatement(VariableDeclarationStatement(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)EnhancedForStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "From textual script to program model.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "767", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/model/TestSuiteFactory.java", "methodName": "org.antlr.gunit.swingui.model.TestSuiteFactory.getGrammarFile", "methodParameterType": "File#", "methodParameterName": "testsuiteFile#", "methodBody": "private static File getGrammarFile(File testsuiteFile) {\n        String sTestFile;\n        try {\n            sTestFile = testsuiteFile.getCanonicalPath();\n        }\n        catch (IOException e) {\n            return null;\n        }\n        // Try Foo.g from Foo.gunit\n        String fname =\n            sTestFile.substring(0, sTestFile.lastIndexOf('.')) + GRAMMAR_EXT;\n        File fileGrammar = new File(fname);\n        if(fileGrammar.exists() && fileGrammar.isFile()) return fileGrammar;\n        // Try FooParser.g from Foo.gunit\n        fname = sTestFile.substring(0, sTestFile.lastIndexOf('.'))+\"Parser\"+GRAMMAR_EXT;\n        if(fileGrammar.exists() && fileGrammar.isFile()) return fileGrammar;\n        return fileGrammar;\n    }", "AST": "Javadoc#Modifier#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#NullLiteral#ReturnStatement#Block#CatchClause#TryStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#MethodInvocation#SimpleName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#ReturnStatement#IfStatement#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#CharacterLiteral#MethodInvocation#MethodInvocation#StringLiteral#SimpleName#InfixExpression#Assignment#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#ReturnStatement#IfStatement#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ReturnStatement(NullLiteral)NullLiteral)ReturnStatement)Block)CatchClause)TryStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)MethodInvocation(SimpleName)SimpleName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ReturnStatement(SimpleName)SimpleName)ReturnStatement)IfStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(CharacterLiteral)CharacterLiteral)MethodInvocation)MethodInvocation(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)Assignment)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(ReturnStatement(SimpleName)SimpleName)ReturnStatement)IfStatement(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Get the grammar file of the testsuite file in the same directory.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "768", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/swingui/runner/ParserLoader.java", "methodName": "org.antlr.gunit.swingui.runner.ParserLoader.ParserLoader", "methodParameterType": "String#String#", "methodParameterName": "grammarName#classDir#", "methodBody": "public ParserLoader(String grammarName, String classDir) throws IOException, ClassNotFoundException {\n\n        final String lexerName = grammarName + \"Lexer\";\n\n        // load all the class files in the \"classDir\" related to the grammarName\n        File dir = new File(classDir);\n        if(dir.isDirectory()) {\n            classList = new HashMap<String, Class<?>>();\n            grammar = grammarName;\n            File[] files = dir.listFiles(new ClassFilenameFilter(grammarName));\n            for(File f : files) {\n\n                // load class data\n                final InputStream in = new BufferedInputStream(new FileInputStream(f));\n                final byte[] classData = new byte[in.available()];\n                in.read(classData);\n                in.close();\n\n                // define class\n                final Class<?> newClass = defineClass(null, classData, 0, classData.length);\n                assert(newClass != null);\n                resolveClass(newClass);\n\n                // save to hashtable\n                final String fileName = f.getName();\n                final String className = fileName.substring(0, fileName.lastIndexOf(\".\"));\n                classList.put(className, newClass);\n                //System.out.println(\"adding: \" + className);\n            }\n        } else {\n            throw new IOException(classDir + \" is not a directory.\");\n        }\n\n        if(classList.isEmpty() || !classList.containsKey(lexerName)) {\n            throw new ClassNotFoundException(lexerName + \" not found.\");\n        }\n\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#StringLiteral#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#WildcardType#ParameterizedType#ParameterizedType#ClassInstanceCreation#Assignment#ExpressionStatement#SimpleName#SimpleName#Assignment#ExpressionStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#PrimitiveType#Dimension#ArrayType#SimpleName#PrimitiveType#Dimension#ArrayType#SimpleName#SimpleName#MethodInvocation#ArrayCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Modifier#SimpleName#SimpleType#WildcardType#ParameterizedType#SimpleName#SimpleName#NullLiteral#SimpleName#NumberLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#ParenthesizedExpression#AssertStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#NumberLiteral#SimpleName#SimpleName#StringLiteral#MethodInvocation#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#InfixExpression#SimpleName#SimpleType#SimpleName#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType)ParameterizedType)ParameterizedType)ClassInstanceCreation)Assignment)ExpressionStatement(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayCreation(ArrayType(PrimitiveType)PrimitiveType(Dimension)Dimension)ArrayType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ArrayCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(Modifier)Modifier(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(WildcardType)WildcardType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(NullLiteral)NullLiteral(SimpleName)SimpleName(NumberLiteral)NumberLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(AssertStatement(ParenthesizedExpression(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression)ParenthesizedExpression)AssertStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Create a class loader for antlr parser/lexer.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "769", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/ITestCase.java", "methodName": "org.antlr.gunit.ITestCase.getTestedRuleName", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public String getTestedRuleName();", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Get the name of the rule that is tested by this test case.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "770", "file": "/root/repos/repos29/antlr3/gunit/src/main/java/org/antlr/gunit/ITestCase.java", "methodName": "org.antlr.gunit.ITestCase.getTestCaseIndex", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public int getTestCaseIndex();", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName)MethodDeclaration", "methodDoc": "Get the index of the test case in the test group for a rule. Starting from 0.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "771", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setTarget", "methodParameterType": "File#", "methodParameterName": "targetFile#", "methodBody": "public void setTarget(File targetFile) {\n        log(\"Setting target to: \" + targetFile.toString(), Project.MSG_VERBOSE);\n        this.target = targetFile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "The grammar file to process.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.io.File.toString", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.log"], "call_func_parameter": [[""], ["java.lang.String"], [""], [""], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "772", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setOutputdirectory", "methodParameterType": "File#", "methodParameterName": "outputDirectoryFile#", "methodBody": "public void setOutputdirectory(File outputDirectoryFile) {\n        log(\"Setting output directory to: \" + outputDirectoryFile.toString(), Project.MSG_VERBOSE);\n        this.outputDirectory = outputDirectoryFile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "The directory to write the generated files to.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.io.File.toString", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.log"], "call_func_parameter": [[""], ["java.lang.String"], [""], [""], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "773", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.getOutputdirectory", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public File getOutputdirectory() {\n        return outputDirectory;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(SimpleName)SimpleName)ReturnStatement)Block)MethodDeclaration", "methodDoc": "The directory to write the generated files to.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "774", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setLibdirectory", "methodParameterType": "File#", "methodParameterName": "libDirectoryFile#", "methodBody": "public void setLibdirectory(File libDirectoryFile) {\n        log(\"Setting lib directory to: \" + libDirectoryFile.toString(), Project.MSG_VERBOSE);\n        this.libDirectory = libDirectoryFile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "The token files output directory.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.io.File.toString", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.log"], "call_func_parameter": [[""], ["java.lang.String"], [""], [""], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "775", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setMessageformat", "methodParameterType": "String#", "methodParameterName": "name#", "methodBody": "public void setMessageformat(String name) {\n        log(\"Setting message-format to: \" + name, Project.MSG_VERBOSE);\n        this.messageFormatName = name;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "The output style for messages.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.log"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "776", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setGlib", "methodParameterType": "File#", "methodParameterName": "superGrammarFile#", "methodBody": "public void setGlib(File superGrammarFile) {\n        this.superGrammar = superGrammarFile;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets an optional super grammar file", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "777", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDebug", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setDebug(boolean enable) {\n        this.debug = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to enable ParseView debugging", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "778", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setReport", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setReport(boolean enable) {\n        this.report = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to enable report statistics", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "779", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setPrint", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setPrint(boolean enable) {\n        this.print = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to print out the grammar without actions", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "780", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setProfile", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setProfile(boolean enable) {\n        this.profile = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to enable profiling", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "781", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setNfa", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setNfa(boolean enable) {\n        this.nfa = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to enable nfa generation", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "782", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDfa", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setDfa(boolean enable) {\n        this.dfa = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to enable nfa generation", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "783", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setMultithreaded", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setMultithreaded(boolean enable) {\n        multiThreaded = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Run the analysis multithreaded", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "784", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setNocollapse", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setNocollapse(boolean enable) {\n        nocollapse = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "collapse incident edges into DFA states", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "785", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setNoprune", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setNoprune(boolean enable) {\n        noprune = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "test lookahead against EBNF block exit branches", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "786", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDbgST", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setDbgST(boolean enable) {\n        dbgST = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "test lookahead against EBNF block exit branches", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "787", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setConversiontimeout", "methodParameterType": "String#", "methodParameterName": "conversiontimeoutString#", "methodBody": "public void setConversiontimeout(String conversiontimeoutString) {\n        log(\"Setting conversiontimeout to: \" + conversiontimeoutString, Project.MSG_VERBOSE);\n        try {\n            int timeout = Integer.valueOf(conversiontimeoutString);\n            this.conversiontimeout = conversiontimeoutString;\n        } catch (NumberFormatException e) {\n            log(\"Option ConversionTimeOut ignored due to illegal value: '\" + conversiontimeoutString + \"'\", Project.MSG_ERR);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#PrimitiveType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#CatchClause#TryStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(TryStatement(Block(VariableDeclarationStatement(PrimitiveType)PrimitiveType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)CatchClause)TryStatement)Block)MethodDeclaration", "methodDoc": "override the default conversion timeout with -Xconversiontimeout nnnn", "call_func_name": ["java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.log", "java.lang.Integer.valueOf", "java.lang.Integer.intValue"], "call_func_parameter": [[""], ["java.lang.String"], [""], ["java.lang.String", "int"], ["java.lang.String"], [""]], "passed_comments": "/"}, {"index": "788", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setGrammartree", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setGrammartree(boolean enable) {\n        grammarTree = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set a flag to enable printing of the grammar tree", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "789", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDepend", "methodParameterType": "boolean#", "methodParameterName": "s#", "methodBody": "public void setDepend(boolean s) {\n        this.depend = s;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Set a flag to enable dependency checking by ANTLR itself The depend option is always used implicitely inside the antlr3 task", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "790", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDiagnostic", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setDiagnostic(boolean enable) {\n        diagnostic = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sets a flag to emit diagnostic text", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "791", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setTrace", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setTrace(boolean enable) {\n        trace = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If true, enables all tracing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "792", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setTraceParser", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setTraceParser(boolean enable) {\n        traceParser = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If true, enables parser tracing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "793", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setTraceLexer", "methodParameterType": "boolean#", "methodParameterName": "enable#", "methodBody": "public void setTraceLexer(boolean enable) {\n        traceLexer = enable;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "If true, enables lexer tracing.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "794", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setFork", "methodParameterType": "boolean#", "methodParameterName": "s#", "methodBody": "public void setFork(boolean s) {\n        this.fork = s;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#PrimitiveType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(PrimitiveType)PrimitiveType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "@ant.attribute ignore=\"true\"", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "795", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.setDir", "methodParameterType": "File#", "methodParameterName": "d#", "methodBody": "public void setDir(File d) {\n        this.workingdir = d;\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "The working directory of the process", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "796", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.createClasspath", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Path createClasspath() {\n        return commandline.createClasspath(getProject()).createPath();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Adds a classpath to be set because a directory might be given for Antlr debug.", "call_func_name": ["org.apache.tools.ant.antlr.ANTLR3.getProject", "org.apache.tools.ant.types.CommandlineJava.createClasspath", "org.apache.tools.ant.types.Path.createPath"], "call_func_parameter": [[""], ["org.apache.tools.ant.Project"], [""]], "passed_comments": "/"}, {"index": "797", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.createJvmarg", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public Commandline.Argument createJvmarg() {\n        return commandline.createVmArgument();\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#QualifiedName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)SimpleType(SimpleName)SimpleName(Block(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "Adds a new JVM argument.", "call_func_name": ["org.apache.tools.ant.types.CommandlineJava.createVmArgument"], "call_func_parameter": [[""]], "passed_comments": "/"}, {"index": "798", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.init", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "@Override\n    public void init() throws BuildException {\n        /* Inquire environment variables */\n        Map<String, String> variables = System.getenv();\n        /* Get value for key \"ANTLR_HOME\" which should hopefully point to\n         * the directory where the current version of antlr3 is installed */\n        String antlrHome = variables.get(\"ANTLR_HOME\");\n        if (antlrHome != null) {\n            /* Environment variable ANTLR_HOME has been defined.\n             * Now add all antlr and stringtemplate libraries to the\n             * classpath */\n            addAntlrJarsToClasspath(antlrHome + \"/lib\");\n        }\n        addClasspathEntry(\"/antlr/ANTLRGrammarParseBehavior.class\", \"AntLR2\");\n        addClasspathEntry(\"/org/antlr/tool/ANTLRParser.class\", \"AntLR3\");\n        addClasspathEntry(\"/org/antlr/stringtemplate/StringTemplate.class\", \"Stringtemplate\");\n\n\n    }", "AST": "Javadoc#SimpleName#MarkerAnnotation#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#StringLiteral#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#StringLiteral#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#StringLiteral#StringLiteral#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(MarkerAnnotation(SimpleName)SimpleName)MarkerAnnotation(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Adds the jars or directories containing Antlr and associates. This should make the forked JVM work without having to specify it directly.", "call_func_name": ["java.lang.System.getenv", "java.util.Map.get", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.apache.tools.ant.antlr.ANTLR3.addAntlrJarsToClasspath", "org.apache.tools.ant.antlr.ANTLR3.addClasspathEntry"], "call_func_parameter": [[""], ["java.lang.Object"], [""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.String", "java.lang.String"]], "passed_comments": [{"org.apache.tools.ant.antlr.ANTLR3.addAntlrJarsToClasspath": "If the environment variable ANTLR_HOME is defined and points to the installation directory of antlr3 then look for all antlr-"}, {"org.apache.tools.ant.antlr.ANTLR3.addClasspathEntry": "Search for the given resource and add the directory or archive that contains it to the classpath. <p>Doesn't work for archives in JDK 1.1 as the URL returned by getResource doesn't contain the name of the archive.</p>"}]}, {"index": "799", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.addClasspathEntry", "methodParameterType": "String#String#", "methodParameterName": "resource#msg#", "methodBody": "protected void addClasspathEntry(String resource, String msg) {\n        /*\n         * pre Ant 1.6 this method used to call getClass().getResource\n         * while Ant 1.6 will call ClassLoader.getResource().\n         *\n         * The difference is that Class.getResource expects a leading\n         * slash for \"absolute\" resources and will strip it before\n         * delegating to ClassLoader.getResource - so we now have to\n         * emulate Class's behavior.\n         */\n        if (resource.startsWith(\"/\")) {\n            resource = resource.substring(1);\n        } else {\n            resource = \"org/apache/tools/ant/taskdefs/optional/\" + resource;\n        }\n\n        File f = LoaderUtils.getResourceSource(getClass().getClassLoader(), resource);\n        if (f != null) {\n            log(\"Found via classpath: \" + f.getAbsolutePath(), Project.MSG_VERBOSE);\n            createClasspath().setLocation(f);\n        } else {\n            log(\"Couldn\\'t find resource \" + resource + \" for library \" + msg + \" in external classpath\", Project.MSG_VERBOSE);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#StringLiteral#MethodInvocation#SimpleName#SimpleName#SimpleName#NumberLiteral#MethodInvocation#Assignment#ExpressionStatement#Block#SimpleName#StringLiteral#SimpleName#InfixExpression#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#StringLiteral#SimpleName#StringLiteral#SimpleName#StringLiteral#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(NumberLiteral)NumberLiteral)MethodInvocation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Search for the given resource and add the directory or archive that contains it to the classpath. <p>Doesn't work for archives in JDK 1.1 as the URL returned by getResource doesn't contain the name of the archive.</p>", "call_func_name": ["java.lang.String.startsWith", "java.lang.String.substring", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.lang.Object.getClass", "java.lang.Class.getClassLoader", "org.apache.tools.ant.util.LoaderUtils.getResourceSource", "java.io.File.getAbsolutePath", "org.apache.tools.ant.antlr.ANTLR3.log", "org.apache.tools.ant.antlr.ANTLR3.createClasspath", "org.apache.tools.ant.types.Path.setLocation"], "call_func_parameter": [["java.lang.String"], ["int"], [""], ["java.lang.String"], [""], [""], [""], ["java.lang.ClassLoader", "java.lang.String"], [""], ["java.lang.String", "int"], [""], ["java.io.File"]], "passed_comments": [{"org.apache.tools.ant.antlr.ANTLR3.createClasspath": "Adds a classpath to be set because a directory might be given for Antlr debug."}]}, {"index": "800", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.addAntlrJarsToClasspath", "methodParameterType": "String#", "methodParameterName": "antlrLibDir#", "methodBody": "private void addAntlrJarsToClasspath(String antlrLibDir) {\n        String[] includes = {\"antlr-*.jar\", \"stringtemplate-*.jar\"};\n\n        DirectoryScanner ds = new DirectoryScanner();\n        ds.setIncludes(includes);\n        ds.setBasedir(new File(antlrLibDir));\n        ds.setCaseSensitive(true);\n        ds.scan();\n\n        String separator = System.getProperty(\"file.separator\");\n        String[] files = ds.getIncludedFiles();\n        for (String file : files) {\n            File f = new File(antlrLibDir + separator + file);\n            log(\"Found via ANTLR_HOME: \" + f.getAbsolutePath(), Project.MSG_VERBOSE);\n            createClasspath().setLocation(f);\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#StringLiteral#StringLiteral#ArrayInitializer#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleType#SimpleName#ClassInstanceCreation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#StringLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#InfixExpression#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(ArrayInitializer(StringLiteral)StringLiteral(StringLiteral)StringLiteral)ArrayInitializer)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)ClassInstanceCreation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)MethodDeclaration", "methodDoc": "If the environment variable ANTLR_HOME is defined and points to the installation directory of antlr3 then look for all antlr-", "call_func_name": ["org.apache.tools.ant.DirectoryScanner.<init>", "org.apache.tools.ant.DirectoryScanner.setIncludes", "java.io.File.<init>", "org.apache.tools.ant.DirectoryScanner.setBasedir", "org.apache.tools.ant.DirectoryScanner.setCaseSensitive", "org.apache.tools.ant.DirectoryScanner.scan", "java.lang.System.getProperty", "org.apache.tools.ant.DirectoryScanner.getIncludedFiles", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.io.File.getAbsolutePath", "org.apache.tools.ant.antlr.ANTLR3.log", "org.apache.tools.ant.antlr.ANTLR3.createClasspath", "org.apache.tools.ant.types.Path.setLocation"], "call_func_parameter": [[""], ["java.lang.String[]"], ["java.lang.String"], ["java.io.File"], ["boolean"], [""], ["java.lang.String"], [""], [""], ["java.lang.String"], [""], [""], ["java.lang.String", "int"], [""], ["java.io.File"]], "passed_comments": [{"org.apache.tools.ant.antlr.ANTLR3.createClasspath": "Adds a classpath to be set because a directory might be given for Antlr debug."}]}, {"index": "801", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.populateAttributes", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "private void populateAttributes() {\n\n        commandline.createArgument().setValue(\"-o\");\n        commandline.createArgument().setValue(outputDirectory.toString());\n\n        commandline.createArgument().setValue(\"-lib\");\n        commandline.createArgument().setValue(libDirectory.toString());\n\n        if (superGrammar != null) {\n            log(\"Option 'glib' is not supported by ANTLR v3. Option ignored!\", Project.MSG_WARN);\n        }\n\n        if (diagnostic) {\n            commandline.createArgument().setValue(\"-diagnostic\");\n        }\n        if (depend) {\n            log(\"Option 'depend' is implicitely always used by ANTLR v3. Option can safely be omitted!\", Project.MSG_WARN);\n        }\n        if (trace) {\n            log(\"Option 'trace' is not supported by ANTLR v3. Option ignored!\", Project.MSG_WARN);\n        }\n        if (traceParser) {\n            log(\"Option 'traceParser' is not supported by ANTLR v3. Option ignored!\", Project.MSG_WARN);\n        }\n        if (traceLexer) {\n            log(\"Option 'traceLexer' is not supported by ANTLR v3. Option ignored!\", Project.MSG_WARN);\n        }\n        if (debug) {\n            commandline.createArgument().setValue(\"-debug\");\n        }\n        if (report) {\n            commandline.createArgument().setValue(\"-report\");\n        }\n        if (print) {\n            commandline.createArgument().setValue(\"-print\");\n        }\n        if (profile) {\n            commandline.createArgument().setValue(\"-profile\");\n        }\n        if (messageFormatName != null) {\n            commandline.createArgument().setValue(\"-message-format\");\n            commandline.createArgument().setValue(messageFormatName);\n        }\n        if (nfa) {\n            commandline.createArgument().setValue(\"-nfa\");\n        }\n        if (dfa) {\n            commandline.createArgument().setValue(\"-dfa\");\n        }\n        if (multiThreaded) {\n            commandline.createArgument().setValue(\"-Xmultithreaded\");\n        }\n        if (nocollapse) {\n            commandline.createArgument().setValue(\"-Xnocollapse\");\n        }\n        if (noprune) {\n            commandline.createArgument().setValue(\"-Xnoprune\");\n        }\n        if (dbgST) {\n            commandline.createArgument().setValue(\"-XdbgST\");\n        }\n        if (conversiontimeout != null) {\n            commandline.createArgument().setValue(\"-Xconversiontimeout\");\n            commandline.createArgument().setValue(conversiontimeout);\n        }\n        if (grammarTree) {\n            commandline.createArgument().setValue(\"-Xgrtree\");\n        }\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#QualifiedName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(IfStatement(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "A refactored method for populating all the command line arguments based on the user-specified attributes.", "call_func_name": ["org.apache.tools.ant.types.CommandlineJava.createArgument", "java.io.File.toString", "org.apache.tools.ant.antlr.ANTLR3.log"], "call_func_parameter": [[""], [""], ["java.lang.String", "int"]], "passed_comments": "/"}, {"index": "802", "file": "/root/repos/repos29/antlr3/antlr-ant/main/antlr3-task/antlr3-src/org/apache/tools/ant/antlr/ANTLR3.java", "methodName": "org.apache.tools.ant.antlr.ANTLR3.run", "methodParameterType": "String[]#OutputStream#OutputStream#", "methodParameterName": "command#out#err#", "methodBody": "private int run(String[] command, OutputStream out, OutputStream err) throws IOException {\n        PumpStreamHandler psh;\n        if (err == null) {\n            psh = new PumpStreamHandler(out, bos);\n        } else {\n            psh = new PumpStreamHandler(out, new TeeOutputStream(err, bos));\n        }\n\n        Execute exe = new Execute(psh, null);\n\n        exe.setAntRun(getProject());\n        if (workingdir != null) {\n            exe.setWorkingDirectory(workingdir);\n        }\n\n        exe.setCommandline(command);\n\n        return exe.execute();\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#Dimension#ArrayType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#ClassInstanceCreation#Assignment#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#NullLiteral#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#ReturnStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(ArrayType(SimpleType(SimpleName)SimpleName)SimpleType(Dimension)Dimension)ArrayType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)Assignment)ExpressionStatement)Block(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)ClassInstanceCreation)Assignment)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(NullLiteral)NullLiteral)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ReturnStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ReturnStatement)Block)MethodDeclaration", "methodDoc": "execute in a forked VM", "call_func_name": ["org.apache.tools.ant.taskdefs.PumpStreamHandler.<init>", "org.apache.tools.ant.util.TeeOutputStream.<init>", "org.apache.tools.ant.taskdefs.Execute.<init>", "org.apache.tools.ant.antlr.ANTLR3.getProject", "org.apache.tools.ant.taskdefs.Execute.setAntRun", "org.apache.tools.ant.taskdefs.Execute.setWorkingDirectory", "org.apache.tools.ant.taskdefs.Execute.setCommandline", "org.apache.tools.ant.taskdefs.Execute.execute"], "call_func_parameter": [["java.io.OutputStream", "java.io.OutputStream"], ["java.io.OutputStream", "java.io.OutputStream"], ["org.apache.tools.ant.taskdefs.ExecuteStreamHandler", "org.apache.tools.ant.taskdefs.ExecuteWatchdog"], [""], ["org.apache.tools.ant.Project"], ["java.io.File"], ["java.lang.String[]"], [""]], "passed_comments": "/"}, {"index": "803", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java", "methodName": "org.antlr.mojo.antlr3.Antlr3ErrorLog.Antlr3ErrorLog", "methodParameterType": "Log#", "methodParameterName": "log#", "methodBody": "public Antlr3ErrorLog(Log log) {\n        this.log = log;\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#ThisExpression#SimpleName#FieldAccess#SimpleName#Assignment#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(Assignment(FieldAccess(ThisExpression)ThisExpression(SimpleName)SimpleName)FieldAccess(SimpleName)SimpleName)Assignment)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Instantiate an ANTLR ErrorListner that communicates any messages it receives to the Maven error sink.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "804", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java", "methodName": "org.antlr.mojo.antlr3.Antlr3ErrorLog.info", "methodParameterType": "String#", "methodParameterName": "message#", "methodBody": "public void info(String message) {\n        log.info(message);\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sends an informational message to the Maven log sink.", "call_func_name": ["org.apache.maven.plugin.logging.Log.info"], "call_func_parameter": [["java.lang.CharSequence"]], "passed_comments": "/"}, {"index": "805", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java", "methodName": "org.antlr.mojo.antlr3.Antlr3ErrorLog.error", "methodParameterType": "Message#", "methodParameterName": "message#", "methodBody": "public void error(Message message) {\n        log.error(message.toString());\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sends an error message from ANTLR analysis to the Maven Log sink.", "call_func_name": ["java.lang.Object.toString", "org.apache.maven.plugin.logging.Log.error"], "call_func_parameter": [[""], ["java.lang.CharSequence"]], "passed_comments": "/"}, {"index": "806", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java", "methodName": "org.antlr.mojo.antlr3.Antlr3ErrorLog.warning", "methodParameterType": "Message#", "methodParameterName": "message#", "methodBody": "public void warning(Message message) {\n        log.warn(message.toString());\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sends a warning message to the Maven log sink.", "call_func_name": ["java.lang.Object.toString", "org.apache.maven.plugin.logging.Log.warn"], "call_func_parameter": [[""], ["java.lang.CharSequence"]], "passed_comments": "/"}, {"index": "807", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3ErrorLog.java", "methodName": "org.antlr.mojo.antlr3.Antlr3ErrorLog.error", "methodParameterType": "ToolMessage#", "methodParameterName": "toolMessage#", "methodBody": "public void error(ToolMessage toolMessage) {\n        log.error(toolMessage.toString());\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)MethodDeclaration", "methodDoc": "Sends an error message from the ANTLR tool to the Maven Log sink.", "call_func_name": "/", "call_func_parameter": "/", "passed_comments": "/"}, {"index": "808", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java", "methodName": "org.antlr.mojo.antlr3.Antlr3Mojo.execute", "methodParameterType": "/", "methodParameterName": "/", "methodBody": "public void execute()\n            throws MojoExecutionException, MojoFailureException {\n\n        Log log = getLog();\n\n        // Check to see if the user asked for debug information, then dump all the\n        // parameters we have picked up if they did.\n        //\n        if (log.isDebugEnabled()) {\n\n            // Excludes\n            //\n            for (String e : excludes) {\n                log.debug(\"ANTLR: Exclude: \" + e);\n            }\n\n            // Includes\n            //\n            for (String e : includes) {\n                log.debug(\"ANTLR: Include: \" + e);\n            }\n\n            // Output location\n            //\n            log.debug(\"ANTLR: Output: \" + outputDirectory);\n\n            // Library directory\n            //\n            log.debug(\"ANTLR: Library: \" + libDirectory);\n\n            // Flags\n            //\n            log.debug(\"ANTLR: report              : \" + report);\n            log.debug(\"ANTLR: printGrammar        : \" + printGrammar);\n            log.debug(\"ANTLR: debug               : \" + debug);\n            log.debug(\"ANTLR: profile             : \" + profile);\n            log.debug(\"ANTLR: nfa                 : \" + nfa);\n            log.debug(\"ANTLR: dfa                 : \" + dfa);\n            log.debug(\"ANTLR: trace               : \" + trace);\n            log.debug(\"ANTLR: messageFormat       : \" + messageFormat);\n            log.debug(\"ANTLR: maxSwitchCaseLabels : \" + maxSwitchCaseLabels);\n            log.debug(\"ANTLR: minSwitchAlts       : \" + minSwitchAlts);\n            log.debug(\"ANTLR: verbose             : \" + verbose);\n        }\n\n        // Ensure that the output directory path is all in tact so that\n        // ANTLR can just write into it.\n        //\n        File outputDir = getOutputDirectory();\n\n        if (!outputDir.exists()) {\n            outputDir.mkdirs();\n        }\n\n        // First thing we need is an instance of the ANTLR 3.1 build tool\n        //\n        try {\n            // ANTLR Tool buld interface\n            //\n            tool = new Tool();\n        } catch (Exception e) {\n            log.error(\"The attempt to create the ANTLR build tool failed, see exception report for details\");\n\n            throw new MojoFailureException(\"Jim failed you!\");\n        }\n\n        // Next we need to set the options given to us in the pom into the\n        // tool instance we have created.\n        //\n        tool.setDebug(debug);\n        tool.setGenerate_DFA_dot(dfa);\n        tool.setGenerate_NFA_dot(nfa);\n        tool.setProfile(profile);\n        tool.setReport(report);\n        tool.setPrintGrammar(printGrammar);\n        tool.setTrace(trace);\n        tool.setVerbose(verbose);\n        tool.setMessageFormat(messageFormat);\n        tool.setMaxSwitchCaseLabels(maxSwitchCaseLabels);\n        tool.setMinSwitchAlts(minSwitchAlts);\n\n        // Where do we want ANTLR to produce its output? (Base directory)\n        //\n        if (log.isDebugEnabled())\n        {\n            log.debug(\"Output directory base will be \" + outputDirectory.getAbsolutePath());\n        }\n        tool.setOutputDirectory(outputDirectory.getAbsolutePath());\n\n        // Tell ANTLR that we always want the output files to be produced in the output directory\n        // using the same relative path as the input file was to the input directory.\n        //\n        tool.setForceRelativeOutput(true);\n\n        // Where do we want ANTLR to look for .tokens and import grammars?\n        //\n        tool.setLibDirectory(libDirectory.getAbsolutePath());\n\n        if (!sourceDirectory.exists()) {\n            if (log.isInfoEnabled()) {\n                log.info(\"No ANTLR grammars to compile in \" + sourceDirectory.getAbsolutePath());\n            }\n            return;\n        } else {\n            if (log.isInfoEnabled()) {\n                log.info(\"ANTLR: Processing source directory \" + sourceDirectory.getAbsolutePath());\n            }\n        }\n\n        // Set working directory for ANTLR to be the base source directory\n        //\n        tool.setInputDirectory(sourceDirectory.getAbsolutePath());\n\n        try {\n\n            // Now pick up all the files and process them with the Tool\n            //\n            processGrammarFiles(sourceDirectory, outputDirectory);\n\n        } catch (InclusionScanException ie) {\n\n            log.error(ie);\n            throw new MojoExecutionException(\"Fatal error occured while evaluating the names of the grammar files to analyze\");\n\n        } catch (Exception e) {\n\n            getLog().error(e);\n            throw new MojoExecutionException(e.getMessage());\n        }\n\n\n\n        tool.process();\n\n        // If any of the grammar files caused errors but did nto throw exceptions\n        // then we should have accumulated errors in the counts\n        //\n        if (tool.getNumErrors() > 0) {\n            throw new MojoExecutionException(\"ANTLR caught \" + tool.getNumErrors() + \" build errors.\");\n        }\n\n        // All looks good, so we need to tel Maven about the sources that\n        // we just created.\n        //\n        if (project != null) {\n            // Tell Maven that there are some new source files underneath\n            // the output directory.\n            //\n            addSourceRoot(this.getOutputDirectory());\n        }\n\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleType#ClassInstanceCreation#Assignment#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#CatchClause#TryStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#ReturnStatement#Block#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#StringLiteral#ClassInstanceCreation#ThrowStatement#Block#CatchClause#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#MethodInvocation#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#MethodInvocation#ClassInstanceCreation#ThrowStatement#Block#CatchClause#TryStatement#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleName#MethodInvocation#NumberLiteral#InfixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#NullLiteral#InfixExpression#SimpleName#ThisExpression#SimpleName#MethodInvocation#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)IfStatement(TryStatement(Block(ExpressionStatement(Assignment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType)ClassInstanceCreation)Assignment)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)CatchClause)TryStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ReturnStatement)ReturnStatement)Block(Block(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement(TryStatement(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral)ClassInstanceCreation)ThrowStatement)Block)CatchClause(CatchClause(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)ThrowStatement)Block)CatchClause)TryStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NumberLiteral)NumberLiteral)InfixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(IfStatement(InfixExpression(SimpleName)SimpleName(NullLiteral)NullLiteral)InfixExpression(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(MethodInvocation(ThisExpression)ThisExpression(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ExpressionStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "The main entry point for this Mojo, it is responsible for converting ANTLR 3.x grammars into the target language specified by the grammar.", "call_func_name": ["org.antlr.mojo.antlr3.Antlr3Mojo.getLog", "org.apache.maven.plugin.logging.Log.isDebugEnabled", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "org.apache.maven.plugin.logging.Log.debug", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "java.lang.StringBuilder.append", "org.antlr.mojo.antlr3.Antlr3Mojo.getOutputDirectory", "java.io.File.exists", "java.io.File.mkdirs", "org.antlr.Tool.<init>", "org.apache.maven.plugin.logging.Log.error", "org.apache.maven.plugin.MojoFailureException.<init>", "org.antlr.Tool.setDebug", "org.antlr.Tool.setGenerate_DFA_dot", "org.antlr.Tool.setGenerate_NFA_dot", "org.antlr.Tool.setProfile", "org.antlr.Tool.setReport", "org.antlr.Tool.setPrintGrammar", "org.antlr.Tool.setTrace", "org.antlr.Tool.setVerbose", "org.antlr.Tool.setMessageFormat", "org.antlr.Tool.setMaxSwitchCaseLabels", "org.antlr.Tool.setMinSwitchAlts", "java.io.File.getAbsolutePath", "org.antlr.Tool.setOutputDirectory", "org.antlr.Tool.setForceRelativeOutput", "org.antlr.Tool.setLibDirectory", "org.apache.maven.plugin.logging.Log.isInfoEnabled", "org.apache.maven.plugin.logging.Log.info", "org.antlr.Tool.setInputDirectory", "org.antlr.mojo.antlr3.Antlr3Mojo.processGrammarFiles", "org.apache.maven.plugin.logging.Log.error", "org.apache.maven.plugin.MojoExecutionException.<init>", "java.lang.Exception.getMessage", "org.antlr.Tool.process", "org.antlr.Tool.getNumErrors", "org.antlr.mojo.antlr3.Antlr3Mojo.addSourceRoot"], "call_func_parameter": [[""], [""], [""], [""], [""], [""], ["java.lang.String"], [""], ["java.lang.CharSequence"], ["java.lang.Object"], ["boolean"], ["int"], [""], [""], [""], [""], ["java.lang.CharSequence"], ["java.lang.String"], ["boolean"], ["boolean"], ["boolean"], ["boolean"], ["boolean"], ["boolean"], ["boolean"], ["boolean"], ["java.lang.String"], ["int"], ["int"], [""], ["java.lang.String"], ["boolean"], ["java.lang.String"], [""], ["java.lang.CharSequence"], ["java.lang.String"], ["java.io.File", "java.io.File"], ["java.lang.Throwable"], ["java.lang.String"], [""], [""], [""], ["java.io.File"]], "passed_comments": [{"org.antlr.Tool.setDebug": "Indicate whether ANTLR should generate a debug version of the recognizer. Debug versions of a parser communicate with a debugger such as that contained in ANTLRWorks and at start up will 'hang' waiting for a connection on an IP port (49100 by default)."}, {"org.antlr.Tool.setGenerate_DFA_dot": "Indicates whether ANTLR should generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>"}, {"org.antlr.Tool.setGenerate_NFA_dot": "Indicate whether ANTLR should generate a description of all the NFAs in <a href=\"http://www.graphviz.org\">Dot format</a>"}, {"org.antlr.Tool.setProfile": "Indicate whether ANTLR should generate a version of the recognizer that gathers statistics about its execution, which it prints when it terminates."}, {"org.antlr.Tool.setReport": "Indicate whether ANTLR should generate a report of various elements of the grammar analysis, once it it has finished analyzing a grammar file."}, {"org.antlr.Tool.setPrintGrammar": "Indicate whether ANTLR should print a version of the input grammar file(s) that is stripped of any action code embedded within."}, {"org.antlr.Tool.setTrace": "Indicate whether ANTLR should generate a version of the recognizer that prints trace messages on entry and exit of each rule"}, {"org.antlr.Tool.setVerbose": "Indicate whether ANTLR should be verbose when analyzing grammar files, such as displaying the names of the files it is generating and similar information."}, {"org.antlr.Tool.setMessageFormat": "Set the message format to one of ANTLR, gnu, vs2005"}, {"org.antlr.Tool.setMaxSwitchCaseLabels": "Set the threshold of case labels beyond which ANTLR will not instruct the target template to generate switch() { case xxx: ..."}, {"org.antlr.Tool.setMinSwitchAlts": "Set the threshold of the number alts, below which ANTLR will not instruct the target template to use a switch statement."}, {"org.antlr.Tool.setOutputDirectory": "Set the location (base directory) where output files should be produced by the ANTLR tool."}, {"org.antlr.Tool.setForceRelativeOutput": "Used by build tools to force the output files to always be relative to the base output directory, even though the tool had to set the output directory to an absolute path as it cannot rely on the workign directory like command line invocation can."}, {"org.antlr.Tool.setLibDirectory": "Set the Path to the directory in which ANTLR will search for ancillary files such as .tokens vocab files and imported grammar files."}, {"org.antlr.Tool.setInputDirectory": "Set the base location of input files. Normally (when the tool is invoked from the command line), the inputDirectory is not set, but for build tools such as Maven, we need to be able to locate the input files relative to the base, as the working directory could be anywhere and changing workig directories is not a valid concept for JVMs because of threading and so on. Setting the directory just means that the getFileDirectory() method will try to open files relative to this input directory."}, {"org.antlr.mojo.antlr3.Antlr3Mojo.processGrammarFiles": "@param sourceDirectory"}, {"org.antlr.Tool.getNumErrors": "Returns the number of errors that the analysis/processing threw up."}]}, {"index": "809", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java", "methodName": "org.antlr.mojo.antlr3.Antlr3Mojo.processGrammarFiles", "methodParameterType": "File#File#", "methodParameterName": "sourceDirectory#outputDirectory#", "methodBody": "private void processGrammarFiles(File sourceDirectory, File outputDirectory)\n            throws IOException, InclusionScanException {\n        // Which files under the source set should we be looking for as grammar files\n        //\n        SourceMapping mapping = new SuffixMapping(\"g\", Collections.<String>emptySet());\n\n        // What are the sets of includes (defaulted or otherwise).\n        //\n        Set<String> includes = getIncludesPatterns();\n\n        // Now, to the excludes, we need to add the imports directory\n        // as this is autoscanned for importd grammars and so is auto-excluded from the\n        // set of gramamr fiels we shuold be analyzing.\n        //\n        excludes.add(\"imports/**\");\n\n        SourceInclusionScanner scan = new SimpleSourceInclusionScanner(includes, excludes);\n\n        scan.addSourceMapping(mapping);\n        Set<File> grammarFiles = scan.getIncludedSources(sourceDirectory, null);\n\n        if (grammarFiles.isEmpty()) {\n            if (getLog().isInfoEnabled()) {\n                getLog().info(\"No grammars to process\");\n            }\n        } else {\n\n            // Tell the ANTLR tool that we want sorted build mode\n            //\n            tool.setMake(true);\n            \n            // Iterate each grammar file we were given and add it into the tool's list of\n            // grammars to process.\n            //\n            for (File grammar : grammarFiles) {\n\n                if (getLog().isDebugEnabled()) {\n                    getLog().debug(\"Grammar file '\" + grammar.getPath() + \"' detected.\");\n                }\n\n\n                String relPath = findSourceSubdir(sourceDirectory, grammar.getPath()) + grammar.getName();\n\n                if (getLog().isDebugEnabled()) {\n                    getLog().debug(\"  ... relative path is: \" + relPath);\n                }\n                tool.addGrammarFile(relPath);\n\n            }\n\n        }\n\n\n    }", "AST": "Javadoc#Modifier#PrimitiveType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#StringLiteral#SimpleName#SimpleName#SimpleType#SimpleName#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SimpleType#ParameterizedType#SimpleName#SimpleName#SimpleName#SimpleName#NullLiteral#MethodInvocation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#StringLiteral#MethodInvocation#ExpressionStatement#Block#IfStatement#Block#SimpleName#SimpleName#BooleanLiteral#MethodInvocation#ExpressionStatement#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#StringLiteral#SimpleName#SimpleName#MethodInvocation#StringLiteral#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#SimpleName#SimpleName#MethodInvocation#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#MethodInvocation#SimpleName#StringLiteral#SimpleName#InfixExpression#MethodInvocation#ExpressionStatement#Block#IfStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#ExpressionStatement#Block#EnhancedForStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(PrimitiveType)PrimitiveType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SimpleName)SimpleName)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement(VariableDeclarationStatement(ParameterizedType(SimpleType(SimpleName)SimpleName)SimpleType(SimpleType(SimpleName)SimpleName)SimpleType)ParameterizedType(VariableDeclarationFragment(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName(NullLiteral)NullLiteral)MethodInvocation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(Block(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(StringLiteral)StringLiteral)MethodInvocation)ExpressionStatement)Block)IfStatement)Block(Block(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(BooleanLiteral)BooleanLiteral)MethodInvocation)ExpressionStatement(EnhancedForStatement(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SimpleName)SimpleName(Block(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(StringLiteral)StringLiteral)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName)MethodInvocation(Block(ExpressionStatement(MethodInvocation(MethodInvocation(SimpleName)SimpleName)MethodInvocation(SimpleName)SimpleName(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)MethodInvocation)ExpressionStatement)Block)IfStatement(ExpressionStatement(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)ExpressionStatement)Block)EnhancedForStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "@param sourceDirectory", "call_func_name": ["java.util.Collections.emptySet", "org.codehaus.plexus.compiler.util.scan.mapping.SuffixMapping.<init>", "org.antlr.mojo.antlr3.Antlr3Mojo.getIncludesPatterns", "java.util.Set.add", "org.codehaus.plexus.compiler.util.scan.SimpleSourceInclusionScanner.<init>", "org.codehaus.plexus.compiler.util.scan.SourceInclusionScanner.addSourceMapping", "org.codehaus.plexus.compiler.util.scan.SourceInclusionScanner.getIncludedSources", "java.util.Set.isEmpty", "org.antlr.mojo.antlr3.Antlr3Mojo.getLog", "org.apache.maven.plugin.logging.Log.isInfoEnabled", "org.apache.maven.plugin.logging.Log.info", "org.antlr.Tool.setMake", "java.util.Set.iterator", "java.util.Iterator.hasNext", "java.util.Iterator.next", "org.apache.maven.plugin.logging.Log.isDebugEnabled", "java.lang.StringBuilder.<init>", "java.lang.StringBuilder.append", "java.io.File.getPath", "java.lang.StringBuilder.toString", "org.apache.maven.plugin.logging.Log.debug", "org.antlr.mojo.antlr3.Antlr3Mojo.findSourceSubdir", "java.io.File.getName", "org.antlr.Tool.addGrammarFile"], "call_func_parameter": [[""], ["java.lang.String", "java.util.Set"], [""], ["java.lang.Object"], ["java.util.Set", "java.util.Set"], ["org.codehaus.plexus.compiler.util.scan.mapping.SourceMapping"], ["java.io.File", "java.io.File"], [""], [""], [""], ["java.lang.CharSequence"], ["boolean"], [""], [""], [""], [""], [""], ["java.lang.String"], [""], [""], ["java.lang.CharSequence"], ["java.io.File", "java.lang.String"], [""], ["java.lang.String"]], "passed_comments": [{"org.antlr.Tool.setMake": "Indicate whether the tool should analyze the dependencies of the provided grammar file list and ensure that the grammars with dependencies are built after any of the other gramamrs in the list that they are dependent on. Setting this option also has the side effect that any grammars that are includes for other grammars in the list are excluded from individual analysis, which allows the caller to invoke the tool via org.antlr.tool -make"}, {"org.antlr.mojo.antlr3.Antlr3Mojo.findSourceSubdir": "Given the source directory File object and the full PATH to a grammar, produce the path to the named grammar file in relative terms to the  {@code sourceDirectory}. This will then allow ANTLR to produce output relative to the base of the output directory and reflect the input organization of the grammar files."}]}, {"index": "810", "file": "/root/repos/repos29/antlr3/antlr3-maven-plugin/src/main/java/org/antlr/mojo/antlr3/Antlr3Mojo.java", "methodName": "org.antlr.mojo.antlr3.Antlr3Mojo.findSourceSubdir", "methodParameterType": "File#String#", "methodParameterName": "sourceDirectory#grammarFileName#", "methodBody": "private String findSourceSubdir(File sourceDirectory, String grammarFileName) {\n        String srcPath = sourceDirectory.getPath() + File.separator;\n\n        if (!grammarFileName.startsWith(srcPath)) {\n            throw new IllegalArgumentException(\"expected \" + grammarFileName + \" to be prefixed with \" + sourceDirectory);\n        }\n\n        File unprefixedGrammarFileName = new File(grammarFileName.substring(srcPath.length()));\n\tif ( unprefixedGrammarFileName.getParent()!=null ) {\n\t    return unprefixedGrammarFileName.getParent() + File.separator;\n        }\n\telse {\n            return \"\";\n\t}\n    }", "AST": "Javadoc#Modifier#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SingleVariableDeclaration#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#SimpleName#MethodInvocation#PrefixExpression#SimpleName#SimpleType#StringLiteral#SimpleName#StringLiteral#SimpleName#InfixExpression#ClassInstanceCreation#ThrowStatement#Block#IfStatement#SimpleName#SimpleType#SimpleName#SimpleName#SimpleType#SimpleName#SimpleName#SimpleName#SimpleName#MethodInvocation#MethodInvocation#ClassInstanceCreation#VariableDeclarationFragment#VariableDeclarationStatement#SimpleName#SimpleName#MethodInvocation#NullLiteral#InfixExpression#SimpleName#SimpleName#MethodInvocation#SimpleName#SimpleName#QualifiedName#InfixExpression#ReturnStatement#Block#StringLiteral#ReturnStatement#Block#IfStatement#Block#MethodDeclaration#", "SBT": "(MethodDeclaration(Modifier)Modifier(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(SingleVariableDeclaration(SimpleType(SimpleName)SimpleName)SimpleType(SimpleName)SimpleName)SingleVariableDeclaration(Block(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(PrefixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)PrefixExpression(Block(ThrowStatement(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(InfixExpression(StringLiteral)StringLiteral(SimpleName)SimpleName(StringLiteral)StringLiteral(SimpleName)SimpleName)InfixExpression)ClassInstanceCreation)ThrowStatement)Block)IfStatement(VariableDeclarationStatement(SimpleType(SimpleName)SimpleName)SimpleType(VariableDeclarationFragment(SimpleName)SimpleName(ClassInstanceCreation(SimpleType(SimpleName)SimpleName)SimpleType(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation)MethodInvocation)ClassInstanceCreation)VariableDeclarationFragment)VariableDeclarationStatement(IfStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(NullLiteral)NullLiteral)InfixExpression(Block(ReturnStatement(InfixExpression(MethodInvocation(SimpleName)SimpleName(SimpleName)SimpleName)MethodInvocation(QualifiedName(SimpleName)SimpleName(SimpleName)SimpleName)QualifiedName)InfixExpression)ReturnStatement)Block(Block(ReturnStatement(StringLiteral)StringLiteral)ReturnStatement)Block)IfStatement)Block)MethodDeclaration", "methodDoc": "Given the source directory File object and the full PATH to a grammar, produce the path to the named grammar file in relative terms to the  {@code sourceDirectory}. This will then allow ANTLR to produce output relative to the base of the output directory and reflect the input organization of the grammar files.", "call_func_name": ["java.lang.StringBuilder.<init>", "java.io.File.getPath", "java.lang.StringBuilder.append", "java.lang.StringBuilder.toString", "java.lang.String.startsWith", "java.lang.StringBuilder.append", "java.lang.IllegalArgumentException.<init>", "java.lang.String.length", "java.lang.String.substring", "java.io.File.<init>", "java.io.File.getParent"], "call_func_parameter": [[""], [""], ["java.lang.String"], [""], ["java.lang.String"], ["java.lang.Object"], ["java.lang.String"], [""], ["int"], ["java.lang.String"], [""]], "passed_comments": "/"}]